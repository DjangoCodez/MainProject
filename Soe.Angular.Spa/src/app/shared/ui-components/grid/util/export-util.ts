import { DateUtil } from '@shared/util/date-util';
import { AgGridAngular } from 'ag-grid-angular';
import {
  SelectColumnOptions,
  SoeColumnType,
  AutocompleteColumnOptions,
} from './column-util';
import { printPdfDoc } from '../pdf-export/print-doc';
import {
  ColDef,
  ExcelStyle,
  GridApi,
  ProcessRowGroupForExportParams,
} from 'ag-grid-community';
import { getAutocompleteCacheKey } from '../cell-editors/autocomplete-cell-editor/autocomplete-cell-editor.component';
import { ISoeExportExcelOptions } from '../interfaces/export-excel-options.interface';

export enum GridExportType {
  Excel,
  ExcelTable,
  Csv,
  Pdf,
}

export class ExportUtil {
  static excelStyles: ExcelStyle[] = [
    {
      id: 'excelDate',
      dataType: 'DateTime',
      numberFormat: { format: 'yyyy-MM-dd' },
    },
    {
      id: 'excelTime',
      dataType: 'DateTime',
      numberFormat: { format: '[hh]:mm;@' },
    },
  ];

  static exportRows(
    agGrid: AgGridAngular,
    agGridApi: GridApi,
    exportExcelOptions: ISoeExportExcelOptions | undefined,
    exportFilename: string,
    exportType: GridExportType,
    allRows = false
  ) {
    let exportCaller: () => void;

    // Get columns to export
    const columnDefs: ColDef[] = agGrid.api
      .getAllDisplayedColumns()
      .map(c => c.getColDef() as ColDef);

    //Grouped column and Total columns, columnId is 'ag-Grid-AutoColumn'(auto generated by agGrid itself)
    //hence, adding 'ag-Grid-AutoColumn' columnId when row group & total columns are available
    const columnKeys: string[] = columnDefs
      .filter(c => (c.field || c.showRowGroup) && !c.context.suppressExport)
      .map(c => c.field ?? 'ag-Grid-AutoColumn');

    switch (exportType) {
      case GridExportType.Excel:
      case GridExportType.ExcelTable:
        exportCaller = () =>
          agGrid.api.exportDataAsExcel({
            exportAsExcelTable: exportType === GridExportType.ExcelTable,
            fileName: exportFilename + '.xlsx',
            sheetName: exportFilename,
            columnKeys: columnKeys,
            exportedRows: allRows ? 'all' : 'filteredAndSorted',
            rowGroupExpandState: exportExcelOptions?.rowGroupExpandState
              ? exportExcelOptions.rowGroupExpandState
              : 'match',
            processRowGroupCallback: (
              params: ProcessRowGroupForExportParams
            ) => {
              const { node } = params;
              if (!node.footer) {
                return exportExcelOptions?.termGroupedFooter
                  ? exportExcelOptions.termGroupedFooter + ': ' + node.key
                  : `row group: ${node.key}`;
              }
              const isRootLevel = node.level === -1;
              if (isRootLevel) {
                return exportExcelOptions?.termGroupedGrandTotal
                  ? exportExcelOptions?.termGroupedGrandTotal
                  : 'Grand Total';
              }
              return exportExcelOptions?.termGroupedSubTotal
                ? exportExcelOptions?.termGroupedSubTotal +
                    ' (' +
                    node.key +
                    ')'
                : `Sub Total (${node.key})`;
            },
            processCellCallback: ({ value, column, node, context }) => {
              if (value && column.getColDef()) {
                const colDef = column.getColDef();
                const columnType = colDef.context.soeColumnType;

                if (colDef.showRowGroup) {
                  // Grouped columns have the value "row group:" before it's actual name.
                  // Replace it with the node key whick will be it's name.
                  value = node?.key;
                }

                if (columnType === SoeColumnType.Select) {
                  if (typeof value === 'number') {
                    const colOption = colDef.context
                      .options as SelectColumnOptions<any, any>;
                    let option: any = undefined;
                    //First check whether dynamicSelectOptions are available
                    //if not check selectOptions
                    if (
                      typeof colDef.cellEditorParams.values === 'function' &&
                      node
                    ) {
                      //select option from dynamicOptions
                      option = colDef.cellEditorParams
                        .values(node)
                        .find(
                          (x: any) => x[colOption?.dropDownIdLabel!] === value
                        );
                    } else {
                      //select option from selectOptions
                      option = colDef.cellEditorParams.values?.find(
                        (x: any) => x[colOption?.dropDownIdLabel!] === value
                      );
                    }
                    return option[colOption?.dropDownValueLabel!] ?? '';
                  }
                } else if (columnType === SoeColumnType.Autocomplete) {
                  if (typeof value === 'number' && node) {
                    const contextKey = getAutocompleteCacheKey(
                      String(colDef.field)
                    );

                    const item = context[contextKey]?.find(
                      (x: any) =>
                        x[
                          (
                            colDef.context.options as AutocompleteColumnOptions<
                              any,
                              any
                            >
                          )?.optionIdField!
                        ] === value
                    );

                    if (item) {
                      return item[
                        (
                          colDef.context.options as AutocompleteColumnOptions<
                            any,
                            any
                          >
                        )?.optionNameField!
                      ];
                    } else {
                      return node.data[
                        (
                          colDef.context.options as AutocompleteColumnOptions<
                            any,
                            any
                          >
                        )?.optionDisplayNameField!
                      ];
                    }
                  }
                } else {
                  const isTime: boolean =
                    columnType === SoeColumnType.Time ||
                    columnType === SoeColumnType.TimeSpan;

                  if (
                    !!value?.toFormattedDate &&
                    typeof value?.toFormattedDate === 'function'
                  ) {
                    return isTime
                      ? (value as Date).toFormattedTime(true)
                      : (value as Date).toFormattedDate(
                          DateUtil.dateFnsLanguageDateFormats
                        );
                  } else if (isTime) {
                    //should have excelTime class on it to get right datatype in excel
                    if ((<any>colDef).minutesToTimeSpan)
                      value = DateUtil.minutesToTimeSpan(value);
                    return DateUtil.parseTimeSpan(
                      value.toString(),
                      true,
                      true,
                      true,
                      true
                    );
                  }
                }
              }

              return value;
            },
          });
        break;
      case GridExportType.Csv:
        exportCaller = () =>
          agGrid.api.exportDataAsCsv({
            fileName: exportFilename + '.csv',
            columnKeys: columnKeys,
            exportedRows: allRows ? 'all' : 'filteredAndSorted',
          });
        break;
      case GridExportType.Pdf:
        exportCaller = () => {
          printPdfDoc(agGridApi, exportFilename + '.pdf');
        };
        break;
      default:
        throw 'Unsupported export format';
    }

    exportCaller();
  }
}
