using Microsoft.VisualBasic.FileIO;
using Newtonsoft.Json;
using Soe.Sys.Common.DTO;
using SoftOne.Soe.Business.DataCache;
using SoftOne.Soe.Business.Util;
using SoftOne.Soe.Business.Util.Config;
using SoftOne.Soe.Business.Util.ImportSpecials;
using SoftOne.Soe.Business.Util.ImportSpecials.Interfaces;
using SoftOne.Soe.Business.Util.LogCollector;
using SoftOne.Soe.Common.DTO;
using SoftOne.Soe.Common.Util;
using SoftOne.Soe.Data;
using SoftOne.Soe.Shared.DTO;
using SoftOne.Soe.Util;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Entity;
using System.Data.Entity.Core.Objects;
using System.Data.Entity.Core.Objects.DataClasses;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Transactions;
using System.Xml.Linq;

namespace SoftOne.Soe.Business.Core
{
    public class PayrollManager : ManagerBase
    {
        #region Variables

        // Create a logger for use in this class
        private readonly log4net.ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);

        #endregion

        #region Ctor

        public PayrollManager(ParameterObject parameterObject) : base(parameterObject) { }

        #endregion

        #region AccountProvision

        public List<string> GetAccountProvisionBaseColumns(int timePeriodId, int actorCompanyId)
        {
            Dictionary<int, string> dict = new Dictionary<int, string>();
            var timePeriods = TimePeriodManager.GetTimePeriodsToDate(12, timePeriodId, actorCompanyId);

            int timePeriodPosition = 12;
            foreach (TimePeriod timePeriod in timePeriods.OrderByDescending(i => i.StopDate))
            {
                if (timePeriodPosition <= 0)
                    break;

                DateTime date = timePeriod.StartDate;
                string monthName = StringUtility.CamelCaseWord(Thread.CurrentThread.CurrentCulture.DateTimeFormat.GetAbbreviatedMonthName(date.Month));
                dict.Add(timePeriodPosition, String.Format("{0} {1}/{2}", monthName, DateTime.DaysInMonth(date.Year, date.Month), 166));

                timePeriodPosition--;
            }
            while (timePeriodPosition > 0)
            {
                dict.Add(timePeriodPosition--, String.Empty);
            }

            return dict.OrderBy(d => d.Key).Select(d => d.Value).ToList();
        }

        public List<AccountProvisionBaseDTO> GetAccountProvisionBaseFromFTP(int timePeriodId, int actorCompanyId, List<AccountProvisionBaseDTO> oldAccountProvisionBaseDTOs)
        {
            var timeperiod = TimePeriodManager.GetTimePeriod(timePeriodId, actorCompanyId);
            var dim = AccountManager.GetAccountDimByNr(2, actorCompanyId);
            var accounts = AccountManager.GetAccountInternalsByDim(dim.AccountDimId, actorCompanyId);
            string fileName = "Mystery_shopping_" + (timeperiod.StartDate.Year - 2000).ToString() + (timeperiod.StartDate.Month < 10 ? "0" + timeperiod.StartDate.Month : timeperiod.StartDate.Month.ToString()) + ".csv";
            string ftp = "ftp://best.betterbusiness.se";
            string userName = "Tele2";
            Uri downloadUri = new Uri(ftp.ToString().TrimEnd('/') + "/" + fileName);
            List<AccountProvisionBaseDTO> dtos = new List<AccountProvisionBaseDTO>();

            try
            {
                var file = FtpUtility.DownloadData(downloadUri, userName, "");

                if (DefenderUtil.IsVirus(file))
                {
                    LogCollector.LogError($"GetAccountProvisionBaseFromFTP Virus detected {downloadUri}");
                    file = null;
                }

                string csv = Encoding.UTF8.GetString(file);

                using (TextFieldParser parser = new TextFieldParser(new StringReader(csv)))
                {
                    parser.TextFieldType = FieldType.Delimited;
                    parser.SetDelimiters(";");
                    while (!parser.EndOfData)
                    {
                        AccountProvisionBaseDTO accountProvisionBaseDTO = new AccountProvisionBaseDTO();

                        string[] fields = parser.ReadFields();
                        int count = 0;
                        foreach (string field in fields)
                        {
                            count++;

                            if (count == 4)
                                break;

                            if (count == 1)
                            {
                                if (!string.IsNullOrEmpty(field))
                                {
                                    var account = accounts.FirstOrDefault(s => s.Account.AccountNr == field);
                                    if (account != null)
                                    {
                                        accountProvisionBaseDTO.AccountId = account.AccountId;
                                    }
                                }
                            }
                            else if (count == 3 && !string.IsNullOrEmpty(field))
                            {
                                decimal.TryParse(field, out decimal value);
                                accountProvisionBaseDTO.Period12Value = value * 100;
                            }
                        }

                        dtos.Add(accountProvisionBaseDTO);
                    }
                }
            }
            catch (Exception ex)
            {
                LogError(ex, this.log);
            }

            foreach (var dto in oldAccountProvisionBaseDTOs)
            {
                var newDTO = dtos.FirstOrDefault(d => d.AccountId == dto.AccountId);
                if (newDTO != null && newDTO.Period12Value != 0)
                    dto.Period12Value = newDTO.Period12Value;
            }

            return oldAccountProvisionBaseDTOs;
        }

        public List<AccountProvisionBaseDTO> GetAccountProvisionBase(int timePeriodId, int actorCompanyId)
        {
            var dtos = new List<AccountProvisionBaseDTO>();

            int accountProvisionAccountDimId = SettingManager.GetIntSetting(SettingMainType.Company, (int)CompanySettingType.PayrollAccountProvisionAccountDim, 0, actorCompanyId, 0);
            if (accountProvisionAccountDimId == 0)
                return dtos;

            var accountInternals = AccountManager.GetAccountInternalsByDim(accountProvisionAccountDimId, actorCompanyId, active: true);
            if (accountInternals == null || accountInternals.Count == 0)
                return dtos;

            var timePeriods = TimePeriodManager.GetTimePeriodsToDate(12, timePeriodId, actorCompanyId, loadTimePeriodAccountValue: true);

            foreach (var accountInternal in accountInternals)
            {
                var baseDTO = new AccountProvisionBaseDTO()
                {
                    TimePeriodId = timePeriodId,
                    AccountId = accountInternal.AccountId,
                    AccountNr = accountInternal.Account.AccountNr,
                    AccountName = accountInternal.Account.Name,
                    AccountDescription = accountInternal.Account.Description,
                };

                int timePeriodPosition = 12;
                foreach (var timePeriod in timePeriods.OrderByDescending(i => i.StopDate))
                {
                    decimal value = 0;
                    TimePeriodAccountValue timePeriodAccountValue = timePeriod.TimePeriodAccountValue.FirstOrDefault(i => i.AccountId == accountInternal.AccountId && i.Type == (int)SoeTimePeriodAccountValueType.Provision && i.State == (int)SoeEntityState.Active);
                    if (timePeriodAccountValue != null)
                    {
                        value = timePeriodAccountValue.Value;
                        if (timePeriodPosition == 12)
                        {
                            baseDTO.TimePeriodAccountValueId = timePeriodAccountValue.TimePeriodAccountValueId;
                            baseDTO.IsLocked = timePeriodAccountValue.Status == (int)SoeTimePeriodAccountValueStatus.Locked;
                            baseDTO.IsModified = false;
                        }
                    }
                    else if (timePeriodPosition == 12)
                    {
                        baseDTO.IsLocked = false;
                        baseDTO.IsModified = true;
                    }

                    baseDTO.SetValue(timePeriodPosition, value);
                    timePeriodPosition--;
                }

                dtos.Add(baseDTO);
            }

            //Tele2 Fetch from FTP
            if (base.IsTele2(actorCompanyId))
                return GetAccountProvisionBaseFromFTP(timePeriodId, actorCompanyId, dtos);

            return dtos;
        }

        public List<AccountProvisionTransactionGridDTO> GetAccountProvisionTransactions(int timePeriodId, int actorCompanyId, int userId)
        {
            var dtos = new List<AccountProvisionTransactionGridDTO>();

            int accountProvisionAccountDimId = SettingManager.GetIntSetting(SettingMainType.Company, (int)CompanySettingType.PayrollAccountProvisionAccountDim, 0, actorCompanyId, 0);
            if (accountProvisionAccountDimId == 0)
                return dtos;

            TimePeriod timePeriod = TimePeriodManager.GetTimePeriod(timePeriodId, actorCompanyId, loadTimePeriodAccountValue: true);
            if (timePeriod == null)
                return dtos;

            List<Employee> employees = EmployeeManager.GetEmployeesForUsersAttestRoles(out _, actorCompanyId, userId, 0, addContactInfo: true);
            if (employees.IsNullOrEmpty())
                return dtos;

            List<AttestState> attestStates = AttestManager.GetAttestStates(actorCompanyId, TermGroup_AttestEntity.PayrollTime, SoeModule.Time);
            if (attestStates.IsNullOrEmpty())
                return dtos;

            List<TimePayrollTransaction> timePayrollTransactions = TimeTransactionManager.GetTimePayrollTransactionsForAccountProvision(actorCompanyId, employees, timePeriod, loadExtended: true, loadTimeBlockDate: true, loadAccountInternals: true);
            if (timePayrollTransactions.IsNullOrEmpty())
                return dtos;

            foreach (var timePayrollTransaction in timePayrollTransactions)
            {
                AccountInternal accountInternal = timePayrollTransaction.AccountInternal?.FirstOrDefault(a => a.Account?.AccountDimId == accountProvisionAccountDimId);
                if (accountInternal == null)
                    continue;

                AttestState attestState = attestStates.FirstOrDefault(s => s.AttestStateId == timePayrollTransaction.AttestStateId);
                if (attestState == null)
                    continue;

                Employee employee = employees.FirstOrDefault(e => e.EmployeeId == timePayrollTransaction.EmployeeId);
                if (employee == null)
                    continue;

                dtos.Add(new AccountProvisionTransactionGridDTO
                {
                    TimePayrollTransactionId = timePayrollTransaction.TimePayrollTransactionId,
                    EmployeeNr = employee.EmployeeNr,
                    EmployeeFirstName = employee.ContactPerson.FirstName,
                    EmployeeLastName = employee.ContactPerson.LastName,
                    EmploymentStartDate = employee.Employment.GetFirstEmployment()?.DateFrom,
                    EmploymentEndDate = employee.Employment.GetLastEmployment()?.DateTo,
                    AccountId = accountInternal.AccountId,
                    AccountName = accountInternal.Account.Name,
                    AccountNr = accountInternal.Account.AccountNr,
                    AccountDescription = accountInternal.Account.Description,
                    AttestStateId = attestState.AttestStateId,
                    AttestStateColor = attestState.Color,
                    AttestStateName = attestState.Name,
                    Date = timePayrollTransaction.TimeBlockDate.Date,
                    Amount = timePayrollTransaction.Amount ?? 0,
                    Quantity = timePayrollTransaction.Quantity,
                    Formula = timePayrollTransaction.TimePayrollTransactionExtended?.Formula,
                    FormulaPlain = timePayrollTransaction.TimePayrollTransactionExtended?.FormulaPlain,
                    FormulaNames = timePayrollTransaction.TimePayrollTransactionExtended?.FormulaNames,
                    FormulaExtracted = timePayrollTransaction.TimePayrollTransactionExtended?.FormulaExtracted,
                    FormulaOrigin = timePayrollTransaction.TimePayrollTransactionExtended?.FormulaOrigin,
                    Comment = timePayrollTransaction.Comment,
                });

            }

            return dtos;
        }

        /// <summary>
        /// Calculate account provision quantity per account
        /// </summary>
        /// <param name="dateFrom">Period start date</param>
        /// <param name="dateTo">Period end date</param>
        /// <param name="salaryType">Salary type (from PayrollGroup)</param>
        /// <param name="paidTime">Paid time in hours per account (including paid absence)</param>
        /// <param name="totalPaidTime">Total paid time in hours for all accounts (including paid absence)</param>
        /// <param name="totalScheduledTime">Scheduled time in hours per account</param>
        /// <param name="employmentRates">All employment rates within specified period (start date, rate)</param>
        /// <returns>Quantity</returns>
        public decimal CalculateAccountProvisionQuantity(DateTime dateFrom, DateTime dateTo, TermGroup_PayrollExportSalaryType salaryType, decimal paidTime, decimal totalPaidTime, decimal totalScheduledTime, Dictionary<DateTime, decimal> employmentRates)
        {
            decimal quantity = 1;

            try
            {
                switch (salaryType)
                {
                    case TermGroup_PayrollExportSalaryType.Monthly:
                        decimal employmentRate = this.CalculateAverageEmploymentRate(dateFrom, dateTo, employmentRates);

                        if (totalScheduledTime == 0)
                            return 1;

                        if (paidTime == 0)
                            return 0;

                        if (employmentRate == 0)
                            return 0;

                        quantity = totalScheduledTime > 0 ? Decimal.Multiply(Decimal.Divide(paidTime, totalScheduledTime), Decimal.Divide(employmentRate, 100M)) : 0;
                        break;
                    case TermGroup_PayrollExportSalaryType.Hourly:
                        if (totalPaidTime < 166)
                            totalPaidTime = 166;

                        if (paidTime == 0)
                            return 0;

                        if (totalPaidTime == 0)
                            return 0;

                        quantity = Decimal.Divide(paidTime, totalPaidTime);
                        break;
                }
            }
            catch (Exception ex)
            {
                LogError(ex, this.log);
            }

            // Quantity can never be more than 1
            if (quantity > 1)
                quantity = 1;

            return quantity;
        }

        private decimal CalculateAverageEmploymentRate(DateTime dateFrom, DateTime dateTo, Dictionary<DateTime, decimal> employmentRates)
        {
            // Convert dictionary of employment rates per start date
            // to list of number of days for each employment rate.
            List<GenericType<int, decimal>> rates = new List<GenericType<int, decimal>>();

            DateTime currentDate = dateFrom;
            decimal? prevRate = null;
            foreach (KeyValuePair<DateTime, decimal> employmentRate in employmentRates.OrderBy(e => e.Key))
            {
                if (!prevRate.HasValue)
                {
                    prevRate = employmentRate.Value;
                    if (employmentRate.Key < currentDate)
                        continue;
                }
                if (employmentRate.Key > currentDate)
                {
                    int days = (int)(employmentRate.Key - currentDate).TotalDays + 1;
                    rates.Add(new GenericType<int, decimal>() { Field1 = days, Field2 = prevRate.Value });

                    prevRate = employmentRate.Value;
                    currentDate = employmentRate.Key;
                }
            }
            if (prevRate.HasValue)
                rates.Add(new GenericType<int, decimal>() { Field1 = (int)(dateTo - currentDate).TotalDays + 1, Field2 = prevRate.Value });

            // Calculate average
            decimal average = 0;
            int totalDays = (int)(dateTo - dateFrom).TotalDays + 1;
            foreach (GenericType<int, decimal> rate in rates)
            {
                average += Decimal.Multiply(Decimal.Divide(rate.Field2, totalDays), rate.Field1);
            }

            return average;
        }

        #endregion

        #region MassRegistration

        public List<MassRegistrationTemplateHead> GetMassRegistrationTemplateHeads(int actorCompanyId, bool loadRows, bool onlyActive = true)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.MassRegistrationTemplateHead.NoTracking();
            entities.MassRegistrationTemplateRow.NoTracking();
            return GetMassRegistrationTemplateHeads(entities, actorCompanyId, loadRows, onlyActive);
        }

        public List<MassRegistrationTemplateHead> GetMassRegistrationTemplateHeads(CompEntities entities, int actorCompanyId, bool loadRows, bool onlyActive = true)
        {
            var query = (from m in entities.MassRegistrationTemplateHead.Include("PayrollProduct").Include("AccountStd")
                         where m.ActorCompanyId == actorCompanyId
                         select m);

            if (loadRows)
            {
                query = query.Include("MassRegistrationTemplateRow.PayrollProduct")
                    .Include("MassRegistrationTemplateRow.AccountStd")
                    .Include("MassRegistrationTemplateRow.Employee.ContactPerson");
            }

            if (onlyActive)
                query = query.Where(a => a.State == (int)SoeEntityState.Active);
            else
                query = query.Where(a => a.State != (int)SoeEntityState.Deleted);

            return query.ToList();
        }

        public MassRegistrationTemplateHead GetMassRegistrationTemplateHead(int actorCompanyId, int massRegistrationTemplateHeadId, bool loadRelations, bool loadAccountStdAndInternal, bool loadAccountAndAccountDim, bool setDimIds, bool setHasCreatedTransactions = false)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.MassRegistrationTemplateHead.NoTracking();
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.MassRegistrationTemplateRow.NoTracking();
            return GetMassRegistrationTemplateHead(entities, actorCompanyId, massRegistrationTemplateHeadId, loadRelations, loadAccountStdAndInternal, loadAccountAndAccountDim, setDimIds, setHasCreatedTransactions);
        }

        public MassRegistrationTemplateHead GetMassRegistrationTemplateHead(CompEntities entities, int actorCompanyId, int massRegistrationTemplateHeadId, bool loadRelations, bool loadAccountStdAndInternal, bool loadAccountAndAccountDim, bool setDimIds, bool setHasCreatedTransactions = false)
        {
            var query = entities.MassRegistrationTemplateHead.Include("MassRegistrationTemplateRow");
            if (loadRelations)
            {
                query = query.Include("PayrollProduct")
                            .Include("MassRegistrationTemplateRow.PayrollProduct")
                            .Include("MassRegistrationTemplateRow.Employee.ContactPerson");
            }

            if (loadAccountStdAndInternal && loadAccountAndAccountDim)
            {
                query = query.Include("AccountStd.Account.AccountDim")
                            .Include("AccountInternal.Account.AccountDim")
                            .Include("MassRegistrationTemplateRow.AccountStd.Account.AccountDim")
                            .Include("MassRegistrationTemplateRow.AccountInternal.Account.AccountDim");
            }
            else
            {
                if (loadAccountStdAndInternal)
                {
                    query = query.Include("AccountStd")
                            .Include("AccountInternal")
                            .Include("MassRegistrationTemplateRow.AccountStd")
                            .Include("MassRegistrationTemplateRow.AccountInternal");
                }
                else if (loadAccountAndAccountDim || setDimIds)
                {
                    query = query.Include("AccountStd.Account.AccountDim")
                                .Include("AccountInternal.Account.AccountDim")
                                .Include("MassRegistrationTemplateRow.AccountStd")
                                .Include("MassRegistrationTemplateRow.AccountInternal.Account.AccountDim");
                }
            }

            MassRegistrationTemplateHead head = (from m in query
                                                 where m.ActorCompanyId == actorCompanyId &&
                                                 m.MassRegistrationTemplateHeadId == massRegistrationTemplateHeadId &&
                                                 m.State == (int)SoeEntityState.Active
                                                 select m).FirstOrDefault();

            if (setDimIds)
            {
                List<AccountDim> dims = AccountManager.GetAccountDimsByCompany();
                foreach (AccountInternal accInt in head.AccountInternal)
                {
                    int index = 0;
                    foreach (var dim in dims)
                    {
                        index++;
                        if (dim.AccountDimId == accInt.Account.AccountDim.AccountDimId)
                            break;
                    }
                    if (index > 0)
                    {
                        if (index == 1)
                            head.Dim1Id = accInt.AccountId;
                        else if (index == 2)
                            head.Dim2Id = accInt.AccountId;
                        else if (index == 3)
                            head.Dim3Id = accInt.AccountId;
                        else if (index == 4)
                            head.Dim4Id = accInt.AccountId;
                        else if (index == 5)
                            head.Dim5Id = accInt.AccountId;
                        else if (index == 6)
                            head.Dim6Id = accInt.AccountId;
                    }
                }
            }

            if (setHasCreatedTransactions)
            {
                foreach (MassRegistrationTemplateRow row in head.MassRegistrationTemplateRow.Where(x => x.State == (int)SoeEntityState.Active))
                {
                    using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
                    bool hasTransactions = (from t in entitiesReadOnly.TimePayrollTransaction
                                            where t.EmployeeId == row.EmployeeId &&
                                            t.MassRegistrationTemplateRowId == row.MassRegistrationTemplateRowId &&
                                            t.State == (int)SoeEntityState.Active
                                            select t).Any();

                    if (hasTransactions)
                    {
                        head.HasCreatedTransactions = true;
                        break;
                    }
                }
            }

            return head;
        }

        public bool MassRegistrationHasCreatedTransactions(int massRegistrationTemplateHeadId, int actorCompanyId)
        {
            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            MassRegistrationTemplateHead templateHead = GetMassRegistrationTemplateHead(actorCompanyId, massRegistrationTemplateHeadId, false, false, false, false);
            if (templateHead != null)
            {
                foreach (MassRegistrationTemplateRow row in templateHead.MassRegistrationTemplateRow.Where(x => x.State == (int)SoeEntityState.Active))
                {
                    bool hasTransactions = (from t in entitiesReadOnly.TimePayrollTransaction
                                            where t.EmployeeId == row.EmployeeId &&
                                            t.MassRegistrationTemplateRowId == row.MassRegistrationTemplateRowId &&
                                            t.State == (int)SoeEntityState.Active
                                            select t).Any();

                    if (hasTransactions)
                        return true;
                }
            }

            return false;
        }

        public ActionResult DeleteMassRegistrationTemplateHead(int actorCompanyId, int massRegistrationTemplateHeadId, bool deleteTransactions)
        {
            ActionResult result = new ActionResult();

            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    entities.Connection.Open();

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_DEFAULT))
                    {

                        AttestState initialAttestState = (from a in entities.AttestState
                                                          where a.ActorCompanyId == actorCompanyId &&
                                                          a.Entity == (int)TermGroup_AttestEntity.PayrollTime &&
                                                          a.Initial
                                                          select a).FirstOrDefault();

                        if (initialAttestState == null)
                            return new ActionResult((int)ActionResultDelete.EntityNotFound, "AttestState");

                        MassRegistrationTemplateHead templateHead = GetMassRegistrationTemplateHead(entities, actorCompanyId, massRegistrationTemplateHeadId, false, false, false, false);
                        if (templateHead == null)
                            return new ActionResult((int)ActionResultDelete.EntityNotFound, "MassRegistrationTemplateHead");

                        ChangeEntityState(templateHead, SoeEntityState.Deleted);

                        if (deleteTransactions)
                        {
                            foreach (MassRegistrationTemplateRow row in templateHead.MassRegistrationTemplateRow.Where(x => x.State == (int)SoeEntityState.Active))
                            {
                                ChangeEntityState(row, SoeEntityState.Deleted);

                                List<TimePayrollTransaction> payrollTransactions = (from t in entities.TimePayrollTransaction
                                                                                    where t.EmployeeId == row.EmployeeId &&
                                                                                    t.MassRegistrationTemplateRowId == row.MassRegistrationTemplateRowId &&
                                                                                    t.State == (int)SoeEntityState.Active
                                                                                    select t).ToList();

                                foreach (TimePayrollTransaction payrollTransaction in payrollTransactions)
                                {
                                    if (payrollTransaction.AttestStateId != initialAttestState.AttestStateId)
                                        continue;

                                    ChangeEntityState(payrollTransaction, SoeEntityState.Deleted);
                                }

                            }
                        }

                        result = SaveChanges(entities);

                        //Commit transaction
                        if (result.Success)
                            transaction.Complete();
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result.Exception = ex;
                    log.Error(ex.Message, ex);
                }
                finally
                {
                    if (result.Success)
                    {
                        //Set success properties
                    }
                    else
                        base.LogTransactionFailed(this.ToString(), this.log);

                    entities.Connection.Close();
                }

                return result;
            }
        }

        public ActionResult SaveMassRegistrationTemplate(MassRegistrationTemplateHeadDTO templateDTO, int actorCompanyId)
        {
            ActionResult result = null;
            int massRegistrationTemplateHeadId = templateDTO.MassRegistrationTemplateHeadId;

            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    entities.Connection.Open();

                    List<AccountInternal> accountInternals = AccountManager.GetAccountInternals(entities, actorCompanyId, true);

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_DEFAULT))
                    {

                        MassRegistrationTemplateHead templateHead = GetMassRegistrationTemplateHead(entities, actorCompanyId, massRegistrationTemplateHeadId, false, true, false, false);
                        if (templateHead == null)
                        {
                            #region Add

                            templateHead = new MassRegistrationTemplateHead()
                            {
                                ActorCompanyId = actorCompanyId,
                                State = (int)SoeEntityState.Active,
                            };

                            SetCreatedProperties(templateHead);
                            entities.MassRegistrationTemplateHead.AddObject(templateHead);

                            #endregion
                        }
                        else
                        {
                            #region Update

                            SetModifiedProperties(templateHead);

                            #endregion
                        }

                        #region Common

                        templateHead.Name = templateDTO.Name;
                        templateHead.IsRecurring = templateDTO.IsRecurring;
                        templateHead.RecurringDateTo = templateDTO.RecurringDateTo;
                        templateHead.InputType = (int)templateDTO.InputType;
                        templateHead.Comment = StringUtility.NullToEmpty(templateDTO.Comment);
                        templateHead.PayrollProductId = templateDTO.PayrollProductId != 0 ? templateDTO.PayrollProductId : null;
                        templateHead.DateFrom = templateDTO.DateFrom;
                        templateHead.DateTo = templateDTO.DateTo;
                        templateHead.Quantity = templateDTO.Quantity;
                        templateHead.IsSpecifiedUnitPrice = templateDTO.IsSpecifiedUnitPrice;
                        templateHead.UnitPrice = templateDTO.UnitPrice;
                        templateHead.StopOnProduct = templateDTO.StopOnProduct;
                        templateHead.StopOnDateFrom = templateDTO.StopOnDateFrom;
                        templateHead.StopOnDateTo = templateDTO.StopOnDateTo;
                        templateHead.StopOnQuantity = templateDTO.StopOnQuantity;
                        templateHead.StopOnIsSpecifiedUnitPrice = templateDTO.StopOnIsSpecifiedUnitPrice;
                        templateHead.StopOnUnitPrice = templateDTO.StopOnUnitPrice;
                        templateHead.PaymentDate = templateDTO.PaymentDate;
                        templateHead.StopOnPaymentDate = templateDTO.StopOnPaymentDate;

                        if (templateDTO.AccountSettings != null)
                        {
                            // Silverlight way
                            if (templateDTO.AccountSettings.Any(x => x.DimNr == Constants.ACCOUNTDIM_STANDARD))
                            {
                                AccountingSettingDTO accountingSettingDTO = templateDTO.AccountSettings.FirstOrDefault(x => x.DimNr == Constants.ACCOUNTDIM_STANDARD);
                                if (accountingSettingDTO != null && accountingSettingDTO.Account1Id != 0)
                                    templateHead.AccountId = accountingSettingDTO.Account1Id;
                            }

                            if (templateHead.AccountInternal != null)
                                templateHead.AccountInternal.Clear();

                            // Add internal accounts
                            foreach (AccountingSettingDTO item in templateDTO.AccountSettings)
                            {
                                AccountInternal accountInt = accountInternals.FirstOrDefault(x => x.AccountId == item.Account1Id);
                                if (accountInt != null)
                                    templateHead.AccountInternal.Add(accountInt);
                            }
                        }
                        else
                        {
                            if (templateDTO.Dim1Id.HasValue && templateDTO.Dim1Id.Value != 0)
                                templateHead.AccountId = templateDTO.Dim1Id.Value;
                            else
                                templateHead.AccountId = null;

                            if (templateHead.AccountInternal != null)
                                templateHead.AccountInternal.Clear();

                            // Add internal accounts
                            AddAccountInternalToMassRegistrationTemplateHead(templateHead, accountInternals, templateDTO.Dim2Id);
                            AddAccountInternalToMassRegistrationTemplateHead(templateHead, accountInternals, templateDTO.Dim3Id);
                            AddAccountInternalToMassRegistrationTemplateHead(templateHead, accountInternals, templateDTO.Dim4Id);
                            AddAccountInternalToMassRegistrationTemplateHead(templateHead, accountInternals, templateDTO.Dim5Id);
                            AddAccountInternalToMassRegistrationTemplateHead(templateHead, accountInternals, templateDTO.Dim6Id);
                        }

                        #endregion

                        #region Rows

                        massRegistrationTemplateHeadId = templateHead.MassRegistrationTemplateHeadId;

                        List<MassRegistrationTemplateRow> existingRows = templateHead.MassRegistrationTemplateRow.Where(x => x.State == (int)SoeEntityState.Active).ToList();

                        #region Delete rows that exists in db but not in input.

                        foreach (var existingRow in existingRows)
                        {
                            if (!templateDTO.Rows.Any(x => x.MassRegistrationTemplateRowId == existingRow.MassRegistrationTemplateRowId))
                            {
                                ChangeEntityState(existingRow, SoeEntityState.Deleted);
                            }
                        }

                        #endregion

                        #region Add/Update rows

                        if (templateDTO.Rows != null)
                        {
                            foreach (var templateRowDTO in templateDTO.Rows)
                            {
                                MassRegistrationTemplateRow templateRow = existingRows.FirstOrDefault(x => x.MassRegistrationTemplateRowId == templateRowDTO.MassRegistrationTemplateRowId);
                                if (templateRow == null)
                                {
                                    templateRow = new MassRegistrationTemplateRow()
                                    {
                                        MassRegistrationTemplateHeadId = massRegistrationTemplateHeadId,
                                        State = (int)SoeEntityState.Active,
                                    };

                                    SetCreatedProperties(templateRow);
                                    entities.MassRegistrationTemplateRow.AddObject(templateRow);

                                }
                                else
                                {
                                    SetModifiedProperties(templateRow);
                                }

                                #region Common

                                templateRow.EmployeeId = templateRowDTO.EmployeeId;
                                templateRow.PayrollProductId = templateRowDTO.ProductId;
                                templateRow.PaymentDate = templateRowDTO.PaymentDate;
                                templateRow.Quantity = templateRowDTO.Quantity;
                                templateRow.UnitPrice = templateRowDTO.UnitPrice;
                                templateRow.DateFrom = templateRowDTO.DateFrom;
                                templateRow.DateTo = templateRowDTO.DateTo;
                                templateRow.IsSpecifiedUnitPrice = templateRowDTO.IsSpecifiedUnitPrice;

                                //Accounting
                                templateRow.AccountId = templateRowDTO.Dim1Id > 0 ? templateRowDTO.Dim1Id : (int?)null;

                                templateRow.AccountInternal.Clear();

                                if (templateRowDTO.Dim2Id != 0)
                                {
                                    var accInt = accountInternals.FirstOrDefault(x => x.AccountId == templateRowDTO.Dim2Id);
                                    if (accInt != null)
                                        templateRow.AccountInternal.Add(accInt);
                                }

                                if (templateRowDTO.Dim3Id != 0)
                                {
                                    var accInt = accountInternals.FirstOrDefault(x => x.AccountId == templateRowDTO.Dim3Id);
                                    if (accInt != null)
                                        templateRow.AccountInternal.Add(accInt);
                                }

                                if (templateRowDTO.Dim4Id != 0)
                                {
                                    var accInt = accountInternals.FirstOrDefault(x => x.AccountId == templateRowDTO.Dim4Id);
                                    if (accInt != null)
                                        templateRow.AccountInternal.Add(accInt);
                                }

                                if (templateRowDTO.Dim5Id != 0)
                                {
                                    var accInt = accountInternals.FirstOrDefault(x => x.AccountId == templateRowDTO.Dim5Id);
                                    if (accInt != null)
                                        templateRow.AccountInternal.Add(accInt);
                                }

                                if (templateRowDTO.Dim6Id != 0)
                                {
                                    var accInt = accountInternals.FirstOrDefault(x => x.AccountId == templateRowDTO.Dim6Id);
                                    if (accInt != null)
                                        templateRow.AccountInternal.Add(accInt);
                                }

                                #endregion
                            }
                        }

                        #endregion

                        #endregion

                        result = SaveChanges(entities, transaction);
                        if (!result.Success)
                            return result;

                        massRegistrationTemplateHeadId = templateHead.MassRegistrationTemplateHeadId;

                        //Commit transaction
                        if (result.Success)
                            transaction.Complete();
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result = new ActionResult(ex);
                    log.Error(ex.Message, ex);
                }
                finally
                {
                    if (result != null && result.Success)
                    {
                        //Set success properties
                        result.IntegerValue = massRegistrationTemplateHeadId;
                    }
                    else
                    {
                        if (result != null)
                            result = new ActionResult(false);

                        base.LogTransactionFailed(this.ToString(), this.log);
                    }

                    entities.Connection.Close();
                }

                return result;
            }

        }

        private void AddAccountInternalToMassRegistrationTemplateHead(MassRegistrationTemplateHead templateHead, List<AccountInternal> accountInternals, int? accountId)
        {
            if (accountId.HasValue && accountId.Value != 0)
            {
                AccountInternal accountInt = accountInternals.FirstOrDefault(x => x.AccountId == accountId.Value);
                if (accountInt != null)
                    templateHead.AccountInternal.Add(accountInt);
            }
        }

        public string ExportMassRegistration(MassRegistrationTemplateHeadDTO head)
        {
            byte[] bytes = ImportExportManager.ConvertMassRegistrationDTOsToExcel(head.Rows);
            if (bytes == null || bytes.Length == 0)
                return String.Empty;

            string filename = GetText(11201, 1004, "Massregistrering") + ".xlsx";
            string url = GeneralManager.GetUrlForDownload(bytes, filename);

            return url;
        }

        public List<MassRegistrationTemplateRowDTO> ImportMassRegistration(Stream stream, TermGroup_MassRegistrationImportType type, DateTime? paymentDate, int actorCompanyId)
        {
            List<MassRegistrationTemplateRowDTO> rows = new List<MassRegistrationTemplateRowDTO>();

            MemoryStream ms = new MemoryStream();
            stream.CopyTo(ms);

            switch (type)
            {
                case TermGroup_MassRegistrationImportType.Excel:
                    rows = ImportExportManager.ConvertMassRegistrationExcelToDTOs(ms.ToArray(), actorCompanyId);
                    break;
                case TermGroup_MassRegistrationImportType.SoftOneClassic:
                    rows = ImportExportManager.ConvertMassRegistrationSoftOneClassicFileToDTOs(ms, paymentDate, actorCompanyId);
                    break;
                case TermGroup_MassRegistrationImportType.PaXml:
                    rows = ImportExportManager.ConvertMassRegistrationPaXmlFileToDTOs(ms.ToArray(), paymentDate, actorCompanyId);
                    break;
            }

            return rows;
        }

        #endregion

        #region SupplementCharge (SE)

        #region Common for 2014-

        public decimal CalculateSupplementChargeSE(CompEntities entities, int actorCompanyId, DateTime date, decimal amount, Employee employee, bool applyEmploymentHasEnded = false, SysPayrollPriceViewDTO sysPayrollPrice = null, List<PayrollGroupAccountStd> payrollGroupAccountStds = null)
        {
            #region Prereq

            // Get Payroll group
            int? payrollGroupId = employee.GetPayrollGroupId(date, uselastEmploymentDateAsFallback: applyEmploymentHasEnded);
            if (!payrollGroupId.HasValue)
                return 0;

            // Get birth date from employee
            DateTime? birthDate = EmployeeManager.GetEmployeeBirthDate(employee);
            if (!birthDate.HasValue)
                return 0;

            #endregion

            return CalculateSupplementChargeSE(entities, actorCompanyId, date, amount, payrollGroupId.Value, birthDate.Value, sysPayrollPrice, payrollGroupAccountStds);
        }

        public decimal CalculateSupplementChargeSE(int actorCompanyId, DateTime date, decimal amount, int? payrollGroupId, DateTime? birthDate, SysPayrollPriceViewDTO sysPayrollPrice = null, List<PayrollGroupAccountStd> payrollGroupAccountStds = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return CalculateSupplementChargeSE(entities, actorCompanyId, date, amount, payrollGroupId, birthDate, sysPayrollPrice, payrollGroupAccountStds);
        }

        public decimal CalculateSupplementChargeSE(CompEntities entities, int actorCompanyId, DateTime date, decimal amount, int? payrollGroupId, DateTime? birthDate, SysPayrollPriceViewDTO sysPayrollPrice = null, List<PayrollGroupAccountStd> payrollGroupAccountStds = null, bool setDefaultAge = false)
        {
            if (amount == 0)
                return 0;

            if (!payrollGroupId.HasValue)
                return 0;

            if (!birthDate.HasValue && setDefaultAge)
                birthDate = DateTime.Today.AddYears(-40);

            if (!birthDate.HasValue)
                return 0;

            int birthDayYear = birthDate.HasValue ? birthDate.Value.Year : 1900; // Since we will only use Year.
            string key = $"CalculateSupplementChargeSE#{date}#{setDefaultAge}#{actorCompanyId}#{birthDayYear}#{payrollGroupId}";
            var rate = BusinessMemoryCache<decimal?>.Get(key);
            if (rate == null)
                rate = CalculateSupplementChargePercentSE(entities, actorCompanyId, date, payrollGroupId, birthDate, sysPayrollPrice, payrollGroupAccountStds);

            if (rate != null && rate != 0)
                BusinessMemoryCache<decimal>.Set(key, rate.Value);

            rate = rate ?? 0;

            return Decimal.Multiply(amount, rate.Value);
        }

        public decimal CalculateSupplementChargePercentSE(CompEntities entities, int actorCompanyId, DateTime date, int? payrollGroupId, DateTime? birthDate, SysPayrollPriceViewDTO sysPayrollPrice = null, List<PayrollGroupAccountStd> payrollGroupAccountStds = null, bool setDefaultAge = false)
        {

            if (!payrollGroupId.HasValue)
                return 0;

            if (!birthDate.HasValue && setDefaultAge)
                birthDate = DateTime.Today.AddYears(-40);

            if (!birthDate.HasValue)
                return 0;

            #region Get percent from PayrollGroupAccountStd           

            if (sysPayrollPrice == null)
                sysPayrollPrice = GetSysPayrollPriceInterval(entities, actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_EmploymentTax, birthDate.Value.Year, date, (int)TermGroup_Languages.Swedish);
            if (sysPayrollPrice == null)
                return 0;

            if (payrollGroupAccountStds == null)
                payrollGroupAccountStds = GetPayrollGroupAccountStds(entities, payrollGroupId.Value, PayrollGroupAccountType.OwnSupplementCharge, birthDate.Value.Year);
            else
                payrollGroupAccountStds = GetPayrollGroupAccountStds(entities, payrollGroupId.Value, PayrollGroupAccountType.OwnSupplementCharge, birthDate.Value.Year, payrollGroupAccountStds);

            if (payrollGroupAccountStds.IsNullOrEmpty())
                return 0;

            PayrollGroupAccountStd payrollGroupAccountStd = payrollGroupAccountStds.FirstOrDefault(x => x.FromInterval == sysPayrollPrice.FromInterval && x.ToInterval == sysPayrollPrice.ToInterval);
            if (payrollGroupAccountStd == null)
                return 0;

            if (!payrollGroupAccountStd.Percent.HasValue)
                return 0;

            #endregion

            return Decimal.Divide(payrollGroupAccountStd.Percent.Value, 100M);

        }

        #endregion

        #endregion

        #region PayrollProductDistributionRule
        public PayrollProductDistributionRuleHead GetPayrollProductDistributionRuleHead(int actorCompanyId, int payrollProductDistributionRuleHeadId, bool loadRules = false)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollProductDistributionRuleHead.NoTracking();
            return GetPayrollProductDistributionRuleHead(entities, actorCompanyId, payrollProductDistributionRuleHeadId, loadRules);
        }
        public PayrollProductDistributionRuleHead GetPayrollProductDistributionRuleHead(CompEntities entities, int actorCompanyId, int payrollProductDistributionRuleHeadId, bool loadRules = false)
        {
            IQueryable<PayrollProductDistributionRuleHead> query = entities.PayrollProductDistributionRuleHead;

            if (loadRules)
                query = query.Include("PayrollProductDistributionRule");

            PayrollProductDistributionRuleHead payrollProductDistributionRuleHead = (from ppdr in query
                                                                                     where ppdr.ActorCompanyId == actorCompanyId &&
                                                                                     ppdr.PayrollProductDistributionRuleHeadId == payrollProductDistributionRuleHeadId &&
                                                                                     ppdr.State == (int)SoeEntityState.Active
                                                                                     select ppdr).FirstOrDefault();

            return payrollProductDistributionRuleHead;
        }

        public List<PayrollProductDistributionRuleHead> GetPayrollProductDistributionRuleHeads(int actorCompanyId, int? payrollProductDistributionRuleHeadId = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollProductDistributionRuleHead.NoTracking();
            return GetPayrollProductDistributionRuleHeads(entities, actorCompanyId, payrollProductDistributionRuleHeadId);
        }

        public List<PayrollProductDistributionRuleHead> GetPayrollProductDistributionRuleHeads(CompEntities entities, int actorCompanyId, int? payrollProductDistributionRuleHeadId = null)
        {
            IQueryable<PayrollProductDistributionRuleHead> query = entities.PayrollProductDistributionRuleHead;

            List<PayrollProductDistributionRuleHead> payrollProductDistributionRuleHeads = (from ppdr in query
                                                                                            where ppdr.ActorCompanyId == actorCompanyId &&
                                                                                            ppdr.State == (int)SoeEntityState.Active
                                                                                            select ppdr).ToList();

            if (payrollProductDistributionRuleHeadId.HasValue)
                payrollProductDistributionRuleHeads = payrollProductDistributionRuleHeads.Where(s => s.PayrollProductDistributionRuleHeadId == payrollProductDistributionRuleHeadId.Value).ToList();

            return payrollProductDistributionRuleHeads;
        }
        public ActionResult SavePayrollProductDistributionRuleHead(PayrollProductDistributionRuleHeadDTO payrollProductDistributionRuleHeadInput, int actorCompanyId)
        {
            ActionResult result = new ActionResult(true);

            if (payrollProductDistributionRuleHeadInput == null)
                return new ActionResult((int)ActionResultSave.EntityIsNull, "PayrollProductDistributionRuleHead");

            int payrollProductDistributionRuleHeadId = 0;

            foreach (var groupRules in payrollProductDistributionRuleHeadInput.Rules.GroupBy(g => g.PayrollProductId))
            {
                var rules = groupRules.ToList();
                if (rules.Any())
                {
                    for (var i = 0; i < rules.Count; i++)
                    {
                        var rule = rules[i];
                        var last = rules.Count - 1 == i;

                        if (rule.Start > rule.Stop)
                            return new ActionResult(result.ErrorNumber, GetText(12536, "Regler har felaktigt format"));

                        if (rules.Where(w => w.PayrollProductDistributionRuleId != rule.PayrollProductDistributionRuleId).Any(x => (x.Start >= rule.Start && x.Start < rule.Stop) || (x.Stop > rule.Start && x.Stop <= rule.Stop)))
                            return new ActionResult(result.ErrorNumber, GetText(12535, "Regler får inte överlappa varandra"));

                        if (!last)
                        {
                            var nextRule = rules[i + 1];
                            if (rule.Stop != nextRule.Start)
                                return new ActionResult(result.ErrorNumber, GetText(12537, "Regler får inte ha hål"));
                        }

                    }
                }
            }

            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    entities.Connection.Open();

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_DEFAULT))
                    {
                        #region Validate input

                        if (String.IsNullOrEmpty(payrollProductDistributionRuleHeadInput.Name))
                            return new ActionResult((int)ActionResultSave.IncorrectInput);

                        #endregion

                        PayrollProductDistributionRuleHead payrollProductDistributionRuleHead = null;
                        if (payrollProductDistributionRuleHeadInput.PayrollProductDistributionRuleHeadId == 0)
                        {
                            #region Add

                            #region PayrollProductDistributionRuleHead

                            payrollProductDistributionRuleHead = new PayrollProductDistributionRuleHead()
                            {
                                Name = payrollProductDistributionRuleHeadInput.Name,
                                Description = payrollProductDistributionRuleHeadInput.Description,

                                //Set FK
                                ActorCompanyId = actorCompanyId,
                            };
                            SetCreatedProperties(payrollProductDistributionRuleHead);
                            entities.PayrollProductDistributionRuleHead.AddObject(payrollProductDistributionRuleHead);

                            #endregion

                            #region PayrollProductDistributionRule

                            foreach (var ruleInput in payrollProductDistributionRuleHeadInput.Rules)
                            {
                                var payrollProductDistributionRule = new PayrollProductDistributionRule()
                                {
                                    PayrollProductId = ruleInput.PayrollProductId,
                                    Start = ruleInput.Start,
                                    Stop = ruleInput.Stop,

                                    ActorCompanyId = actorCompanyId,
                                };
                                SetCreatedProperties(payrollProductDistributionRule);

                                payrollProductDistributionRuleHead.PayrollProductDistributionRule.Add(payrollProductDistributionRule);
                            }

                            #endregion

                            #endregion
                        }
                        else
                        {
                            #region Update

                            payrollProductDistributionRuleHead = GetPayrollProductDistributionRuleHead(entities, actorCompanyId, payrollProductDistributionRuleHeadInput.PayrollProductDistributionRuleHeadId, true);
                            if (payrollProductDistributionRuleHead == null)
                                return new ActionResult((int)ActionResultSave.EntityNotFound, "PayrollProductDistributionRuleHead");

                            #region PayrollProductDistributionRuleHead

                            payrollProductDistributionRuleHead.Name = payrollProductDistributionRuleHeadInput.Name;
                            payrollProductDistributionRuleHead.Description = payrollProductDistributionRuleHeadInput.Description;

                            SetModifiedProperties(payrollProductDistributionRuleHead);

                            #endregion

                            List<PayrollProductDistributionRule> existingRules = payrollProductDistributionRuleHead.PayrollProductDistributionRule.Where(x => x.State == (int)SoeEntityState.Active).ToList();

                            #region Add Rule

                            foreach (var ruleInput in payrollProductDistributionRuleHeadInput.Rules)
                            {
                                PayrollProductDistributionRule rule = existingRules.FirstOrDefault(x => x.PayrollProductDistributionRuleId == ruleInput.PayrollProductDistributionRuleId);
                                if (rule == null)
                                {
                                    rule = new PayrollProductDistributionRule()
                                    {
                                        PayrollProductId = ruleInput.PayrollProductId,
                                        Start = ruleInput.Start,
                                        Stop = ruleInput.Stop,
                                        ActorCompanyId = actorCompanyId,
                                    };
                                    SetCreatedProperties(rule);

                                    payrollProductDistributionRuleHead.PayrollProductDistributionRule.Add(rule);
                                }

                            }

                            #endregion

                            #endregion

                            #region Update/Delete rule


                            foreach (var existingRule in existingRules)
                            {
                                var ruleInput = payrollProductDistributionRuleHeadInput.Rules.FirstOrDefault(w => w.PayrollProductDistributionRuleId == existingRule.PayrollProductDistributionRuleId);
                                if (ruleInput == null)
                                {
                                    ChangeEntityState(existingRule, SoeEntityState.Deleted);
                                }
                                else
                                {
                                    if (existingRule.PayrollProductId != ruleInput.PayrollProductId || existingRule.Start != ruleInput.Start || existingRule.Stop != ruleInput.Stop)
                                    {
                                        existingRule.PayrollProductId = ruleInput.PayrollProductId;
                                        existingRule.Start = ruleInput.Start;
                                        existingRule.Stop = ruleInput.Stop;
                                        SetModifiedProperties(existingRule);
                                    }
                                }

                            }


                            #endregion
                        }

                        if (result.Success)
                        {
                            result = SaveChanges(entities, transaction);
                            payrollProductDistributionRuleHeadId = payrollProductDistributionRuleHead.PayrollProductDistributionRuleHeadId;
                        }

                        //Commit transaction
                        if (result.Success)
                            transaction.Complete();
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result.Exception = ex;
                }
                finally
                {
                    if (result.Success)
                    {
                        result.IntegerValue = payrollProductDistributionRuleHeadId;
                    }
                    else
                        base.LogTransactionFailed(this.ToString(), this.log);


                    entities.Connection.Close();
                }

                return result;
            }
        }

        public ActionResult DeletePayrollProductDistributionRuleHead(int payrollProductDistributionRuleHeadId, int actorCompanyId)
        {
            if (payrollProductDistributionRuleHeadId == 0)
                return new ActionResult((int)ActionResultDelete.EntityIsNull, "PayrollProductDistributionRuleHead");

            var timePeriods = TimePeriodManager.GetTimePeriodHeadsConnectedToDistributionRule(actorCompanyId, TermGroup_TimePeriodType.RuleWorkTime, payrollProductDistributionRuleHeadId);
            if (timePeriods.Any())
                return new ActionResult((int)ActionResultDelete.NothingDeleted, GetText(8551, "Övertidsfördelning är kopplad mot en planeringsperiod och kan ej tas bort"));

            using (CompEntities entities = new CompEntities())
            {
                var originalPayrollProductDistributionRuleHead = GetPayrollProductDistributionRuleHead(entities, actorCompanyId, payrollProductDistributionRuleHeadId, true);

                if (originalPayrollProductDistributionRuleHead == null)
                    return new ActionResult((int)ActionResultDelete.EntityNotFound, "PayrollProductDistributionRuleHead");

                foreach (PayrollProductDistributionRule rule in originalPayrollProductDistributionRuleHead.PayrollProductDistributionRule.Where(x => x.State == (int)SoeEntityState.Active).ToList())
                {
                    ChangeEntityState(rule, SoeEntityState.Deleted);
                }

                ActionResult result = ChangeEntityState(originalPayrollProductDistributionRuleHead, SoeEntityState.Deleted);
                if (result.Success)
                    result = SaveChanges(entities);

                return result;
            }
        }

        #endregion

        #region PayrollGroup

        public List<PayrollGroup> GetPayrollGroups(int actorCompanyId, bool loadPriceTypes = false, bool loadTimePeriods = false, bool onlyActive = true, bool loadSettings = false, bool loadAccountStd = false, bool loadExternalCode = false, bool loadPayrollGroupVacationGroup = false, bool includePayrollGroupPayrollProduct = false, bool includePriceFormulas = false)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroup.NoTracking();
            return GetPayrollGroups(entities, actorCompanyId, loadPriceTypes, loadTimePeriods, onlyActive, loadSettings, loadAccountStd, loadExternalCode, loadPayrollGroupVacationGroup, includePayrollGroupPayrollProduct, includePriceFormulas);
        }

        public List<PayrollGroup> GetPayrollGroups(CompEntities entities, int actorCompanyId, bool loadPriceTypes = false, bool loadTimePeriods = false, bool onlyActive = true, bool loadSettings = false, bool loadAccountStd = false, bool loadExternalCode = false, bool loadPayrollGroupVacationGroup = false, bool includePayrollGroupPayrollProduct = false, bool includePriceFormulas = false)
        {
            IQueryable<PayrollGroup> query = entities.PayrollGroup;
            if (loadPriceTypes)
            {
                query = query.Include("PayrollGroupPriceType.PayrollGroupPriceTypePeriod");
                query = query.Include("PayrollGroupPriceType.PayrollPriceType.PayrollPriceTypePeriod");
            }
            if (loadTimePeriods)
                query = query.Include("TimePeriodHead.TimePeriod");
            if (loadSettings)
                query = query.Include("PayrollGroupSetting");
            if (loadAccountStd)
                query = query.Include("PayrollGroupAccountStd");

            if (loadPayrollGroupVacationGroup)
                query = query.Include("PayrollGroupVacationGroup");

            if (includePayrollGroupPayrollProduct)
                query = query.Include("PayrollGroupPayrollProduct.PayrollProduct");

            if (includePriceFormulas)
                query = query.Include("PayrollGroupPriceFormula.PayrollPriceFormula");

            List<PayrollGroup> payrollGroups = (from pg in query
                                                where pg.ActorCompanyId == actorCompanyId &&
                                                (onlyActive ? pg.State == (int)SoeEntityState.Active : pg.State != (int)SoeEntityState.Deleted)
                                                orderby pg.Name
                                                select pg).ToList();

            if (payrollGroups.IsNullOrEmpty())
                return new List<PayrollGroup>();

            if (loadExternalCode)
                LoadPayrollGroupExternalCodes(entities, payrollGroups, actorCompanyId);

            return payrollGroups;
        }

        public IEnumerable<PayrollGroupSmallDTO> GetPayrollGroupsSmall(int actorCompanyId, bool addEmptyRow, bool onlyActive)
        {
            var payrollGroups = new List<PayrollGroupSmallDTO>();
            if (addEmptyRow)
            {
                payrollGroups.Add(new PayrollGroupSmallDTO()
                {
                    PayrollGroupId = 0,
                    Name = " "
                });
            }

            payrollGroups.AddRange(GetPayrollGroups(actorCompanyId, loadPriceTypes: true, onlyActive: onlyActive).OrderBy(pg => pg.Name).ToSmallDTOs(true));

            if (this.UsePayrollLevels(actorCompanyId))
            {
                foreach (var payrollGroup in payrollGroups)
                {
                    payrollGroup.PriceTypeLevels = new List<PriceTypeLevelDTO>();
                    var priceTypeLevels = this.GetPriceTypeLevelDTOs(payrollGroup.PayrollGroupId, payrollGroup.PriceTypes);
                    foreach (var priceTypeLevel in priceTypeLevels)
                    {
                        foreach (var payrollGroupPriceType in payrollGroup.PriceTypes)
                        {
                            payrollGroupPriceType.PriceTypeLevel = priceTypeLevels.FirstOrDefault(x => x.PayrollPriceTypeId == payrollGroupPriceType.PayrollPriceTypeId);
                        }
                    }
                }
            }

            return payrollGroups;
        }

        public List<PriceTypeLevelDTO> GetPriceTypeLevelDTOs(int payrollGroupId, List<PayrollGroupPriceTypeDTO> payrollGroupPriceTypes)
        {
            List<PriceTypeLevelDTO> dtos = new List<PriceTypeLevelDTO>();
            if (payrollGroupPriceTypes == null)
                return dtos;

            foreach (var group in payrollGroupPriceTypes.GroupBy(x => x.PayrollPriceTypeId))
            {
                PriceTypeLevelDTO dto = new PriceTypeLevelDTO()
                {
                    PayrollPriceTypeId = group.Key,
                    PayrollGroupId = payrollGroupId,
                };

                dto.HasLevels = group.Any(x => x.PayrollLevelId.HasValue);
                dto.LevelIsMandatory = group.All(x => x.PayrollLevelId.HasValue);
                dto.SelectableLevelIds = group.Where(x => x.PayrollLevelId.HasValue).Select(x => x.PayrollLevelId.Value).Distinct().ToList();
                if (!dto.LevelIsMandatory)
                    dto.SelectableLevelIds.Add(0); //No level

                dtos.Add(dto);
            }

            return dtos;
        }

        public Dictionary<int, string> GetPayrollGroupsDict(int actorCompanyId, bool addEmptyRow)
        {
            Dictionary<int, string> dict = GetPayrollGroups(actorCompanyId).ToDictionary(k => k.PayrollGroupId, v => v.Name);
            if (addEmptyRow)
                dict.Add(0, " ");
            return dict.Sort();
        }

        public PayrollGroup GetPayrollGroup(int payrollGroupId, bool onlyActive = true, bool includePriceTypes = false, bool includePriceFormulas = false, bool includeSettings = false, bool includePayrollGroupReports = false, bool includeTimePeriod = false, bool includeAccounts = false, bool includePayrollGroupVacationGroup = false, bool includePayrollGroupPayrollProduct = false, bool loadExternalCode = false)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.EmployeeGroup.NoTracking();
            return GetPayrollGroup(entities, payrollGroupId, onlyActive, includePriceTypes, includePriceFormulas, includeSettings, includePayrollGroupReports, includeTimePeriod, includeAccounts, includePayrollGroupVacationGroup, includePayrollGroupPayrollProduct, loadExternalCode);
        }

        public PayrollGroup GetPayrollGroup(CompEntities entities, int payrollGroupId, bool onlyActive = true, bool includePriceTypes = false, bool includePriceFormulas = false, bool includeSettings = false, bool includePayrollGroupReports = false, bool includeTimePeriod = false, bool includeAccounts = false, bool includePayrollGroupVacationGroup = false, bool includePayrollGroupPayrollProduct = false, bool loadExternalCode = false)
        {
            int actorCompanyId = base.ActorCompanyId;
            IQueryable<PayrollGroup> query = entities.PayrollGroup;

            if (includePriceTypes)
            {
                query = query.Include("PayrollGroupPriceType.PayrollPriceType");
                query = query.Include("PayrollGroupPriceType.PayrollGroupPriceTypePeriod");
                query = query.Include("PayrollGroupPriceType.PayrollLevel");
            }
            if (includePriceFormulas)
                query = query.Include("PayrollGroupPriceFormula.PayrollPriceFormula");
            if (includeSettings)
                query = query.Include("PayrollGroupSetting");
            if (includePayrollGroupReports)
                query = query.Include("PayrollGroupReport.Report");
            if (includeTimePeriod)
                query = query.Include("TimePeriodHead.TimePeriod");
            if (includeAccounts)
                query = query.Include("PayrollGroupAccountStd.AccountStd.Account");
            if (includePayrollGroupVacationGroup)
                query = query.Include("PayrollGroupVacationGroup.VacationGroup");
            if (includePayrollGroupPayrollProduct)
                query = query.Include("PayrollGroupPayrollProduct.PayrollProduct");

            var payrollGroup = (from pg in query
                                where pg.PayrollGroupId == payrollGroupId &&
                                pg.ActorCompanyId == actorCompanyId &&
                                (onlyActive ? pg.State == (int)SoeEntityState.Active : pg.State != (int)SoeEntityState.Deleted)
                                select pg).FirstOrDefault();

            #region ExternalCode 

            if (payrollGroup != null && loadExternalCode)
            {
                payrollGroup.ExternalCodes = new List<string>();

                var externalCodes = ActorManager.GetCompanyExternalCodes(entities, TermGroup_CompanyExternalCodeEntity.PayrollGroup, payrollGroup.PayrollGroupId, payrollGroup.ActorCompanyId);
                if (!externalCodes.IsNullOrEmpty())
                {
                    payrollGroup.ExternalCodes.AddRange(externalCodes.Select(s => s.ExternalCode));
                    payrollGroup.ExternalCodesString = StringUtility.GetSeparatedString(externalCodes.Select(s => s.ExternalCode), Constants.Delimiter, true, false);
                }
            }

            #endregion

            return payrollGroup;
        }

        public PayrollGroup GetPayrollGroup(string name, int actorCompanyId, bool onlyActive = true)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroup.NoTracking();
            return GetPayrollGroup(entities, name, actorCompanyId, onlyActive);
        }

        public PayrollGroup GetPayrollGroup(CompEntities entities, string name, int actorCompanyId, bool onlyActive = true)
        {
            return (from pg in entities.PayrollGroup
                    where pg.Name.ToLower() == name.ToLower() &&
                    pg.ActorCompanyId == actorCompanyId &&
                    (onlyActive ? pg.State == (int)SoeEntityState.Active : pg.State != (int)SoeEntityState.Deleted)
                    select pg).FirstOrDefault();
        }

        public PayrollGroup GetPayrollGroupByName(string name, int actorCompanyId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.EmployeeGroup.NoTracking();
            return GetPayrollGroupByName(entities, name, actorCompanyId);
        }

        public PayrollGroup GetPayrollGroupByName(CompEntities entities, string name, int actorCompanyId)
        {
            return (from eg in entities.PayrollGroup
                    where eg.Name == name &&
                    eg.ActorCompanyId == actorCompanyId &&
                    eg.State == (int)SoeEntityState.Active
                    select eg).FirstOrDefault();
        }

        public void LoadPayrollGroupExternalCodes(CompEntities entities, List<PayrollGroup> payrollGroups, int actorCompanyId)
        {
            if (payrollGroups.IsNullOrEmpty() || payrollGroups.All(eg => eg.ExternalCodesIsLoaded))
                return;

            var allExternalCodes = ActorManager.GetCompanyExternalCodes(entities, TermGroup_CompanyExternalCodeEntity.PayrollGroup, actorCompanyId);

            foreach (var payrollGroup in payrollGroups.Where(eg => !eg.ExternalCodesIsLoaded))
            {
                payrollGroup.ExternalCodes = new List<string>();

                var externalCodes = allExternalCodes.Where(eg => eg.RecordId == payrollGroup.PayrollGroupId).ToList();
                if (!externalCodes.IsNullOrEmpty())
                {
                    payrollGroup.ExternalCodes.AddRange(externalCodes.Select(s => s.ExternalCode));
                    payrollGroup.ExternalCodesString = StringUtility.GetSeparatedString(externalCodes.Select(s => s.ExternalCode), Constants.Delimiter, true, false);
                }

                payrollGroup.ExternalCodesIsLoaded = true;
            }
        }

        public bool PayrollGroupExists(string name, int actorCompanyId, bool onlyActive = true)
        {
            return GetPayrollGroup(name, actorCompanyId, onlyActive) != null;
        }

        public bool PayrollGroupVacationGroupExists(int VacationGroupId)
        {

            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            return (from pg in entitiesReadOnly.PayrollGroupVacationGroup
                    where
                    pg.VacationGroupId == VacationGroupId &&
                    pg.State == (int)SoeEntityState.Active
                    select pg).Any();
        }

        public bool HasPayrollGroups(int actorCompanyId)
        {
            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            return (from pg in entitiesReadOnly.PayrollGroup
                    where
                    pg.ActorCompanyId == actorCompanyId &&
                    pg.State == (int)SoeEntityState.Active
                    select pg).Any();
        }

        public bool IsPayrollGroupUsedInPayroll(int payrollGroupId, int timePeriodHeadId, int actorCompanyId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.EmployeeTimePeriod.NoTracking();
            return IsPayrollGroupUsedInPayroll(entities, payrollGroupId, timePeriodHeadId, actorCompanyId);
        }

        public bool IsPayrollGroupUsedInPayroll(CompEntities entities, int payrollGroupId, int timePeriodHeadId, int actorCompanyId)
        {
            List<EmployeeTimePeriod> employeeTimePeriods = (from ept in entities.EmployeeTimePeriod
                                                                .Include("TimePeriod")
                                                            where ept.ActorCompanyId == actorCompanyId &&
                                                            ept.TimePeriod.TimePeriodHead.TimePeriodHeadId == timePeriodHeadId &&
                                                            ept.State == (int)SoeEntityState.Active
                                                            select ept).ToList();

            foreach (var employeeTimePeriodsGroupedByEmployee in employeeTimePeriods.GroupBy(i => i.EmployeeId))
            {
                Employee employee = null;
                foreach (EmployeeTimePeriod employeeTimePeriod in employeeTimePeriodsGroupedByEmployee)
                {
                    if (employee == null)
                    {
                        if (!employeeTimePeriod.EmployeeReference.IsLoaded)
                            employeeTimePeriod.EmployeeReference.Load();
                        employeeTimePeriod.Employee.LoadEmploymentsAndEmploymentChangeBatch();
                        employee = employeeTimePeriod.Employee;
                    }

                    if (employee.GetPayrollGroupId(employeeTimePeriod.TimePeriod.StartDate, employeeTimePeriod.TimePeriod.StopDate) == payrollGroupId)
                        return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Check if all specified price types exists in specified payroll group
        /// </summary>
        /// <param name="payrollGroupId">Payroll group ID</param>
        /// <param name="priceTypeIds">List of price type IDs</param>
        /// <returns>True if all price types exist, otherwise false</returns>
        public bool PriceTypesExistsInPayrollGroup(int payrollGroupId, List<int> priceTypeIds)
        {
            if (priceTypeIds == null || priceTypeIds.Count == 0)
                return false;

            // Get payroll group with price types
            PayrollGroup payrollGroup = GetPayrollGroup(payrollGroupId, onlyActive: true, includePriceTypes: true);
            if (payrollGroup == null)
                return false;

            // Check if each specified price type exists in specified payroll group
            List<int> payrollGroupPriceTypeIds = payrollGroup.PayrollGroupPriceType.Select(p => p.PayrollPriceTypeId).ToList();
            foreach (int priceTypeId in priceTypeIds)
            {
                if (!payrollGroupPriceTypeIds.Contains(priceTypeId))
                    return false;
            }

            return true;
        }

        public ActionResult SavePayrollGroup(PayrollGroupDTO payrollGroupInput)
        {
            ActionResult result = new ActionResult(true);

            if (payrollGroupInput == null)
                return new ActionResult();

            int payrollGroupId = 0;

            List<Report> reports = ReportManager.GetReports(base.ActorCompanyId, null, reportIds: payrollGroupInput.ReportIds, onlyOriginal: true);

            using (CompEntities entities = new CompEntities())
            {
                #region PayrollGroup

                #region Add/Update

                PayrollGroup payrollGroup = this.GetPayrollGroup(entities, payrollGroupInput.PayrollGroupId, false, true, true, true, true, false, true, true, true);
                if (payrollGroup == null)
                {
                    #region Add

                    payrollGroup = new PayrollGroup()
                    {
                        ActorCompanyId = payrollGroupInput.ActorCompanyId,
                    };
                    SetCreatedProperties(payrollGroup);
                    entities.PayrollGroup.AddObject(payrollGroup);

                    #endregion
                }
                else
                {
                    #region Update

                    SetModifiedProperties(payrollGroup);

                    #endregion
                }

                payrollGroup.Name = payrollGroupInput.Name;
                payrollGroup.OneTimeTaxFormulaId = payrollGroupInput.OneTimeTaxFormulaId.HasValue ? payrollGroupInput.OneTimeTaxFormulaId.Value.ToNullable() : (int?)null;
                payrollGroup.State = (int)payrollGroupInput.State;

                #endregion

                #endregion

                #region TimePeriod

                if (payrollGroup.PayrollGroupId > 0 && payrollGroup.TimePeriodHeadId.HasValue && payrollGroup.TimePeriodHeadId.Value != payrollGroupInput.TimePeriodHeadId && IsPayrollGroupUsedInPayroll(entities, payrollGroup.PayrollGroupId, payrollGroup.TimePeriodHeadId.Value, payrollGroupInput.ActorCompanyId))
                    return new ActionResult((int)ActionResultSave.PayrollGroup_UsedInPayroll, GetText(11535, "Lön skapad, ändring av perioduppsättning ej tillåtet"));

                payrollGroup.TimePeriodHeadId = payrollGroupInput.TimePeriodHeadId.HasValue ? payrollGroupInput.TimePeriodHeadId.Value.ToNullable() : (int?)null;

                #endregion

                #region PayrollGroupAccountStd

                #region Update/Delete

                // Update or Delete existing PayrollGroupAccounts
                foreach (PayrollGroupAccountStd acc in payrollGroup.PayrollGroupAccountStd.ToList())
                {
                    if (!payrollGroupInput.Accounts.IsNullOrEmpty())
                    {
                        PayrollGroupAccountsDTO accInput = payrollGroupInput.Accounts.FirstOrDefault(p => p.FromInterval == acc.FromInterval && p.ToInterval == acc.ToInterval);
                        if (accInput != null)
                        {
                            switch ((PayrollGroupAccountType)acc.Type)
                            {
                                case PayrollGroupAccountType.EmploymentTax:
                                    if (accInput.EmploymentTaxAccountId.HasValue && accInput.EmploymentTaxAccountId.Value > 0)
                                    {
                                        if (accInput.EmploymentTaxAccountId != acc.AccountId)
                                            acc.AccountId = accInput.EmploymentTaxAccountId.Value;
                                        // Remove from input to prevent adding it again below
                                        accInput.EmploymentTaxAccountId = null;
                                    }
                                    else
                                        entities.DeleteObject(acc);
                                    break;
                                case PayrollGroupAccountType.PayrollTax:
                                    if (accInput.PayrollTaxAccountId.HasValue && accInput.PayrollTaxAccountId.Value > 0)
                                    {
                                        if (accInput.PayrollTaxAccountId != acc.AccountId)
                                            acc.AccountId = accInput.PayrollTaxAccountId.Value;
                                        // Remove from input to prevent adding it again below
                                        accInput.PayrollTaxAccountId = null;
                                    }
                                    else
                                        entities.DeleteObject(acc);
                                    break;
                                case PayrollGroupAccountType.OwnSupplementCharge:
                                    if (accInput.OwnSupplementChargeAccountId.HasValue && accInput.OwnSupplementChargeAccountId.Value > 0)
                                    {
                                        if (accInput.OwnSupplementChargeAccountId != acc.AccountId)
                                            acc.AccountId = accInput.OwnSupplementChargeAccountId.Value;
                                        if (accInput.OwnSupplementChargePercent != acc.Percent)
                                            acc.Percent = accInput.OwnSupplementChargePercent;
                                        // Remove from input to prevent adding it again below
                                        accInput.OwnSupplementChargeAccountId = null;
                                        accInput.OwnSupplementChargePercent = null;
                                    }
                                    else
                                        entities.DeleteObject(acc);
                                    break;
                            }
                        }
                    }
                }

                #endregion

                #region Add

                if (payrollGroupInput.Accounts != null && payrollGroupInput.Accounts.Count > 0)
                {
                    foreach (PayrollGroupAccountsDTO accountInput in payrollGroupInput.Accounts)
                    {
                        if (accountInput.EmploymentTaxAccountId.HasValue && accountInput.EmploymentTaxAccountId.Value > 0)
                            payrollGroup.AddPayrollGroupAccountStd(PayrollGroupAccountType.EmploymentTax, accountInput.EmploymentTaxAccountId.Value, accountInput.EmploymentTaxPercent, accountInput.FromInterval, accountInput.ToInterval);
                        if (accountInput.PayrollTaxAccountId.HasValue && accountInput.PayrollTaxAccountId.Value > 0)
                            payrollGroup.AddPayrollGroupAccountStd(PayrollGroupAccountType.PayrollTax, accountInput.PayrollTaxAccountId.Value, accountInput.PayrollTaxPercent, accountInput.FromInterval, accountInput.ToInterval);
                        if (accountInput.OwnSupplementChargeAccountId.HasValue && accountInput.OwnSupplementChargeAccountId.Value > 0)
                            payrollGroup.AddPayrollGroupAccountStd(PayrollGroupAccountType.OwnSupplementCharge, accountInput.OwnSupplementChargeAccountId.Value, accountInput.OwnSupplementChargePercent, accountInput.FromInterval, accountInput.ToInterval);
                    }
                }

                #endregion

                #endregion

                #region PayrollGroupPriceType

                #region Update/Delete

                // Update or Delete existing PayrollGroupPriceTypes
                foreach (PayrollGroupPriceType priceType in payrollGroup.PayrollGroupPriceType.Where(p => p.State == (int)SoeEntityState.Active).ToList())
                {
                    // Try get PriceType from input
                    PayrollGroupPriceTypeDTO priceTypeInput = (from p in payrollGroupInput.PriceTypes
                                                               where p.PayrollPriceTypeId == priceType.PayrollPriceTypeId &&
                                                               p.PayrollLevelId == priceType.PayrollLevelId
                                                               select p).FirstOrDefault();

                    if (priceTypeInput != null)
                    {
                        #region Update

                        if (priceType.Sort != priceTypeInput.Sort || priceType.ReadOnlyOnEmployee != priceTypeInput.ReadOnlyOnEmployee || priceType.ShowOnEmployee != priceTypeInput.ShowOnEmployee)
                        {
                            priceType.Sort = priceTypeInput.Sort;
                            priceType.ShowOnEmployee = priceTypeInput.ShowOnEmployee;
                            priceType.ReadOnlyOnEmployee = priceTypeInput.ReadOnlyOnEmployee;
                            SetModifiedProperties(priceType);
                        }

                        #region PayrollGroupPriceTypePeriod

                        #region Update/Delete

                        // Update or Delete existing PayrollGroupPriceTypePeriods
                        foreach (PayrollGroupPriceTypePeriod period in priceType.PayrollGroupPriceTypePeriod.Where(p => p.State == (int)SoeEntityState.Active).ToList())
                        {
                            // Try get Period from input
                            PayrollGroupPriceTypePeriodDTO periodInput = (from p in priceTypeInput.Periods
                                                                          where p.PayrollGroupPriceTypePeriodId == period.PayrollGroupPriceTypePeriodId
                                                                          select p).FirstOrDefault();

                            if (periodInput != null)
                            {
                                #region Update

                                if (period.FromDate != periodInput.FromDate || period.Amount != periodInput.Amount)
                                {
                                    period.FromDate = periodInput.FromDate;
                                    period.Amount = periodInput.Amount;
                                    SetModifiedProperties(period);
                                }

                                #endregion
                            }
                            else
                            {
                                #region Delete

                                period.State = (int)SoeEntityState.Deleted;
                                SetModifiedProperties(period);

                                #endregion
                            }

                            // Remove from input to prevent adding it again below
                            priceTypeInput.Periods.Remove(periodInput);
                        }

                        #endregion

                        #region Add

                        // Add all periods that is left in the input
                        foreach (PayrollGroupPriceTypePeriodDTO periodInput in priceTypeInput.Periods)
                        {
                            PayrollGroupPriceTypePeriod period = new PayrollGroupPriceTypePeriod()
                            {
                                FromDate = periodInput.FromDate,
                                Amount = periodInput.Amount
                            };
                            SetCreatedProperties(period);
                            priceType.PayrollGroupPriceTypePeriod.Add(period);
                        }

                        #endregion

                        #endregion

                        #endregion
                    }
                    else
                    {
                        #region Delete

                        // Check if price type is explicitly used on any employee
                        Dictionary<int, string> employeeNbrs = GetEmployeesUsingPayrollPriceType(entities, priceType.PayrollPriceTypeId, priceType.PayrollLevelId, payrollGroup.PayrollGroupId);
                        if (employeeNbrs.Count > 0)
                        {
                            string errMsg = GetText(3683, "Kan ej ta bort lönetyp") + "\n" + GetText(3684, "Lönetypen används på nedanstående anställda och måste först tas bort på dem innan den kan tas bort från löneavtalet") + "\n\n" + StringUtility.ToNewLineString(employeeNbrs.Values.ToList(), true);
                            result = new ActionResult((int)ActionResultSave.PayrollPriceTypeInUse, errMsg)
                            {
                                StrDict = employeeNbrs
                            };
                            return result;
                        }

                        priceType.State = (int)SoeEntityState.Deleted;
                        SetModifiedProperties(priceType);

                        #region PayrollGroupPriceTypePeriod

                        foreach (var period in priceType.PayrollGroupPriceTypePeriod.Where(p => p.State == (int)SoeEntityState.Active))
                        {
                            period.State = (int)SoeEntityState.Deleted;
                            SetModifiedProperties(period);
                        }

                        #endregion

                        #endregion
                    }

                    // Remove from input to prevent adding it again below
                    payrollGroupInput.PriceTypes.Remove(priceTypeInput);
                }

                #endregion

                #region Add

                // Add all PriceTypes that is left in the input
                foreach (PayrollGroupPriceTypeDTO priceTypeInput in payrollGroupInput.PriceTypes)
                {
                    PayrollGroupPriceType priceType = new PayrollGroupPriceType()
                    {
                        PayrollPriceTypeId = priceTypeInput.PayrollPriceTypeId,
                        Sort = priceTypeInput.Sort,
                        ShowOnEmployee = priceTypeInput.ShowOnEmployee,
                        ReadOnlyOnEmployee = priceTypeInput.ReadOnlyOnEmployee,
                        PayrollLevelId = priceTypeInput.PayrollLevelId.ToNullable(),
                    };
                    SetCreatedProperties(priceType);
                    payrollGroup.PayrollGroupPriceType.Add(priceType);

                    #region PayrollGroupPriceTypePeriod

                    if (priceTypeInput.Periods != null)
                    {
                        foreach (var periodInput in priceTypeInput.Periods)
                        {
                            PayrollGroupPriceTypePeriod period = new PayrollGroupPriceTypePeriod()
                            {
                                FromDate = periodInput.FromDate,
                                Amount = periodInput.Amount
                            };
                            SetCreatedProperties(period);
                            priceType.PayrollGroupPriceTypePeriod.Add(period);
                        }
                    }

                    #endregion
                }

                #endregion

                #endregion

                #region PayrollGroupPriceFormula

                #region Update/Delete

                // Update or Delete existing PayrollGroupPriceFormulas
                foreach (PayrollGroupPriceFormula priceFormula in payrollGroup.PayrollGroupPriceFormula.Where(p => p.State == (int)SoeEntityState.Active).ToList())
                {
                    // Try get PriceFormula from input
                    PayrollGroupPriceFormulaDTO priceFormulaInput = (from p in payrollGroupInput.PriceFormulas
                                                                     where p.PayrollGroupPriceFormulaId == priceFormula.PayrollGroupPriceFormulaId
                                                                     select p).FirstOrDefault();

                    if (priceFormulaInput != null)
                    {
                        #region Update

                        if (priceFormula.PayrollPriceFormulaId != priceFormulaInput.PayrollPriceFormulaId ||
                            priceFormula.ShowOnEmployee != priceFormulaInput.ShowOnEmployee ||
                            priceFormula.FromDate != priceFormulaInput.FromDate ||
                            priceFormula.ToDate != priceFormulaInput.ToDate)
                        {
                            priceFormula.PayrollPriceFormulaId = priceFormulaInput.PayrollPriceFormulaId;
                            priceFormula.ShowOnEmployee = priceFormulaInput.ShowOnEmployee;
                            priceFormula.FromDate = priceFormulaInput.FromDate;
                            priceFormula.ToDate = priceFormulaInput.ToDate;
                            SetModifiedProperties(priceFormula);
                        }

                        #endregion
                    }
                    else
                    {
                        #region Delete

                        priceFormula.State = (int)SoeEntityState.Deleted;
                        SetModifiedProperties(priceFormula);

                        #endregion
                    }

                    // Remove from input to prevent adding it again below
                    payrollGroupInput.PriceFormulas.Remove(priceFormulaInput);
                }

                #endregion

                #region Add

                // Add all PriceFormulas that is left in the input
                foreach (PayrollGroupPriceFormulaDTO priceFormulaInput in payrollGroupInput.PriceFormulas)
                {
                    PayrollGroupPriceFormula priceFormula = new PayrollGroupPriceFormula()
                    {
                        PayrollPriceFormulaId = priceFormulaInput.PayrollPriceFormulaId,
                        ShowOnEmployee = priceFormulaInput.ShowOnEmployee,
                        FromDate = priceFormulaInput.FromDate,
                        ToDate = priceFormulaInput.ToDate
                    };
                    SetCreatedProperties(priceFormula);
                    payrollGroup.PayrollGroupPriceFormula.Add(priceFormula);
                }

                #endregion

                #endregion

                #region PayrollGroupReport

                #region Delete

                // Delete existing PayrollGroupReports
                foreach (PayrollGroupReport payrollGroupReport in payrollGroup.PayrollGroupReport.Where(x => x.State == (int)SoeEntityState.Active).ToList())
                {
                    if (!payrollGroupInput.ReportIds.Contains(payrollGroupReport.ReportId))
                        payrollGroupReport.State = (int)SoeEntityState.Deleted;

                    // Remove from input to prevent adding it again below
                    payrollGroupInput.ReportIds.Remove(payrollGroupReport.ReportId);
                }

                #endregion

                #region Add

                if (!payrollGroupInput.ReportIds.IsNullOrEmpty())
                {
                    foreach (int reportId in payrollGroupInput.ReportIds)
                    {
                        Report report = reports.FirstOrDefault(r => r.ReportId == reportId);
                        if (report == null)
                            continue;

                        PayrollGroupReport newPayrollGroupReport = new PayrollGroupReport()
                        {
                            ActorCompanyId = payrollGroupInput.ActorCompanyId,
                            ReportId = reportId,
                            SysReportTemplateTypeId = report.SysReportTemplateTypeId ?? 0,
                        };

                        SetCreatedProperties(newPayrollGroupReport);
                        payrollGroup.PayrollGroupReport.Add(newPayrollGroupReport);
                    }
                }

                #endregion

                #endregion

                #region PayrollGroupSettings

                List<PayrollGroupSetting> settings = GetPayrollGroupSettings(entities, payrollGroupInput.PayrollGroupId);
                foreach (PayrollGroupSettingDTO settingDTO in payrollGroupInput.Settings)
                {
                    PayrollGroupSetting setting = settings.FirstOrDefault(s => s.PayrollGroupSettingId == settingDTO.Id);
                    if (setting == null)
                    {
                        #region Add

                        setting = new PayrollGroupSetting()
                        {
                            DataType = (int)settingDTO.DataType,
                            Type = (int)settingDTO.Type,
                            Name = settingDTO.Name ?? settingDTO.DataType.ToString(),
                            StrData = settingDTO.StrData,
                            IntData = settingDTO.IntData,
                            DecimalData = settingDTO.DecimalData,
                            BoolData = settingDTO.BoolData,
                            DateData = settingDTO.DateData,
                            TimeData = settingDTO.TimeData
                        };
                        SetCreatedProperties(setting);
                        payrollGroup.PayrollGroupSetting.Add(setting);

                        #endregion
                    }
                    else
                    {
                        #region Update

                        setting.DataType = (int)settingDTO.DataType;
                        setting.Type = (int)settingDTO.Type;
                        setting.Name = settingDTO.Name ?? settingDTO.DataType.ToString();
                        setting.StrData = settingDTO.StrData;
                        setting.IntData = settingDTO.IntData;
                        setting.DecimalData = settingDTO.DecimalData;
                        setting.BoolData = settingDTO.BoolData;
                        setting.DateData = settingDTO.DateData;
                        setting.TimeData = settingDTO.TimeData;
                        SetModifiedProperties(setting);

                        #endregion
                    }
                }

                #endregion

                #region PayrollGroupVacationGroups

                #region Update/Delete

                // Update or Delete existing PayrollGroupVacationGroups
                foreach (PayrollGroupVacationGroup payrollGroupVacationGroup in payrollGroup.PayrollGroupVacationGroup.Where(x => x.State == (int)SoeEntityState.Active).ToList())
                {
                    // Try get PayrollGroupVacationGroup from input
                    PayrollGroupVacationGroupDTO payrollGroupVacationGroupInput = (from p in payrollGroupInput.Vacations
                                                                                   where p.PayrollGroupVacationGroupId == payrollGroupVacationGroup.PayrollGroupVacationGroupId
                                                                                   select p).FirstOrDefault();

                    if (payrollGroupVacationGroupInput != null)
                    {
                        #region Update

                        payrollGroupVacationGroup.PayrollGroupId = payrollGroupVacationGroupInput.PayrollGroupId;
                        payrollGroupVacationGroup.VacationGroupId = payrollGroupVacationGroupInput.VacationGroupId;
                        payrollGroupVacationGroup.Default = payrollGroupVacationGroupInput.IsDefault;

                        #endregion
                    }
                    else
                    {
                        #region Delete

                        Dictionary<int, string> vacationGroupInUse = GetEmploymentVacationGroups(entities, payrollGroupVacationGroup.VacationGroupId);
                        if (vacationGroupInUse.Count > 0)
                        {
                            result = new ActionResult((int)ActionResultSave.EmploymentVacationGroupInUse)
                            {
                                StrDict = vacationGroupInUse
                            };
                            return result;
                        }

                        payrollGroupVacationGroup.State = (int)SoeEntityState.Deleted;

                        #endregion
                    }
                    SetModifiedProperties(payrollGroupVacationGroup);
                    // Remove from input to prevent adding it again below
                    payrollGroupInput.Vacations.Remove(payrollGroupVacationGroupInput);
                }
                #endregion

                #region Add

                foreach (PayrollGroupVacationGroupDTO payrollGroupVacationGroupDTO in payrollGroupInput.Vacations)
                {
                    PayrollGroupVacationGroup newPayrollGroupVacationGroup = new PayrollGroupVacationGroup()
                    {
                        PayrollGroupId = payrollGroupVacationGroupDTO.PayrollGroupId,
                        VacationGroupId = payrollGroupVacationGroupDTO.VacationGroupId,
                        Default = payrollGroupVacationGroupDTO.IsDefault,
                    };

                    SetCreatedProperties(newPayrollGroupVacationGroup);
                    payrollGroup.PayrollGroupVacationGroup.Add(newPayrollGroupVacationGroup);
                }

                #endregion

                #endregion

                #region PayrollGroupPayrollProducts

                #region Update/Delete

                // Update or Delete existing PayrollGroupPayrollProducts
                foreach (PayrollGroupPayrollProduct payrollGroupPayrollProduct in payrollGroup.PayrollGroupPayrollProduct.Where(x => x.State == (int)SoeEntityState.Active).ToList())
                {
                    // Try get PayrollGroupPayrollProduct from input
                    PayrollGroupPayrollProductDTO payrollGroupPayrollProductInput = (from p in payrollGroupInput.PayrollProducts
                                                                                     where p.PayrollGroupPayrollProductId == payrollGroupPayrollProduct.PayrollGroupPayrollProductId
                                                                                     select p).FirstOrDefault();

                    if (payrollGroupPayrollProductInput != null)
                    {
                        #region Update

                        payrollGroupPayrollProduct.PayrollGroupId = payrollGroupPayrollProductInput.PayrollGroupId;
                        payrollGroupPayrollProduct.ProductId = payrollGroupPayrollProductInput.ProductId;
                        payrollGroupPayrollProduct.Distribute = payrollGroupPayrollProductInput.Distribute;

                        #endregion
                    }
                    else
                    {
                        #region Delete

                        payrollGroupPayrollProduct.State = (int)SoeEntityState.Deleted;

                        #endregion
                    }
                    SetModifiedProperties(payrollGroupPayrollProduct);
                    // Remove from input to prevent adding it again below
                    payrollGroupInput.PayrollProducts.Remove(payrollGroupPayrollProductInput);
                }
                #endregion

                #region Add

                foreach (PayrollGroupPayrollProductDTO payrollGroupPayrollProductDTO in payrollGroupInput.PayrollProducts)
                {
                    PayrollGroupPayrollProduct newPayrollGroupPayrollProduct = new PayrollGroupPayrollProduct()
                    {
                        PayrollGroupId = payrollGroupPayrollProductDTO.PayrollGroupId,
                        ProductId = payrollGroupPayrollProductDTO.ProductId,
                        Distribute = payrollGroupPayrollProductDTO.Distribute,
                    };

                    SetCreatedProperties(newPayrollGroupPayrollProduct);
                    payrollGroup.PayrollGroupPayrollProduct.Add(newPayrollGroupPayrollProduct);
                }

                #endregion

                #endregion

                result = SaveChanges(entities);

                ActorManager.UpsertExternalNbrs(entities, TermGroup_CompanyExternalCodeEntity.PayrollGroup, payrollGroup.PayrollGroupId, payrollGroupInput.ExternalCodesString, payrollGroup.ActorCompanyId);

                if (!result.Success)
                    return result;

                payrollGroupId = payrollGroup.PayrollGroupId;
            }

            result.IntegerValue = payrollGroupId;

            return result;
        }

        public ActionResult DeletePayrollGroup(int payrollGroupId)
        {
            using (CompEntities entities = new CompEntities())
            {
                PayrollGroup payrollGroup = GetPayrollGroup(entities, payrollGroupId, false);
                if (payrollGroup == null)
                    return new ActionResult((int)ActionResultDelete.EntityNotFound, "PayrollGroup");

                if (PayrollGroupInUse(payrollGroupId))
                    return new ActionResult((int)ActionResultDelete.PayrollGroupInUse, GetText(3682, 1, "Löneavtalet används och kan därför ej tas bort"));

                ActorManager.UpsertExternalNbrs(entities, TermGroup_CompanyExternalCodeEntity.PayrollGroup, payrollGroup.PayrollGroupId, "", payrollGroup.ActorCompanyId);

                return ChangeEntityState(entities, payrollGroup, SoeEntityState.Deleted, true);
            }
        }

        private bool PayrollGroupInUse(int payrollGroupId)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            if (entitiesReadOnly.Employment.Any(e => e.OriginalPayrollGroupId == payrollGroupId && e.State == (int)SoeEntityState.Active))
                return true;

            if (entitiesReadOnly.EmploymentChange.Any(e => e.FieldType == (int)TermGroup_EmploymentChangeFieldType.PayrollGroupId && (e.FromValue == payrollGroupId.ToString() || e.ToValue == payrollGroupId.ToString())))
                return true;

            if (entitiesReadOnly.PayrollReviewHead.Any(p => p.PayrollGroupId == payrollGroupId && p.State == (int)SoeEntityState.Active))
                return true;
            return false;
        }

        private Dictionary<int, string> GetEmployeesUsingPayrollPriceType(CompEntities entities, int payrollPriceTypeId, int? payrollLevelId, int? payrollGroupId)
        {
            Dictionary<int, string> dict = new Dictionary<int, string>();

            List<Employee> employees;

            if (!payrollLevelId.HasValue)
            {
                employees = (from p in entities.EmploymentPriceType.Include("Employment")
                             where p.PayrollPriceTypeId == payrollPriceTypeId &&
                             p.EmploymentPriceTypePeriod.Any(x => x.State == (int)SoeEntityState.Active && !x.PayrollLevelId.HasValue) &&
                             p.State == (int)SoeEntityState.Active
                             select p.Employment.Employee).Distinct().ToList();

            }
            else
            {
                employees = (from p in entities.EmploymentPriceType.Include("Employment")
                             where p.PayrollPriceTypeId == payrollPriceTypeId &&
                             p.EmploymentPriceTypePeriod.Any(x => x.State == (int)SoeEntityState.Active && x.PayrollLevelId == payrollLevelId.Value) &&
                             p.State == (int)SoeEntityState.Active
                             select p.Employment.Employee).Distinct().ToList();
            }

            foreach (var employee in employees)
            {
                if (!payrollGroupId.HasValue || employee.GetPayrollGroupId() == payrollGroupId)
                    dict.Add(employee.EmployeeId, employee.EmployeeNr);
            }

            return dict;
        }

        private Dictionary<int, string> GetEmploymentVacationGroups(CompEntities entities, int VacationGroupId)
        {
            Dictionary<int, string> dict = new Dictionary<int, string>();

            var vacationGroups = (from evg in entities.EmploymentVacationGroup
                                  where evg.VacationGroupId == VacationGroupId &&
                                  evg.State == (int)SoeEntityState.Active
                                  select evg).Distinct().ToList();

            foreach (var vacationGroup in vacationGroups)
            {
                dict.Add(vacationGroup.EmploymentVacationGroupId, vacationGroup.VacationGroup.Name);
            }

            return dict;
        }

        #endregion

        #region PayrollGroupAccount

        public PayrollGroupAccountStd GetPayrollGroupAccountStd(int payrollGroupId, PayrollGroupAccountType type, decimal intervalValue)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroupAccountStd.NoTracking();
            return GetPayrollGroupAccountStd(entities, payrollGroupId, type, intervalValue);
        }

        public PayrollGroupAccountStd GetPayrollGroupAccountStd(CompEntities entities, int payrollGroupId, PayrollGroupAccountType type, decimal intervalValue)
        {
            return (from p in entities.PayrollGroupAccountStd.Include("AccountStd.Account")
                    where p.PayrollGroupId == payrollGroupId &&
                          p.Type == (int)type &&
                          (!p.FromInterval.HasValue || p.FromInterval <= intervalValue) &&
                          (!p.ToInterval.HasValue || p.ToInterval >= intervalValue)
                    select p).FirstOrDefault();
        }

        public List<PayrollGroupAccountStd> GetPayrollGroupAccountStds(CompEntities entities, int payrollGroupId, PayrollGroupAccountType type, decimal intervalValue, List<PayrollGroupAccountStd> payrollGroupAccountStds = null)
        {
            if (payrollGroupAccountStds == null)
                return (from p in entities.PayrollGroupAccountStd
                        where p.PayrollGroupId == payrollGroupId &&
                              p.Type == (int)type &&
                              (!p.FromInterval.HasValue || p.FromInterval <= intervalValue) &&
                              (!p.ToInterval.HasValue || p.ToInterval >= intervalValue)
                        select p).ToList();
            else
                return (from p in payrollGroupAccountStds
                        where p.PayrollGroupId == payrollGroupId &&
                              p.Type == (int)type &&
                              (!p.FromInterval.HasValue || p.FromInterval <= intervalValue) &&
                              (!p.ToInterval.HasValue || p.ToInterval >= intervalValue)
                        select p).ToList();
        }

        public List<PayrollGroupAccountStd> GetPayrollGroupAccountStdsForCompany(CompEntities entities, int actorCompanyId)
        {
            return (from p in entities.PayrollGroupAccountStd
                    where p.PayrollGroup.ActorCompanyId == actorCompanyId
                    select p).ToList();
        }

        public List<DateTime> GetPayrollGroupAccountDates(int sysCountryId)
        {
            List<SysPayrollPrice> employmentTaxPrices = GetSysPayrollPrices(sysCountryId, (int)TermGroup_SysPayrollPrice.SE_EmploymentTax);
            List<SysPayrollPrice> payrollTaxPrices = GetSysPayrollPrices(sysCountryId, (int)TermGroup_SysPayrollPrice.SE_PayrollTax);

            List<DateTime> dates = new List<DateTime>();

            if (employmentTaxPrices != null && employmentTaxPrices.Count > 0)
                dates.AddRange(employmentTaxPrices.Where(p => p.FromDate.HasValue).Select(p => p.FromDate.Value));

            if (payrollTaxPrices != null && payrollTaxPrices.Count > 0)
                dates.AddRange(payrollTaxPrices.Where(p => p.FromDate.HasValue).Select(p => p.FromDate.Value));

            return dates.Distinct().ToList();
        }

        #endregion

        #region PayrollGroupPayrollProduct

        public List<PayrollGroupPayrollProduct> GetPayrollGroupPayrollProducts(int payrollGroupId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroupPayrollProduct.NoTracking();
            return GetPayrollGroupPayrollProducts(entities, payrollGroupId);
        }

        public List<PayrollGroupPayrollProduct> GetPayrollGroupPayrollProducts(CompEntities entities, int payrollGroupId)
        {
            IQueryable<PayrollGroupPayrollProduct> query = entities.PayrollGroupPayrollProduct.Include("PayrollProduct");

            return (from pgp in query
                    where pgp.PayrollGroupId == payrollGroupId &&
                    pgp.State == (int)SoeEntityState.Active
                    select pgp).ToList();
        }

        #endregion

        #region PayrollGroupPriceFormula

        public List<PayrollGroupPriceFormula> GetPayrollGroupPriceFormulas(int payrollGroupId, bool? showOnEmployee = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroupPriceFormula.NoTracking();
            return GetPayrollGroupPriceFormulas(entities, payrollGroupId, showOnEmployee);
        }

        public List<PayrollGroupPriceFormula> GetPayrollGroupPriceFormulas(CompEntities entities, int payrollGroupId, bool? showOnEmployee = null)
        {
            var query = (from p in entities.PayrollGroupPriceFormula
                             .Include("PayrollPriceFormula")
                         where p.PayrollGroupId == payrollGroupId &&
                         p.State == (int)SoeEntityState.Active
                         select p);

            if (showOnEmployee.HasValue)
                query = query.Where(p => p.ShowOnEmployee == showOnEmployee.Value);

            return query.ToList();
        }

        public List<PayrollGroupPriceFormula> GetPayrollGroupPriceFormulas(int payrollGroupId, int payrollPriceFormulaId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroupPriceFormula.NoTracking();
            return GetPayrollGroupPriceFormulas(entities, payrollGroupId, payrollPriceFormulaId);
        }

        public List<PayrollGroupPriceFormula> GetPayrollGroupPriceFormulas(CompEntities entities, int payrollGroupId, int payrollPriceFormulaId)
        {
            return (from p in entities.PayrollGroupPriceFormula
                    where p.PayrollGroupId == payrollGroupId &&
                    p.PayrollPriceFormulaId == payrollPriceFormulaId &&
                    p.State == (int)SoeEntityState.Active
                    select p).ToList();
        }

        public PayrollGroupPriceFormula GetPayrollGroupPriceFormula(int payrollGroupPriceFormulaId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroupPriceFormula.NoTracking();
            return GetPayrollGroupPriceFormula(entities, payrollGroupPriceFormulaId);
        }

        public PayrollGroupPriceFormula GetPayrollGroupPriceFormula(CompEntities entities, int payrollGroupPriceFormulaId)
        {
            return (from p in entities.PayrollGroupPriceFormula
                    where p.PayrollGroupPriceFormulaId == payrollGroupPriceFormulaId
                    select p).FirstOrDefault();
        }

        #endregion

        #region PayrollGroupPriceType

        public List<PayrollGroupPriceType> GetPayrollGroupPriceTypesForCompany(int actorCompanyId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroupPriceType.NoTracking();
            return GetPayrollGroupPriceTypesForCompany(entities, actorCompanyId);
        }

        public List<PayrollGroupPriceType> GetPayrollGroupPriceTypesForCompany(CompEntities entities, int actorCompanyId)
        {
            return (from p in entities.PayrollGroupPriceType
                        .Include("PayrollGroupPriceTypePeriod")
                        .Include("PayrollPriceType.PayrollPriceTypePeriod")
                        .Include("PayrollLevel")
                    where p.PayrollGroup.ActorCompanyId == actorCompanyId &&
                    p.State == (int)SoeEntityState.Active
                    select p).ToList();
        }

        public List<PayrollGroupPriceType> GetPayrollGroupPriceTypes(int payrollGroupId, bool? showOnEmployee = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetPayrollGroupPriceTypes(entities, payrollGroupId, showOnEmployee);
        }

        public List<PayrollGroupPriceType> GetPayrollGroupPriceTypes(CompEntities entities, int payrollGroupId, bool? showOnEmployee = null)
        {
            var query = (from p in entities.PayrollGroupPriceType
                            .Include("PayrollGroupPriceTypePeriod")
                            .Include("PayrollPriceType.PayrollPriceTypePeriod")
                            .Include("PayrollLevel")
                         where p.PayrollGroupId == payrollGroupId &&
                         p.State == (int)SoeEntityState.Active
                         select p);

            if (showOnEmployee.HasValue)
                query = query.Where(p => p.ShowOnEmployee == showOnEmployee.Value);

            return query.ToList();
        }

        public PayrollGroupPriceType GetPayrollGroupPriceType(CompEntities entities, int payrollGroupId, int payrollPriceTypeId, int? payrollLevelId)
        {
            List<PayrollGroupPriceType> priceTypes = (from p in entities.PayrollGroupPriceType
                                                      .Include("PayrollGroupPriceTypePeriod")
                                                      where p.PayrollGroupId == payrollGroupId &&
                                                      p.PayrollPriceTypeId == payrollPriceTypeId &&
                                                      p.State == (int)SoeEntityState.Active
                                                      select p).ToList();

            if (payrollLevelId.HasValue)
                return priceTypes.FirstOrDefault(x => x.PayrollLevelId == payrollLevelId.Value);
            else
                return priceTypes.FirstOrDefault(x => !x.PayrollLevelId.HasValue);
        }

        #endregion

        #region PayrollGroupReport

        public List<PayrollGroupReport> GetPayrollGroupReports(int actorCompanyId, int payrollGroupId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroupReport.NoTracking();
            return GetPayrollGroupReports(entities, actorCompanyId, payrollGroupId);
        }

        public List<PayrollGroupReport> GetPayrollGroupReports(CompEntities entities, int actorCompanyId, int payrollGroupId)
        {
            return (from pgr in entities.PayrollGroupReport
                    .Include("Report")
                    where pgr.ActorCompanyId == actorCompanyId &&
                    pgr.PayrollGroupId == payrollGroupId &&
                    pgr.State == (int)SoeEntityState.Active &&
                    pgr.Report.State == (int)SoeEntityState.Active
                    select pgr).ToList();
        }

        public List<PayrollGroupReportDTO> GetCompanyPayrollGroupReports(int actorCompanyId, bool checkRolePermission = false, int? roleId = 0)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroupReport.NoTracking();
            return GetCompanyPayrollGroupReports(entities, actorCompanyId, checkRolePermission, roleId);
        }

        public List<PayrollGroupReportDTO> GetCompanyPayrollGroupReports(CompEntities entities, int actorCompanyId, bool checkRolePermission = false, int? roleId = null)
        {
            List<PayrollGroupReportDTO> dtos = new List<PayrollGroupReportDTO>();

            var query = entities.PayrollGroupReport.Include("Report");
            if (checkRolePermission)
                query = query.Include("Report.ReportRolePermission");

            List<PayrollGroupReport> payrollGroupReports = (from pgr in query
                                                            where pgr.ActorCompanyId == actorCompanyId &&
                                                            pgr.State == (int)SoeEntityState.Active &&
                                                            pgr.Report.State == (int)SoeEntityState.Active
                                                            select pgr).ToList();

            // If has any reports connected to PayrollGroup, return them. If does not have any reports connected to PayrollGroup, but have PayrollGroups, return empty
            if (!payrollGroupReports.Any() && !HasPayrollGroups(actorCompanyId))
            {
                // Otherwise, return reports for Company
                var dict = ReportManager.GetReportsByTemplateTypeDict(actorCompanyId, SoeReportTemplateType.TimeEmploymentContract, onlyOriginal: true);
                foreach (var pair in dict)
                {
                    dtos.Add(new PayrollGroupReportDTO()
                    {
                        PayrollGroupReportId = 0,
                        ActorCompanyId = actorCompanyId,
                        PayrollGroupId = 0,
                        ReportId = pair.Key,
                        ReportName = pair.Value,
                        ReportNr = 0,
                        ReportDescription = "",
                        SysReportTemplateTypeId = (int)SoeReportTemplateType.TimeEmploymentContract,
                    });
                }
            }
            else if (checkRolePermission && roleId.HasValue) // Check role permission on reports
            {
                dtos = FilterPayrollGroupReportsOnPermission(payrollGroupReports, actorCompanyId, roleId);
            }

            dtos.AddRange(GetEmployeeTemplateReports(entities, actorCompanyId, false, roleId, dtos));
            return dtos.Where(w => w.State != SoeEntityState.Deleted).ToList();
        }

        public List<PayrollGroupReportDTO> FilterPayrollGroupReportsOnPermission(List<PayrollGroupReport> payrollGroupReports, int actorCompanyId, int? roleId)
        {
            List<PayrollGroupReportDTO> dtos = new List<PayrollGroupReportDTO>();
            // Check role permission on reports
            if (payrollGroupReports.Any() && roleId.HasValue)
            {
                foreach (var payrollGroupReport in payrollGroupReports)
                {
                    if (dtos.Any(x => x.PayrollGroupId == payrollGroupReport.PayrollGroupId && x.ReportId == payrollGroupReport.ReportId))
                        continue;

                    if (payrollGroupReport.Report.ReportRolePermission.HasReportRolePermission(payrollGroupReport.ReportId, roleId.Value))
                    {
                        var reportTemplateType = ReportManager.GetSysReportTemplateType(payrollGroupReport.Report, actorCompanyId);
                        if (reportTemplateType != null && (reportTemplateType.SysReportTemplateTypeId == (int)SoeReportTemplateType.TimeEmploymentContract || reportTemplateType.SysReportTemplateTypeId == (int)SoeReportTemplateType.TimeEmploymentDynamicContract))
                            dtos.Add(payrollGroupReport.ToDTO());
                    }
                }
            }

            return dtos;
        }

        public List<PayrollGroupReportDTO> GetEmployeeTemplateReports(CompEntities entities, int actorCompanyId, bool checkRolePermission = false, int? roleId = null, List<PayrollGroupReportDTO> dtos = null)
        {
            if (base.HasEmployeeTemplatesFromCache(entities, actorCompanyId))
            {
                if (dtos == null)
                {
                    var query = entities.PayrollGroupReport.Include("Report");
                    if (checkRolePermission)
                        query = query.Include("Report.ReportRolePermission");

                    var payrollGroupReports = (from pgr in query
                                               where pgr.ActorCompanyId == actorCompanyId &&
                                                 pgr.State == (int)SoeEntityState.Active &&
                                                 pgr.Report.State == (int)SoeEntityState.Active &&
                                                 pgr.SysReportTemplateTypeId == (int)SoeReportTemplateType.TimeEmploymentDynamicContract
                                               select pgr).ToList();

                    if (checkRolePermission)
                        dtos = FilterPayrollGroupReportsOnPermission(payrollGroupReports, actorCompanyId, roleId);
                    else
                        dtos = payrollGroupReports.ToDTOs().ToList();
                }

                List<PayrollGroupReportDTO> templateDTOs = new List<PayrollGroupReportDTO>();
                foreach (var pgr in dtos.Where(w => w.SysReportTemplateTypeId == (int)SoeReportTemplateType.TimeEmploymentDynamicContract))
                {
                    pgr.State = SoeEntityState.Deleted;

                    var templates = EmployeeManager.GetEmployeeTemplates(entities, actorCompanyId, loadCollectiveAgreement: false, loadGroups: false, loadRows: false, payrollGroupId: pgr.PayrollGroupId);

                    if (templates.Any())
                    {
                        foreach (var pair in templates)
                        {
                            templateDTOs.Add(new PayrollGroupReportDTO()
                            {
                                PayrollGroupReportId = 0,
                                EmployeeTemplateId = pair.EmployeeTemplateId,
                                ActorCompanyId = actorCompanyId,
                                PayrollGroupId = pgr.PayrollGroupId,
                                ReportId = pgr.ReportId,
                                ReportName = pair.Name,
                                ReportNr = 0,
                                ReportDescription = pair.Description,
                                SysReportTemplateTypeId = (int)SoeReportTemplateType.TimeEmploymentDynamicContract,
                            });
                        }
                    }
                }

                return templateDTOs;
            }
            else
                return new List<PayrollGroupReportDTO>();
        }

        public int? GetReportForEmployeeTemplateId(CompEntities entities, int actorCompanyId, int employeeTemplateId)
        {
            return GetEmployeeTemplateReports(entities, actorCompanyId, true, base.RoleId).FirstOrDefault(w => w.EmployeeTemplateId == employeeTemplateId)?.ReportId ?? (int?)null;
        }

        #endregion

        #region PayrollGroupSettings

        public List<PayrollGroupSetting> GetPayrollGroupSettingsForCompany(int actorCompanyId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroupSetting.NoTracking();
            return GetPayrollGroupSettingsForCompany(entities, actorCompanyId);
        }

        public List<PayrollGroupSetting> GetPayrollGroupSettingsForCompany(CompEntities entities, int actorCompanyId)
        {
            return (from pg in entities.PayrollGroupSetting
                    where pg.PayrollGroup.ActorCompanyId == actorCompanyId &&
                    pg.State == (int)SoeEntityState.Active
                    select pg).ToList();
        }

        public List<PayrollGroupSetting> GetPayrollGroupSettings(CompEntities entities, int payrollGroupId)
        {
            return (from pg in entities.PayrollGroupSetting
                    where pg.PayrollGroupId == payrollGroupId &&
                    pg.State == (int)SoeEntityState.Active
                    select pg).ToList();
        }

        public PayrollGroupSetting GetPayrollGroupSetting(int payrollGroupId, PayrollGroupSettingType type, List<PayrollGroup> payrollGroups = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroupSetting.NoTracking();
            return GetPayrollGroupSetting(entities, payrollGroupId, type, payrollGroups);
        }

        public PayrollGroupSetting GetPayrollGroupSetting(CompEntities entities, int payrollGroupId, PayrollGroupSettingType type, List<PayrollGroup> payrollGroups = null)
        {
            var payrollGroup = payrollGroups?.FirstOrDefault(pg => pg.PayrollGroupId == payrollGroupId);
            if (payrollGroup != null && payrollGroup.PayrollGroupSetting.IsLoaded)
                return payrollGroup.PayrollGroupSetting
                    .FirstOrDefault(pg => pg.Type == (int)type && pg.State == (int)SoeEntityState.Active);
            else
                return entities.PayrollGroupSetting
                    .FirstOrDefault(pg => pg.Type == (int)type && pg.State == (int)SoeEntityState.Active && pg.PayrollGroupId == payrollGroupId);
        }

        public object GetPayrollGroupSettingValue(PayrollGroupSetting setting)
        {
            object value = null;

            if (setting == null)
                return value;

            switch (setting.DataType)
            {
                case (int)SettingDataType.String:
                    value = setting.StrData;
                    break;
                case (int)SettingDataType.Integer:
                    value = setting.IntData;
                    break;
                case (int)SettingDataType.Boolean:
                    value = setting.BoolData;
                    break;
                case (int)SettingDataType.Date:
                case (int)SettingDataType.Time:
                    value = setting.DateData;
                    break;
                case (int)SettingDataType.Decimal:
                    value = setting.DecimalData;
                    break;
            }

            return value;
        }

        #endregion

        #region PayrollGroupVacationGroup

        public List<PayrollGroupVacationGroup> GetPayrollGroupVacationGroups(int payrollGroupId, bool loadVacationGroupSE)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollGroupVacationGroup.NoTracking();
            return GetPayrollGroupVacationGroups(entities, payrollGroupId, loadVacationGroupSE);
        }

        public List<PayrollGroupVacationGroup> GetPayrollGroupVacationGroups(CompEntities entities, int payrollGroupId, bool loadVacationGroupSE)
        {
            IQueryable<PayrollGroupVacationGroup> query = entities.PayrollGroupVacationGroup.Include("VacationGroup");
            if (loadVacationGroupSE)
                query = query.Include("VacationGroup.VacationGroupSE");

            return (from pgv in query
                    where pgv.PayrollGroupId == payrollGroupId &&
                    pgv.State == (int)SoeEntityState.Active
                    select pgv).ToList();
        }

        #endregion

        #region PayrollLevel

        public PayrollLevel GetPayrollLevel(int actorCompanyId, int payrollLevelId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollLevel.NoTracking();
            return GetPayrollLevel(entities, actorCompanyId, payrollLevelId);
        }

        public PayrollLevel GetPayrollLevel(CompEntities entities, int actorCompanyId, int payrollLevelId)
        {
            return entities.PayrollLevel.FirstOrDefault(l => l.PayrollLevelId == payrollLevelId && l.ActorCompanyId == actorCompanyId);
        }

        public List<PayrollLevel> GetPayrollLevels(int actorCompanyId, int? payrollLevelId = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollLevel.NoTracking();
            return GetPayrollLevels(entities, actorCompanyId, payrollLevelId);
        }

        public List<PayrollLevel> GetPayrollLevels(CompEntities entities, int actorCompanyId, int? payrollLevelId = null)
        {
            IQueryable<PayrollLevel> query = (from pl in entities.PayrollLevel
                                              where pl.ActorCompanyId == actorCompanyId &&
                                              (pl.State == (int)SoeEntityState.Active || pl.State == (int)SoeEntityState.Inactive)
                                              select pl);

            if (payrollLevelId.HasValue)
                query = query.Where(s => s.PayrollLevelId == payrollLevelId.Value);

            List<PayrollLevel> payrollLevels = query.ToList();

            return payrollLevels.OrderBy(a => a.Name).ToList();
        }

        public bool UsePayrollLevels(int actorCompanyId)
        {
            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            return (from pl in entitiesReadOnly.PayrollLevel
                    where pl.ActorCompanyId == actorCompanyId &&
                    (pl.State == (int)SoeEntityState.Active)
                    select pl).Any();
        }

        public ActionResult SavePayrollLevel(PayrollLevelDTO payrollLevelInput, int actorCompanyId)
        {
            if (payrollLevelInput == null)
                return new ActionResult((int)ActionResultSave.EntityIsNull, "PayrollLevel");

            // Default result is successful
            ActionResult result = new ActionResult();

            int payrollLevelId = payrollLevelInput.PayrollLevelId;
            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    entities.Connection.Open();

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_DEFAULT))
                    {
                        #region PayrollLevel

                        // Get existing
                        PayrollLevel payrollLevel = GetPayrollLevel(entities, actorCompanyId, payrollLevelId);
                        if (payrollLevel == null)
                        {
                            #region Add
                            payrollLevel = new PayrollLevel()
                            {
                                ActorCompanyId = actorCompanyId,
                            };
                            SetCreatedProperties(payrollLevel);
                            entities.PayrollLevel.AddObject(payrollLevel);

                            #endregion
                        }
                        else
                        {
                            #region Update

                            SetModifiedProperties(payrollLevel);

                            #endregion
                        }

                        payrollLevel.Code = payrollLevelInput.Code;
                        payrollLevel.Name = payrollLevelInput.Name;
                        payrollLevel.Description = payrollLevelInput.Description;
                        payrollLevel.ExternalCode = payrollLevelInput.ExternalCode;
                        payrollLevel.State = (int)payrollLevelInput.State;

                        #endregion

                        result = SaveChanges(entities, transaction);
                        if (result.Success)
                        {
                            //Commit transaction
                            transaction.Complete();

                            payrollLevelId = payrollLevel.PayrollLevelId;
                        }
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result.Exception = ex;
                    result.IntegerValue = 0;
                }
                finally
                {

                    if (result.Success)
                    {
                        //Set success properties
                        result.IntegerValue = payrollLevelId;
                    }
                    else
                        base.LogTransactionFailed(this.ToString(), this.log);

                    entities.Connection.Close();
                }

                return result;
            }
        }

        public ActionResult DeletePayrollLevel(int payrollLevelId)
        {
            using (CompEntities entities = new CompEntities())
            {
                PayrollLevel payrollLevel = GetPayrollLevel(entities, base.ActorCompanyId, payrollLevelId);
                if (payrollLevel == null)
                    return new ActionResult((int)ActionResultDelete.EntityNotFound, "PayrollLevel");
                if (PayrollLevelInUse(payrollLevelId))
                    return new ActionResult((int)ActionResultDelete.EntityInUse, GetText(8934, 1, "Lönenivån används och kan därför ej tas bort"));

                return ChangeEntityState(entities, payrollLevel, SoeEntityState.Deleted, true);
            }
        }
        private bool PayrollLevelInUse(int payrollLevelId)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            if (entitiesReadOnly.PayrollGroupPriceType.Any(e => e.PayrollLevelId == payrollLevelId && e.State == (int)SoeEntityState.Active))
                return true;

            if (entitiesReadOnly.EmploymentPriceTypePeriod.Any(e => e.PayrollLevelId == payrollLevelId && e.State == (int)SoeEntityState.Active))
                return true;

            return false;
        }

        #endregion

        #region PayrollImport

        public List<PayrollImportHeadDTO> GetPayrollImportHeads(bool includeFile, bool includeEmployees, bool includeScheduleAndTransactionInfo, bool setStatuses)
        {

            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            List<PayrollImportHeadDTO> heads = (from h in entitiesReadOnly.PayrollImportHead
                                                where h.ActorCompanyId == ActorCompanyId &&
                                                h.State == (int)SoeEntityState.Active
                                                select new PayrollImportHeadDTO()
                                                {
                                                    PayrollImportHeadId = h.PayrollImportHeadId,
                                                    ActorCompanyId = h.ActorCompanyId,
                                                    DateFrom = h.DateFrom,
                                                    DateTo = h.DateTo,
                                                    PaymentDate = h.PaymentDate,
                                                    Type = (TermGroup_PayrollImportHeadType)h.Type,
                                                    FileType = (TermGroup_PayrollImportHeadFileType)h.FileType,
                                                    File = null,
                                                    Comment = h.Comment,
                                                    Created = h.Created,
                                                    CreatedBy = h.CreatedBy,
                                                    Modified = h.Modified,
                                                    ModifiedBy = h.ModifiedBy,
                                                    State = (SoeEntityState)h.State,
                                                    Checksum = h.Checksum
                                                }).ToList();

            if (heads.IsNullOrEmpty())
                return heads;

            heads.ForEach(f => f.TypeName = GetText((int)f.Type, (int)TermGroup.PayrollImportHeadType));
            heads.ForEach(f => f.FileTypeName = GetText((int)f.FileType, (int)TermGroup.PayrollImportHeadFileType));

            List<PayrollImportEmployee> importEmployees = new List<PayrollImportEmployee>();
            if (includeEmployees || setStatuses)
            {
                IQueryable<PayrollImportEmployee> query = entitiesReadOnly.PayrollImportEmployee;
                if (includeScheduleAndTransactionInfo)
                {
                    query = query.Include("PayrollImportEmployeeSchedule");
                    query = query.Include("PayrollImportEmployeeTransaction");
                }
                List<int> payrollImportHeadIds = heads.Select(s => s.PayrollImportHeadId).ToList();
                importEmployees = query.Where(w => w.State == (int)SoeEntityState.Active && payrollImportHeadIds.Contains(w.PayrollImportHeadId)).ToList();
            }

            List<GenericType> employeeStatus = GetTermGroupContent(TermGroup.PayrollImportEmployeeStatus);
            Dictionary<int, string> employeeInfos = includeEmployees ? GetEmployeeInfos(importEmployees) : new Dictionary<int, string>();

            foreach (PayrollImportHeadDTO importHeadDTO in heads)
            {
                bool hasUnprocessed = false, hasError = false, hasProcessed = false, hasPartlyProcessed = false;
                importHeadDTO.Name = $"{importHeadDTO.DateFrom.ToShortDateString()} - {importHeadDTO.DateTo.ToShortDateString()}, {GetText(12083, "Utbet")}: {(importHeadDTO.PaymentDate.HasValue ? importHeadDTO.PaymentDate.ToShortDateString() : string.Empty)}";

                if (includeEmployees)
                {
                    foreach (PayrollImportEmployee importEmployee in importEmployees.Where(e => e.PayrollImportHeadId == importHeadDTO.PayrollImportHeadId && e.State == (int)SoeEntityState.Active).ToList())
                    {
                        importEmployee.EmployeeInfo = employeeInfos.GetValue(importEmployee.EmployeeId);

                        PayrollImportEmployeeDTO importEmployeeDTO = importEmployee.ToDTO(includeScheduleAndTransactionInfo, includeScheduleAndTransactionInfo);
                        if (importEmployeeDTO != null)
                        {
                            if (setStatuses)
                                importEmployeeDTO.SetStatuses(employeeStatus, ref hasUnprocessed, ref hasError, ref hasProcessed, ref hasPartlyProcessed);
                            importHeadDTO.Employees.Add(importEmployeeDTO);
                        }

                    }
                }

                if (setStatuses)
                    SetPayrollImportHeadStatus(importHeadDTO, hasError, hasProcessed, hasPartlyProcessed, hasUnprocessed);
            }

            return heads;
        }

        public PayrollImportHeadDTO GetPayrollImportHead(int payrollImportHeadId, List<int> payrollImportEmployeeIds = null, bool loadSchedule = false, bool loadTransactions = false, bool loadTransactionAccounts = false, bool loadTransactionLinks = false, bool setStatuses = false)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollImportHead.NoTracking();
            PayrollImportHead importHead = (from h in entities.PayrollImportHead
                                                .Include("PayrollImportEmployee")
                                            where h.ActorCompanyId == ActorCompanyId &&
                                            h.PayrollImportHeadId == payrollImportHeadId &&
                                            h.State == (int)SoeEntityState.Active
                                            select h).FirstOrDefault();

            PayrollImportHeadDTO importHeadDTO = importHead?.ToDTO(false, false, GetText(12083, "Utbet"));
            if (importHeadDTO == null)
                return null;

            bool hasUnprocessed = false, hasError = false, hasProcessed = false, hasPartlyProcessed = false;

            List<PayrollImportEmployee> importEmployees = importHead.PayrollImportEmployee.Where(e => e.State == (int)SoeEntityState.Active).ToList();
            if (!payrollImportEmployeeIds.IsNullOrEmpty())
                importEmployees = importEmployees.Where(e => payrollImportEmployeeIds.Contains(e.PayrollImportEmployeeId)).ToList();

            if (importEmployees.Any())
            {
                importHeadDTO.Employees = new List<PayrollImportEmployeeDTO>();

                List<GenericType> employeeStatus = GetTermGroupContent(TermGroup.PayrollImportEmployeeStatus);
                List<Account> accounts = loadTransactions ? AccountManager.GetAccountsByCompany(base.ActorCompanyId, loadAccountDim: true) : null;
                Dictionary<int, string> employeeInfos = GetEmployeeInfos(importEmployees);

                foreach (PayrollImportEmployee importEmployee in importEmployees)
                {
                    importEmployee.EmployeeInfo = employeeInfos.GetValue(importEmployee.EmployeeId);

                    List<PayrollImportEmployeeSchedule> importEmployeeSchedules = loadSchedule ? GetPayrollImportEmployeeSchedules(importEmployee.PayrollImportEmployeeId, true) : null;
                    List<PayrollImportEmployeeTransaction> importEmployeeTransactions = loadTransactions ? GetPayrollImportEmployeeTransactions(importEmployee.PayrollImportEmployeeId, true, loadTransactionAccounts, loadTransactionLinks) : null;

                    PayrollImportEmployeeDTO importEmployeeDTO = importEmployee.ToDTO(loadSchedule, loadTransactions, accounts, importEmployeeSchedules, importEmployeeTransactions);
                    if (importEmployeeDTO != null)
                    {
                        if (setStatuses)
                            importEmployeeDTO.SetStatuses(employeeStatus, ref hasUnprocessed, ref hasError, ref hasProcessed, ref hasPartlyProcessed);
                        importHeadDTO.Employees.Add(importEmployeeDTO);
                    }
                }
            }

            if (setStatuses)
                SetPayrollImportHeadStatus(importHeadDTO, hasError, hasProcessed, hasPartlyProcessed, hasUnprocessed);

            return importHeadDTO;
        }

        public List<PayrollImportEmployeeDTO> GetPayrollImportEmployees(int payrollImportHeadId, List<int> employeeIds = null, bool includeSchedule = false, bool includeTransactions = false, bool includeTransactionAccounts = false, bool includeLinks = false, bool setStatuses = false)
        {
            return GetPayrollImportHead(payrollImportHeadId, employeeIds, includeSchedule, includeTransactions, includeTransactionAccounts, includeLinks, setStatuses)?.Employees ?? new List<PayrollImportEmployeeDTO>();
        }

        public List<PayrollImportEmployeeSchedule> GetPayrollImportEmployeeSchedules(int payrollImportEmployeeId, bool setStatuses)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollImportEmployeeSchedule.NoTracking();
            List<PayrollImportEmployeeSchedule> importSchedules = (from p in entities.PayrollImportEmployeeSchedule
                                                                   where p.PayrollImportEmployeeId == payrollImportEmployeeId &&
                                                                   p.State == (int)SoeEntityState.Active
                                                                   orderby p.Date, p.StartTime
                                                                   select p).ToList();

            if (setStatuses)
            {
                foreach (PayrollImportEmployeeSchedule importSchedule in importSchedules)
                {
                    importSchedule.StatusName = GetText(importSchedule.Status, (int)TermGroup.PayrollImportEmployeeScheduleStatus);
                }
            }

            return importSchedules;
        }

        public List<PayrollImportEmployeeTransaction> GetPayrollImportEmployeeTransactions(int payrollImportEmployeeId, bool setStatuses, bool loadAccountInternals = false, bool loadAccountInternalsExtended = false, bool loadLinks = false)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.PayrollImportEmployeeTransaction.NoTracking();
            IQueryable<PayrollImportEmployeeTransaction> query = entitiesReadOnly.PayrollImportEmployeeTransaction;
            query = query.Include("PayrollImportEmployee");
            if (loadAccountInternalsExtended)
            {
                query = query.Include("AccountStd.Account.AccountDim");
                query = query.Include("PayrollImportEmployeeTransactionAccountInternal.AccountInternal.Account.AccountDim");
            }
            else if (loadAccountInternals)
                query = query.Include("PayrollImportEmployeeTransactionAccountInternal");
            if (loadLinks)
                query = query.Include("PayrollImportEmployeeTransactionLink");

            List<PayrollImportEmployeeTransaction> importTransactions = (from p in query
                                                                         where p.PayrollImportEmployeeId == payrollImportEmployeeId &&
                                                                         p.State == (int)SoeEntityState.Active
                                                                         orderby p.Date, p.StartTime
                                                                         select p).ToList();

            if (setStatuses)
            {
                foreach (PayrollImportEmployeeTransaction importTransaction in importTransactions)
                {
                    importTransaction.TypeName = GetText(importTransaction.Type, (int)TermGroup.PayrollImportEmployeeTransactionType);
                    importTransaction.StatusName = GetText(importTransaction.Status, (int)TermGroup.PayrollImportEmployeeTransactionStatus);
                }
            }

            return importTransactions;
        }

        public List<PayrollImportEmployeeTransaction> GetPayrollImportEmployeeTransactionsForEmployee(CompEntities entities, int employeeId, DateTime fromDate, DateTime toDate)
        {
            return (from p in entities.PayrollImportEmployeeTransaction
                        .Include("PayrollImportEmployee")
                    where p.PayrollImportEmployee.EmployeeId == employeeId &&
                    p.PayrollImportEmployee.State == (int)SoeEntityState.Active &&
                    p.PayrollImportEmployee.PayrollImportHead.ActorCompanyId == ActorCompanyId &&
                    p.PayrollImportEmployee.PayrollImportHead.State == (int)SoeEntityState.Active &&
                    p.PayrollImportEmployee.EmployeeId == employeeId &&
                    p.Date >= fromDate && p.Date <= toDate &&
                    p.State == (int)SoeEntityState.Active
                    orderby p.Date, p.StartTime
                    select p).ToList();
        }

        public List<PayrollImportEmployeeTransactionLinkDTO> GetPayrollImportEmployeeTransactionLinks(int payrollImportEmployeeTransactionId, int actorCompanyId)
        {

            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.PayrollImportEmployeeTransactionLink.NoTracking();
            List<PayrollImportEmployeeTransactionLink> links = (from l in entitiesReadOnly.PayrollImportEmployeeTransactionLink
                                                                where l.PayrollImportEmployeeTransaction.PayrollImportEmployee.PayrollImportHead.ActorCompanyId == actorCompanyId &&
                                                                l.PayrollImportEmployeeTransactionId == payrollImportEmployeeTransactionId
                                                                select l).ToList();

            List<PayrollImportEmployeeTransactionLinkDTO> result = new List<PayrollImportEmployeeTransactionLinkDTO>();
            entitiesReadOnly.TimePayrollTransaction.NoTracking();
            entitiesReadOnly.TimeCodeTransaction.NoTracking();

            foreach (PayrollImportEmployeeTransactionLink link in links)
            {
                List<TimePayrollTransaction> transactions = new List<TimePayrollTransaction>();
                if (link.TimePayrollTransactionId.HasValue)
                {
                    TimePayrollTransaction trans = (from t in entitiesReadOnly.TimePayrollTransaction
                                                        .Include("PayrollProduct")
                                                        .Include("AttestState")
                                                        .Include("TimeCodeTransaction")
                                                    where t.TimePayrollTransactionId == link.TimePayrollTransactionId.Value
                                                    select t).FirstOrDefault();
                    if (trans != null)
                        transactions.Add(trans);
                }
                else if (link.TimeBlockId.HasValue)
                {
                    transactions.AddRange((from t in entitiesReadOnly.TimePayrollTransaction
                                            .Include("PayrollProduct")
                                            .Include("AttestState")
                                            .Include("TimeCodeTransaction")
                                           where t.TimeBlockId == link.TimeBlockId.Value
                                           select t).ToList());
                }

                foreach (TimePayrollTransaction trans in transactions)
                {
                    PayrollImportEmployeeTransactionLinkDTO dto = link.ToDTO();
                    dto.ProductNr = trans.PayrollProduct.Number;
                    dto.ProductName = trans.PayrollProduct.Name;
                    dto.Quantity = trans.Quantity;
                    dto.AttestStateColor = trans.AttestState.Color;
                    dto.AttestStateName = trans.AttestState.Name;

                    if (trans.TimeCodeTransaction != null)
                    {
                        dto.Start = trans.TimeCodeTransaction.Start;
                        dto.Stop = trans.TimeCodeTransaction.Stop;
                    }

                    result.Add(dto);
                }
            }

            return result;
        }

        public Dictionary<int, List<DateTime>> GetPayrollImportUnhandledOrError(CompEntities entities, int actorCompanyId, List<int> employeeIds, DateTime fromDate, DateTime toDate, List<PayrollImportEmployeeTransaction> importEmployeeTransactions = null)
        {
            List<PayrollImportEmployeeTransaction> payrollImportEmployees;
            if (importEmployeeTransactions != null && employeeIds.Any())
            {
                payrollImportEmployees = importEmployeeTransactions
                    .Where(w => w.State == (int)SoeEntityState.Active &&
                           w.Status != (int)TermGroup_PayrollImportEmployeeTransactionStatus.Processed &&
                           w.Date >= fromDate &&
                           w.Date <= toDate &&
                           employeeIds.Contains(w.PayrollImportEmployee.EmployeeId))
                    .ToList();
            }
            else
            {
                payrollImportEmployees = entities.PayrollImportEmployeeTransaction
                    .Include("PayrollImportEmployee")
                    .Where(w =>
                           w.PayrollImportEmployee.PayrollImportHead.ActorCompanyId == actorCompanyId &&
                           w.PayrollImportEmployee.PayrollImportHead.State == (int)SoeEntityState.Active &&
                           w.State == (int)SoeEntityState.Active &&
                           w.Status != (int)TermGroup_PayrollImportEmployeeTransactionStatus.Processed &&
                           w.Date >= fromDate &&
                           w.Date <= toDate &&
                           employeeIds.Contains(w.PayrollImportEmployee.EmployeeId))
                    .ToList();
            }

            if (payrollImportEmployees.IsNullOrEmpty())
                return new Dictionary<int, List<DateTime>>();
            return payrollImportEmployees.GroupBy(g => g.PayrollImportEmployee.EmployeeId).ToDictionary(k => k.Key, v => v.Select(s => s.Date).Distinct().ToList());
        }

        private Dictionary<int, string> GetEmployeeInfos(List<PayrollImportEmployee> importEmployees)
        {
            List<int> employeeIds = importEmployees?.Select(i => i.EmployeeId).Distinct().ToList() ?? new List<int>();
            if (employeeIds.IsNullOrEmpty())
                return new Dictionary<int, string>();

            return EmployeeManager.GetAllEmployeesByIds(base.ActorCompanyId, employeeIds).ToDictionary(k => k.EmployeeId, v => v.NumberAndName);
        }

        private void SetPayrollImportHeadStatus(PayrollImportHeadDTO head, bool hasError, bool hasProcessed, bool hasPartlyProcessed, bool hasUnprocessed)
        {
            if (head == null)
                return;

            bool isPartlyProcessed = hasPartlyProcessed || (hasProcessed && hasUnprocessed);
            bool isProcessed = hasProcessed && !hasUnprocessed;

            if (hasError)
                head.Status = TermGroup_PayrollImportHeadStatus.Error;
            else if (isPartlyProcessed)
                head.Status = TermGroup_PayrollImportHeadStatus.PartlyProcessed;
            else if (isProcessed)
                head.Status = TermGroup_PayrollImportHeadStatus.Processed;
            else
                head.Status = TermGroup_PayrollImportHeadStatus.Unprocessed;

            head.StatusName = GetText((int)head.Status, (int)TermGroup.PayrollImportHeadStatus);
        }

        public ActionResult ImportPayrollImportHead(int actorCompanyId, DateTime paymentDate, byte[] file, string fileName, TermGroup_PayrollImportHeadFileType fileType, string comment, bool skipMissingEmployeeValidation = false)
        {
            using (CompEntities entities = new CompEntities())
            {
                string checksum = CryptographyUtility.GetMd5Hash(Encoding.Default.GetString(file));
                if (entities.PayrollImportHead.Any(a => a.ActorCompanyId == actorCompanyId && a.State == (int)SoeEntityState.Active && a.Checksum == checksum))
                    return new ActionResult(GetText(12105, "Importen misslyckades eftersom filen redan har importerats"));

                List<EmployeeDTO> employees = null;
                IPayrollImportable model = null;
                string informationMessage = "";

                switch (fileType)
                {
                    case TermGroup_PayrollImportHeadFileType.SoftOneClassic:
                        SoftOneLonClassic classic = new SoftOneLonClassic();
                        if (TryGetEmployeesForImport(classic.GetEmployeeNrs(file)))
                            model = classic;
                        break;
                    case TermGroup_PayrollImportHeadFileType.PaXml:
                        PaXml2 paXml2 = new PaXml2(file);
                        if (TryGetEmployeesForImport(paXml2.GetEmployeeNrs()))
                            model = paXml2;
                        break;
                    default:
                        break;
                }

                ActionResult result = model != null ? CreatePayrollImportHead() : null;
                return result ?? new ActionResult("No matching fileType found");

                bool TryGetEmployeesForImport(List<string> employeeNbrs)
                {
                    List<int> employeeIds = EmployeeManager.GetAllEmployeeIdsByEmployeeNr(entities, actorCompanyId, employeeNbrs);
                    List<Employee> employeesForNbrs = EmployeeManager.GetEmployeesForUsersAttestRoles(entities, out _, actorCompanyId, this.UserId, this.RoleId, employeeFilter: employeeIds, loadEmployeeVactionSE: true);
                    if (employeesForNbrs.Count != employeeNbrs.Count && IsAnyEmployeeMissing(employeesForNbrs, employeeNbrs, out List<string> missingEmployeeNbrs))
                    {
                        string missingEmployeeNbrsMessage = StringUtility.GetCommaSeparatedString(missingEmployeeNbrs, true, true);
                        if (skipMissingEmployeeValidation)
                        {
                            informationMessage = GetText(91925, "Alla anställda lästes inte in. Saknade anställningsnummer:") + " " + missingEmployeeNbrsMessage;
                        }
                        else
                        {
                            result = new ActionResult(GetText(12101, "Importen misslyckades eftersom alla anställda inte kunde hittas. Saknade anställningsnummer:") + " " + missingEmployeeNbrsMessage)
                            {
                                CanUserOverride = true
                            };
                            return false;
                        }
                    }

                    List<EmployeeGroup> employeeGroups = GetEmployeeGroupsFromCache(entities, CacheConfig.Company(actorCompanyId));
                    List<PayrollGroup> payrollGroups = GetPayrollGroupsFromCache(entities, CacheConfig.Company(actorCompanyId));
                    List<VacationGroup> vacationGroups = GetVacationGroupsFromCache(entities, CacheConfig.Company(actorCompanyId));
                    List<PayrollPriceType> payrollPriceTypes = GetPayrollPriceTypesFromCache(entities, CacheConfig.Company(actorCompanyId));
                    employees = employeesForNbrs.ToDTOs(employeeGroups: employeeGroups, payrollGroups: payrollGroups, vacationGroups: vacationGroups, payrollPriceTypes: payrollPriceTypes).ToList();
                    return true;
                }
                bool IsAnyEmployeeMissing(List<Employee> employeesForNbrs, List<string> employeeNbrs, out List<string> missingEmployeeNbrs)
                {
                    missingEmployeeNbrs = new List<string>();
                    if (!employeeNbrs.IsNullOrEmpty())
                    {
                        foreach (string employeeNr in employeeNbrs)
                        {
                            if (!employeesForNbrs?.Any(a => a.EmployeeNr == employeeNr) ?? false)
                                missingEmployeeNbrs.Add(employeeNr);
                        }
                    }
                    return missingEmployeeNbrs.Any();
                }
                ActionResult CreatePayrollImportHead()
                {
                    ActionResult importResult = null;
                    List<AccountDimDTO> accountDims = AccountManager.GetAccountDimsByCompany(entities, actorCompanyId, loadAccounts: true, loadInternalAccounts: true).ToDTOs(includeAccounts: true, loadInternalAccounts: true);
                    List<PayrollProductGridDTO> payrollProducts = ProductManager.GetPayrollProducts(entities, actorCompanyId, null).ToGridDTOs().ToList();
                    List<TimeDeviationCauseDTO> timeDeviationCauses = TimeDeviationCauseManager.GetTimeDeviationCauses(entities, actorCompanyId).ToDTOs().ToList();
                    PayrollImportHeadDTO importHead = model.ParseToPayrollImportHead(actorCompanyId, file, paymentDate, employees, accountDims, payrollProducts, timeDeviationCauses);
                    if (importHead != null)
                    {
                        if (string.IsNullOrEmpty(importHead.ErrorMessage))
                        {
                            importHead.Type = TermGroup_PayrollImportHeadType.File;
                            importHead.FileType = fileType;
                            importHead.Comment = fileName + (string.IsNullOrEmpty(comment) ? "" : " " + comment);
                            importHead.Checksum = checksum;

                            importResult = SavePayrollImportHead(entities, importHead);
                            if (importResult.Success)
                                importResult.ErrorMessage = informationMessage;
                        }
                        else
                            importResult = new ActionResult(importHead.ErrorMessage);
                    }
                    return importResult;
                }
            }
        }

        public ActionResult SavePayrollImportHead(CompEntities entities, PayrollImportHeadDTO inputImportHead)
        {
            ActionResult result = new ActionResult();
            DateTime batchTimeStamp = DateTime.Now;
            DateTime dateFrom = inputImportHead.DateFrom;
            DateTime dateTo = inputImportHead.DateTo;
            bool isNew = false;

            #region PayrollImportHead

            PayrollImportHead importHead = entities.PayrollImportHead.FirstOrDefault(f => f.PayrollImportHeadId == inputImportHead.PayrollImportHeadId);
            if (importHead == null)
            {
                isNew = true;
                importHead = new PayrollImportHead()
                {
                    ActorCompanyId = ActorCompanyId,
                };
                SetCreatedProperties(importHead, created: batchTimeStamp);
                entities.PayrollImportHead.AddObject(importHead);
            }
            else
            {
                SetModifiedProperties(importHead, modified: batchTimeStamp);
                importHead.PayrollImportEmployee.Load();
            }

            importHead.Type = (int)inputImportHead.Type;
            importHead.File = inputImportHead.File;
            importHead.FileType = (int)inputImportHead.FileType;
            importHead.PaymentDate = inputImportHead.PaymentDate;
            importHead.Comment = inputImportHead.Comment;
            importHead.Checksum = inputImportHead.Checksum;

            #endregion

            List<PayrollImportEmployee> importEmployees = importHead?.PayrollImportEmployee?.Where(w => w.State == (int)SoeEntityState.Active).ToList() ?? new List<PayrollImportEmployee>();
            foreach (PayrollImportEmployeeDTO inputImportEmployee in inputImportHead.Employees)
            {
                #region PayrollImportEmployee

                PayrollImportEmployee importEmployee = inputImportEmployee.PayrollImportEmployeeId != 0 ? importEmployees.FirstOrDefault(f => f.PayrollImportEmployeeId == inputImportEmployee.PayrollImportEmployeeId) : null;
                if (importEmployee == null)
                {
                    importEmployee = new PayrollImportEmployee()
                    {
                        EmployeeId = inputImportEmployee.EmployeeId,
                    };
                    SetCreatedProperties(importEmployee, created: batchTimeStamp);
                    importEmployees.Add(importEmployee);
                }
                else
                {
                    SetModifiedProperties(importEmployee, modified: batchTimeStamp);
                    if (!importEmployee.PayrollImportEmployeeSchedule.IsLoaded)
                        importEmployee.PayrollImportEmployeeSchedule.Load();
                    if (!importEmployee.PayrollImportEmployeeTransaction.IsLoaded)
                        importEmployee.PayrollImportEmployeeTransaction.Load();
                }

                #endregion

                #region PayrollImportEmployeeSchedule

                List<PayrollImportEmployeeSchedule> importEmployeeSchedules = importEmployee.PayrollImportEmployeeSchedule?.Where(w => w.State == (int)SoeEntityState.Active).ToList() ?? new List<PayrollImportEmployeeSchedule>();
                if (inputImportEmployee.Schedule != null)
                {
                    foreach (PayrollImportEmployeeScheduleDTO importEmployeeSchedule in inputImportEmployee.Schedule)
                    {
                        SavePayrollImportEmployeeSchedule(entities, importEmployeeSchedule, batchTimeStamp, importEmployeeSchedules, importEmployee, false);
                    }
                }

                #endregion

                #region PayrollImportEmployeeTransaction

                List<PayrollImportEmployeeTransaction> importEmployeeTransactions = importEmployee.PayrollImportEmployeeTransaction?.Where(w => w.State == (int)SoeEntityState.Active).ToList() ?? new List<PayrollImportEmployeeTransaction>();
                if (inputImportEmployee.Transactions != null)
                {
                    foreach (PayrollImportEmployeeTransactionDTO importEmployeeTransaction in inputImportEmployee.Transactions)
                    {
                        SavePayrollImportEmployeeTransaction(entities, importEmployeeTransaction, batchTimeStamp, importEmployeeTransactions, importEmployee, false);
                    }
                }

                #endregion
            }

            importHead.PayrollImportEmployee.AddRange(importEmployees);

            if (isNew)
            {
                importHead.DateFrom = dateFrom != DateTime.MinValue ? dateFrom : DateTime.Today;
                importHead.DateTo = dateTo != DateTime.MinValue ? dateTo : DateTime.Today;
            }

            return SaveChanges(entities);
        }

        public ActionResult SavePayrollImportEmployeeSchedule(PayrollImportEmployeeScheduleDTO payrollImportEmployeeScheduleDTO)
        {
            using (CompEntities entities = new CompEntities())
            {
                return SavePayrollImportEmployeeSchedule(entities, payrollImportEmployeeScheduleDTO, DateTime.Now);
            }
        }

        public ActionResult SavePayrollImportEmployeeSchedule(CompEntities entities, PayrollImportEmployeeScheduleDTO payrollImportEmployeeScheduleDTO, DateTime batchTimeStamp, List<PayrollImportEmployeeSchedule> employeeSchedules = null, PayrollImportEmployee payrollImportEmployee = null, bool save = true)
        {
            PayrollImportEmployeeSchedule payrollImportEmployeeSchedule;

            if (employeeSchedules != null)
                payrollImportEmployeeSchedule = employeeSchedules.FirstOrDefault(f => f.PayrollImportEmployeeScheduleId == payrollImportEmployeeScheduleDTO.PayrollImportEmployeeScheduleId);
            else
                payrollImportEmployeeSchedule = entities.PayrollImportEmployeeSchedule.FirstOrDefault(f => f.PayrollImportEmployeeScheduleId == payrollImportEmployeeScheduleDTO.PayrollImportEmployeeScheduleId);

            if (payrollImportEmployeeSchedule != null)
            {
                if (payrollImportEmployeeSchedule.StartTime == payrollImportEmployeeScheduleDTO.StartTime && payrollImportEmployeeSchedule.StopTime == payrollImportEmployeeScheduleDTO.StopTime && payrollImportEmployeeSchedule.IsBreak == payrollImportEmployeeScheduleDTO.IsBreak && payrollImportEmployeeSchedule.Quantity == payrollImportEmployeeScheduleDTO.Quantity)
                    return new ActionResult();

                ChangeEntityState(payrollImportEmployeeSchedule, SoeEntityState.Deleted, modified: batchTimeStamp);
            }

            PayrollImportEmployeeSchedule newScheduleRow = new PayrollImportEmployeeSchedule()
            {
                PayrollImportEmployeeId = payrollImportEmployeeScheduleDTO.PayrollImportEmployeeId,
                Date = payrollImportEmployeeScheduleDTO.Date,
                StartTime = payrollImportEmployeeScheduleDTO.StartTime,
                StopTime = payrollImportEmployeeScheduleDTO.StopTime,
                Quantity = payrollImportEmployeeScheduleDTO.Quantity,
                IsBreak = payrollImportEmployeeScheduleDTO.IsBreak
            };

            if (payrollImportEmployee != null)
                newScheduleRow.PayrollImportEmployee = payrollImportEmployee;

            SetCreatedProperties(newScheduleRow, created: batchTimeStamp);
            entities.PayrollImportEmployeeSchedule.AddObject(newScheduleRow);

            if (save)
                return SaveChanges(entities);
            else
                return new ActionResult();
        }

        public ActionResult DeletePayrollImportEmployeeSchedule(int payrollImportEmployeeScheduleId)
        {
            using (CompEntities entities = new CompEntities())
            {
                PayrollImportEmployeeSchedule payrollImportEmployeeSchedule = entities.PayrollImportEmployeeSchedule.FirstOrDefault(f => f.State != (int)SoeEntityState.Deleted && f.PayrollImportEmployeeScheduleId == payrollImportEmployeeScheduleId);

                if (payrollImportEmployeeSchedule == null)
                    return new ActionResult((int)ActionResultDelete.EntityNotFound, "payrollImportEmployeeTransaction");

                ChangeEntityState(payrollImportEmployeeSchedule, SoeEntityState.Deleted);
                return SaveChanges(entities);
            }
        }

        public ActionResult SavePayrollImportEmployeeTransaction(PayrollImportEmployeeTransactionDTO payrollImportEmployeeTransactionDTO)
        {
            using (CompEntities entities = new CompEntities())
            {
                return SavePayrollImportEmployeeTransaction(entities, payrollImportEmployeeTransactionDTO, DateTime.Now);
            }
        }

        public ActionResult SavePayrollImportEmployeeTransaction(CompEntities entities, PayrollImportEmployeeTransactionDTO payrollImportEmployeeTransactionDTO, DateTime batchTimeStamp, List<PayrollImportEmployeeTransaction> employeeTransactions = null, PayrollImportEmployee payrollImportEmployee = null, bool save = true)
        {
            PayrollImportEmployeeTransaction payrollImportEmployeeTransaction;

            if (employeeTransactions != null)
                payrollImportEmployeeTransaction = employeeTransactions.FirstOrDefault(f => f.PayrollImportEmployeeTransactionId == payrollImportEmployeeTransactionDTO.PayrollImportEmployeeTransactionId);
            else
                payrollImportEmployeeTransaction = entities.PayrollImportEmployeeTransaction.FirstOrDefault(f => f.PayrollImportEmployeeTransactionId == payrollImportEmployeeTransactionDTO.PayrollImportEmployeeTransactionId);


            if (payrollImportEmployeeTransaction != null)
            {
                if (payrollImportEmployeeTransaction.Date == payrollImportEmployeeTransactionDTO.Date &&
                    payrollImportEmployeeTransaction.StartTime == payrollImportEmployeeTransactionDTO.StartTime &&
                    payrollImportEmployeeTransaction.StopTime == payrollImportEmployeeTransactionDTO.StopTime &&
                    payrollImportEmployeeTransaction.Amount == payrollImportEmployeeTransactionDTO.Amount &&
                    payrollImportEmployeeTransaction.Quantity == payrollImportEmployeeTransactionDTO.Quantity &&
                    payrollImportEmployeeTransaction.Code == payrollImportEmployeeTransactionDTO.Code &&
                    payrollImportEmployeeTransaction.Note == payrollImportEmployeeTransactionDTO.Note &&
                    payrollImportEmployeeTransaction.ErrorMessage == payrollImportEmployeeTransactionDTO.ErrorMessage &&
                    payrollImportEmployeeTransaction.PayrollProductId == payrollImportEmployeeTransactionDTO.PayrollProductId &&
                    payrollImportEmployeeTransaction.TimeDeviationCauseId == payrollImportEmployeeTransactionDTO.TimeDeviationCauseId &&
                    payrollImportEmployeeTransaction.TimeCodeAdditionDeductionId == payrollImportEmployeeTransactionDTO.TimeCodeAdditionDeductionId &&
                    payrollImportEmployeeTransaction.AccountStdId == payrollImportEmployeeTransactionDTO.AccountStdId)
                {
                    // Nothing changed on transaction, also check account internals
                    List<int> existingAccountIds = !payrollImportEmployeeTransaction.PayrollImportEmployeeTransactionAccountInternal.IsNullOrEmpty() ? payrollImportEmployeeTransaction.PayrollImportEmployeeTransactionAccountInternal.Where(a => a.AccountId.HasValue).Select(a => a.AccountId.Value).ToList() : new List<int>();
                    List<int> newAccountIds = !payrollImportEmployeeTransactionDTO.AccountInternals.IsNullOrEmpty() ? payrollImportEmployeeTransactionDTO.AccountInternals.Where(a => a.AccountId.HasValue).Select(a => a.AccountId.Value).ToList() : new List<int>();
                    if (existingAccountIds.Count == newAccountIds.Count && existingAccountIds.Intersect(newAccountIds).Count() == existingAccountIds.Count)
                        return new ActionResult();
                }

                SetModifiedProperties(payrollImportEmployeeTransaction, modified: batchTimeStamp);
                payrollImportEmployeeTransaction.State = (int)SoeEntityState.Deleted;
            }

            PayrollImportEmployeeTransaction newTransaction = new PayrollImportEmployeeTransaction()
            {
                PayrollImportEmployeeId = payrollImportEmployeeTransactionDTO.PayrollImportEmployeeId,
                Date = payrollImportEmployeeTransactionDTO.Date,
                StartTime = payrollImportEmployeeTransactionDTO.StartTime,
                StopTime = payrollImportEmployeeTransactionDTO.StopTime,
                Amount = payrollImportEmployeeTransactionDTO.Amount,
                Quantity = payrollImportEmployeeTransactionDTO.Quantity,
                Code = StringUtility.EmptyToNull(payrollImportEmployeeTransactionDTO.Code),
                Note = payrollImportEmployeeTransactionDTO.Note,
                ErrorMessage = payrollImportEmployeeTransactionDTO.ErrorMessage,
                PayrollProductId = payrollImportEmployeeTransactionDTO.PayrollProductId,
                TimeDeviationCauseId = payrollImportEmployeeTransactionDTO.TimeDeviationCauseId,
                State = (int)payrollImportEmployeeTransactionDTO.State,
                TimeCodeAdditionDeductionId = payrollImportEmployeeTransactionDTO.TimeCodeAdditionDeductionId,
                Type = (int)payrollImportEmployeeTransactionDTO.Type,
                AccountStdId = payrollImportEmployeeTransactionDTO.AccountStdId.HasValue && payrollImportEmployeeTransactionDTO.AccountStdId.Value != 0 ? payrollImportEmployeeTransactionDTO.AccountStdId : (int?)null,
                AccountCode = payrollImportEmployeeTransactionDTO.AccountCode,
            };
            SetCreatedProperties(newTransaction, created: batchTimeStamp);

            if (!payrollImportEmployeeTransactionDTO.AccountInternals.IsNullOrEmpty())
            {
                foreach (var ai in payrollImportEmployeeTransactionDTO.AccountInternals)
                {
                    if ((ai.AccountSIEDimNr == 0) && ai.AccountDimNr.HasValue)
                    {
                        AccountDim dim = AccountManager.GetAccountDimByNr(ai.AccountDimNr.Value, ActorCompanyId, true);
                        if (dim != null && dim.SysSieDimNr.HasValue)
                            ai.AccountSIEDimNr = dim.SysSieDimNr.Value;
                    }

                    newTransaction.PayrollImportEmployeeTransactionAccountInternal.Add(new PayrollImportEmployeeTransactionAccountInternal()
                    {
                        AccountSIEDimNr = ai.AccountSIEDimNr,
                        AccountId = ai.AccountId.HasValue && ai.AccountId.Value != 0 ? ai.AccountId : (int?)null,
                        AccountCode = ai.AccountCode
                    });
                }
            }

            entities.PayrollImportEmployeeTransaction.AddObject(newTransaction);

            if (payrollImportEmployee != null)
                newTransaction.PayrollImportEmployee = payrollImportEmployee;

            if (save)
                return SaveChanges(entities);
            else
                return new ActionResult();
        }

        public ActionResult SetPayrollImportEmployeeTransactionAsProcessed(int payrollImportEmployeeTransactionId, int actorCompanyId)
        {
            using (CompEntities entities = new CompEntities())
            {
                PayrollImportEmployeeTransaction trans = (from t in entities.PayrollImportEmployeeTransaction
                                                          where t.PayrollImportEmployee.PayrollImportHead.ActorCompanyId == actorCompanyId &&
                                                          t.PayrollImportEmployeeTransactionId == payrollImportEmployeeTransactionId
                                                          select t).FirstOrDefault();

                if (trans == null)
                    return new ActionResult((int)ActionResultSave.EntityNotFound, "PayrollImportEmployeeTransaction");

                trans.Status = (int)TermGroup_PayrollImportEmployeeTransactionStatus.Processed;
                return SaveChanges(entities);
            }
        }

        public ActionResult DeletePayrollImportEmployeeTransaction(int payrollImportEmployeeTransactionId)
        {
            using (CompEntities entities = new CompEntities())
            {
                AttestState initialAttestState = AttestManager.GetInitialAttestState(base.ActorCompanyId, TermGroup_AttestEntity.PayrollTime);
                if (initialAttestState == null)
                    return new ActionResult((int)ActionResultDelete.EntityNotFound, "AttestState");

                PayrollImportEmployeeTransaction payrollImportEmployeeTransaction = entities.PayrollImportEmployeeTransaction.Include("PayrollImportEmployeeTransactionLink").FirstOrDefault(f => f.State != (int)SoeEntityState.Deleted && f.PayrollImportEmployeeTransactionId == payrollImportEmployeeTransactionId);
                if (payrollImportEmployeeTransaction == null)
                    return new ActionResult((int)ActionResultDelete.EntityNotFound, "payrollImportEmployeeTransaction");

                List<int> timepayrollTransactionIds = payrollImportEmployeeTransaction.PayrollImportEmployeeTransactionLink.Where(w => w.TimePayrollTransactionId.HasValue).Select(s => s.TimePayrollTransactionId.Value).ToList();
                if (timepayrollTransactionIds.Any() && entities.TimePayrollTransaction.Where(f => timepayrollTransactionIds.Contains(f.TimePayrollTransactionId) && f.ActorCompanyId == ActorCompanyId && f.State == (int)SoeEntityState.Active).Any(a => a.AttestStateId != initialAttestState.AttestStateId))
                    return new ActionResult(GetText(12100, "Transaktionen har kopplade attesterade tider"));

                List<int> timeBlockIds = payrollImportEmployeeTransaction.PayrollImportEmployeeTransactionLink.Where(w => w.TimeBlockId.HasValue).Select(s => s.TimeBlockId.Value).ToList();
                if (timeBlockIds.Any() && entities.TimePayrollTransaction.Where(f => f.TimeBlockId.HasValue && timeBlockIds.Contains(f.TimeBlockId.Value) && f.ActorCompanyId == ActorCompanyId && f.State == (int)SoeEntityState.Active).Any(a => a.AttestStateId != initialAttestState.AttestStateId))
                    return new ActionResult(GetText(12100, "Transaktionen har kopplade attesterade tider"));

                payrollImportEmployeeTransaction.State = (int)SoeEntityState.Deleted;
                SetDeletedProperties(payrollImportEmployeeTransaction);

                return SaveChanges(entities);
            }
        }

        #endregion

        #region PayrollWarnings
        public List<PayrollControlFunctionOutcome> GetPayrollWarningsForGroup(int actorCompanyId, List<int> employeeIds, int timePeriodId, bool showDeleted = false, bool loadOutcomes = false, bool setTerms = false)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.PayrollControlFunctionOutcome.MergeOption = MergeOption.NoTracking;
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetPayrollWarningsForGroup(entities, actorCompanyId, employeeIds, timePeriodId, showDeleted, loadOutcomes, setTerms);
        }
        public List<PayrollControlFunctionOutcome> GetPayrollWarningsForGroup(CompEntities entities, int actorCompanyId, List<int> employeeIds, int timePeriodId, bool showDeleted = false, bool loadOutcomes = false, bool setTerms = false)
        {
            IQueryable<PayrollControlFunctionOutcome> query = entities.PayrollControlFunctionOutcome;
            if (loadOutcomes)
                query = query.Include("PayrollControlFunctionOutcomeChange");

            Dictionary<int, EmployeeTimePeriod> employeeTimePeriodsDict = TimePeriodManager.GetEmployeeTimePeriodsForEmployees(entities, employeeIds, actorCompanyId, timePeriodId).ToDictionary(k => k.EmployeeId, v => v);
            List<int> employeeTimePeriodIds = employeeTimePeriodsDict.Values.Select(x => x.EmployeeTimePeriodId).ToList();

            var outcomes = (from p in query
                            where p.ActorCompanyId == actorCompanyId &&
                            employeeIds.Contains(p.EmployeeId) &&
                            employeeTimePeriodIds.Contains(p.EmployeeTimePeriodId) &&
                            (showDeleted || (p.State == (int)SoeEntityState.Active))
                            select p).ToList();

            foreach (int employeeId in employeeIds)
            {
                if (!employeeTimePeriodsDict.ContainsKey(employeeId))
                    outcomes.Add(CreatePayrollPeriodHasNotBeenCalculatedWarning(employeeId));

                //TDOO: Add in memory warning
            }

            if (setTerms)
                SetPayrollControlFunctionTerms(outcomes);

            return outcomes;
        }
        public List<PayrollControlFunctionOutcome> GetPayrollWarnings(int actorCompanyId, int employeeId, int employeeTimePeriodId, List<PayrollCalculationProductDTO> payrollCalculationProductDTOs, bool showDeleted = false, bool loadOutcomes = false, bool setTerms = false, bool addInMemoryWarnings = true)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.PayrollControlFunctionOutcome.MergeOption = MergeOption.NoTracking;
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetPayrollWarnings(entities, actorCompanyId, employeeId, employeeTimePeriodId, payrollCalculationProductDTOs, showDeleted, loadOutcomes, setTerms, addInMemoryWarnings);
        }

        public List<PayrollControlFunctionOutcome> GetPayrollWarnings(CompEntities entities, int actorCompanyId, int employeeId, int employeeTimePeriodId, List<PayrollCalculationProductDTO> payrollCalculationProductDTOs = null, bool showDeleted = false, bool loadOutcomes = false, bool setTerms = false, bool addInMemoryWarnings = true)
        {
            IQueryable<PayrollControlFunctionOutcome> query = entities.PayrollControlFunctionOutcome;
            if (loadOutcomes)
                query = query.Include("PayrollControlFunctionOutcomeChange");

            List<PayrollControlFunctionOutcome> outcomes = new List<PayrollControlFunctionOutcome>();

            if (employeeTimePeriodId != 0)
            {
                outcomes = (from p in query
                            where p.ActorCompanyId == actorCompanyId &&
                            p.EmployeeId == employeeId &&
                            p.EmployeeTimePeriodId == employeeTimePeriodId &&
                            (showDeleted || (p.State == (int)SoeEntityState.Active))
                            select p).ToList();
            }

            if (addInMemoryWarnings)
            {
                outcomes.AddRange(RecalculatePayrollControlFunctions.GetInMemoryWarnings(employeeId, employeeTimePeriodId, PayrollRulesUtil.CalculateSum(payrollCalculationProductDTOs)));
            }

            if (setTerms)
                SetPayrollControlFunctionTerms(outcomes);

            return outcomes.OrderBy(o => o.TypeName).ThenBy(o => o.StatusName).ToList();
        }
        public Dictionary<TermGroup_PayrollControlFunctionType, List<int>> GetPayrollWarningsByType(CompEntities entities, int actorCompanyId, List<int> employeeIds, int timePeriodId)
        {
            var outcomes = GetPayrollWarnings(entities, actorCompanyId, employeeIds, timePeriodId, loadHidden: false);
            return outcomes.GroupBy(o => o.Type).ToDictionary(k => (TermGroup_PayrollControlFunctionType)k.Key, v => v.Select(o => o.EmployeeId).Distinct().ToList());
        }

        public List<PayrollControlFunctionOutcome> GetPayrollWarnings(int actorCompanyId, List<int> employeeIds, int timePeriodId, bool setTerms = false)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.PayrollControlFunctionOutcome.MergeOption = MergeOption.NoTracking;
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetPayrollWarnings(entities, actorCompanyId, employeeIds, timePeriodId, setTerms);
        }

        public List<PayrollControlFunctionOutcome> GetPayrollWarnings(CompEntities entities, int actorCompanyId, List<int> employeeIds, int timePeriodId, bool setTerms = false, bool loadHidden = true)
        {
            List<int> validEmployeeIds = EmployeeManager.GetEmployeeIdsForQuery(entities, employeeIds);

            Dictionary<int, EmployeeTimePeriod> employeeTimePeriodsDict = TimePeriodManager.GetEmployeeTimePeriodsForEmployees(entities, employeeIds, actorCompanyId, timePeriodId).ToDictionary(k => k.EmployeeId, v => v);
            List<int> employeeTimePeriodIds = employeeTimePeriodsDict.Values.Select(x => x.EmployeeTimePeriodId).ToList();

            IQueryable<PayrollControlFunctionOutcome> query = entities.PayrollControlFunctionOutcome;
            if (!validEmployeeIds.IsNullOrEmpty())
                query = query.Where(w => validEmployeeIds.Contains(w.EmployeeId));

            var outcomes = (from p in query
                            where p.ActorCompanyId == actorCompanyId &&
                            p.EmployeeTimePeriod.TimePeriodId == timePeriodId &&
                            p.State == (int)SoeEntityState.Active &&
                            (p.Status != (int)TermGroup_PayrollControlFunctionStatus.HideforPeriod || loadHidden)
                            select p).ToList();

            //This needs to be done before the filtering below otherwise we remove the "PeriodHasNotBeenCalculatedWarning" for employees without calculated period
            outcomes = outcomes.Where(r => employeeTimePeriodIds.Contains(r.EmployeeTimePeriodId)).ToList();
            foreach (int employeeId in employeeIds)
            {
                if (!employeeTimePeriodsDict.ContainsKey(employeeId))
                    outcomes.Add(CreatePayrollPeriodHasNotBeenCalculatedWarning(employeeId));
            }

            if (!outcomes.IsNullOrEmpty())
            {
                if (validEmployeeIds.IsNullOrEmpty())
                    outcomes = outcomes.Where(r => employeeIds.Contains(r.EmployeeId)).ToList();
                if (setTerms)
                    SetPayrollControlFunctionTerms(outcomes);
            }
            return outcomes;
        }

        public PayrollControlFunctionOutcome CreatePayrollPeriodHasNotBeenCalculatedWarning(int employeeId)
        {
            return PayrollControlFunctionOutcome.CreatePayrollPeriodHasNotBeenCalculated(employeeId);
        }

        private void SetPayrollControlFunctionTerms(List<PayrollControlFunctionOutcome> payrollControlFunctionOutcomes)
        {
            if (payrollControlFunctionOutcomes.IsNullOrEmpty())
                return;

            var payrollControlFunctionTypeTerms = base.GetTermGroupContent(TermGroup.PayrollControlFunctionType);
            var payrollControlFunctionStatus = base.GetTermGroupContent(TermGroup.PayrollControlFunctionStatus);
            var payrollControlFunctionOutcomeChangeType = base.GetTermGroupContent(TermGroup.PayrollControlFunctionOutcomeChangeType);
            var payrollControlFunctionOutcomeChangeFieldType = base.GetTermGroupContent(TermGroup.PayrollControlFunctionOutcomeChangeFieldType);

            foreach (var outcome in payrollControlFunctionOutcomes)
            {
                outcome.TypeName = payrollControlFunctionTypeTerms.FirstOrDefault(f => f.Id == outcome.Type)?.Name;
                outcome.StatusName = payrollControlFunctionStatus.FirstOrDefault(f => f.Id == outcome.Status)?.Name;

                if (!outcome.PayrollControlFunctionOutcomeChange.IsNullOrEmpty())
                {
                    foreach (var outcomeChange in outcome.PayrollControlFunctionOutcomeChange)
                    {
                        outcomeChange.TypeName = payrollControlFunctionOutcomeChangeType.FirstOrDefault(f => f.Id == outcomeChange.Type)?.Name;
                        outcomeChange.FieldTypeName = payrollControlFunctionOutcomeChangeFieldType.FirstOrDefault(f => f.Id == outcomeChange.FieldType)?.Name;

                        if (outcomeChange.FieldType == (int)TermGroup_PayrollControlFunctionOutcomeChangeFieldType.Status)
                        {
                            outcomeChange.FromValueName = payrollControlFunctionStatus.FirstOrDefault(f => f.Id == Int32.Parse(outcomeChange.FromValue))?.Name;
                            outcomeChange.ToValueName = payrollControlFunctionStatus.FirstOrDefault(f => f.Id == Int32.Parse(outcomeChange.ToValue))?.Name;
                        }
                    }
                }
            }
        }

        public ActionResult SavePayrollWarnings(int actorCompanyId, List<PayrollControlFunctionOutcomeDTO> inputPayrollWarnings)
        {
            inputPayrollWarnings = inputPayrollWarnings.Where(x => x.Type != TermGroup_PayrollControlFunctionType.PeriodHasNotBeenCalculated).ToList();

            if (!inputPayrollWarnings.Any())
                return new ActionResult(true);

            var employeeId = inputPayrollWarnings.FirstOrDefault()?.EmployeeId ?? 0;
            var employeeTimePeriodId = inputPayrollWarnings.FirstOrDefault()?.EmployeeTimePeriodId ?? 0;

            if (employeeId == 0 || employeeTimePeriodId == 0)
                return new ActionResult(false);

            using (CompEntities entities = new CompEntities())
            {
                List<PayrollControlFunctionOutcome> payrollWarnings = GetPayrollWarnings(entities, actorCompanyId, employeeId, employeeTimePeriodId, addInMemoryWarnings: false);
                if (!payrollWarnings.Any())
                    return new ActionResult(true);

                foreach (PayrollControlFunctionOutcome payrollWarning in payrollWarnings)
                {
                    var inputPayrollWarning = inputPayrollWarnings.FirstOrDefault(w => w.PayrollControlFunctionOutcomeId == payrollWarning.PayrollControlFunctionOutcomeId);
                    if (inputPayrollWarning == null)
                        continue;

                    if (payrollWarning.Status != (int)inputPayrollWarning.Status)
                    {
                        var change = PayrollControlFunctionOutcomeChange.Create(
                            employeeId,
                            employeeTimePeriodId,
                            TermGroup_PayrollControlFunctionOutcomeChangeType.Manual,
                            TermGroup_PayrollControlFunctionOutcomeChangeFieldType.Status,
                            payrollWarning.Status.ToString(),
                            ((int)inputPayrollWarning.Status).ToString());

                        SetCreatedProperties(change);
                        payrollWarning.PayrollControlFunctionOutcomeChange.Add(change);
                        payrollWarning.Status = (int)inputPayrollWarning.Status;
                        SetModifiedProperties(payrollWarning);
                    }
                    if (payrollWarning.Comment != inputPayrollWarning.Comment)
                    {
                        var change = PayrollControlFunctionOutcomeChange.Create(
                            employeeId,
                            employeeTimePeriodId,
                            TermGroup_PayrollControlFunctionOutcomeChangeType.Manual,
                            TermGroup_PayrollControlFunctionOutcomeChangeFieldType.Comment,
                            payrollWarning.Comment,
                            inputPayrollWarning.Comment);

                        SetCreatedProperties(change);
                        payrollWarning.PayrollControlFunctionOutcomeChange.Add(change);
                        payrollWarning.Comment = inputPayrollWarning.Comment;
                        SetModifiedProperties(payrollWarning);
                    }
                }
                var result = SaveChanges(entities);
                return result;
            }
        }

        #endregion

        #region TimeRegistrationInformation

        public ActionResult SaveTimeRegistrationInformation(List<TimeRegistrationInformation> timeRegistrationInformation, int actorCompanyId, bool sendGoMail = false)
        {
            var timeDeviationCauses = TimeDeviationCauseManager.GetTimeDeviationCauses(actorCompanyId);
            List<TimeRegistrationInformation> failed = new List<TimeRegistrationInformation>();
            List<MessageEditDTO> messageEditForUsers = new List<MessageEditDTO>();

            using (CompEntities entities = new CompEntities())
            {
                var importHeads = entities.PayrollImportHead.Where(w => w.ActorCompanyId == actorCompanyId && w.State == (int)SoeEntityState.Active).ToList();
                var datesInFile = timeRegistrationInformation.Select(s => CalendarUtility.GetBeginningOfMonth(s.Date)).Distinct().ToList();
                var existingDates = importHeads.Where(w => w.FileType == (int)TermGroup_PayrollImportHeadFileType.TimeRegistrationInformation).Select(s => CalendarUtility.GetBeginningOfMonth(s.DateFrom.Date)).Distinct().ToList();

                datesInFile = datesInFile.Where(w => !existingDates.Contains(w)).ToList();

                if (datesInFile.Any())
                {
                    foreach (var date in datesInFile)
                    {
                        var headOnDate = importHeads.FirstOrDefault(f => f.DateFrom == date);

                        if (headOnDate == null)
                        {
                            headOnDate = new PayrollImportHead()
                            {
                                DateFrom = date,
                                DateTo = CalendarUtility.GetEndOfMonth(date),
                                FileType = (int)TermGroup_PayrollImportHeadFileType.TimeRegistrationInformation,

                                //Set FK
                                ActorCompanyId = actorCompanyId,
                            };
                            SetCreatedProperties(headOnDate);
                            entities.PayrollImportHead.AddObject(headOnDate);
                            SaveChanges(entities);
                        }
                    }
                }

                importHeads = entities.PayrollImportHead.Include("PayrollImportEmployee").Where(w => w.ActorCompanyId == actorCompanyId && w.State == (int)SoeEntityState.Active).ToList();

                foreach (var groupedOnEmployee in timeRegistrationInformation.GroupBy(o => o.EmployeeNr))
                {
                    var first = groupedOnEmployee.First();
                    if (!string.IsNullOrEmpty(first.EmployeeNr))
                    {
                        var employee = EmployeeManager.GetEmployeeByNr(first.EmployeeNr, actorCompanyId, loadEmployment: true);

                        if (employee != null && EmployeeManager.GetEmployeesForUsersAttestRoles(entities, out _, actorCompanyId, UserId, RoleId, employeeFilter: employee.EmployeeId.ObjToList()).Any())
                        {
                            foreach (var info in groupedOnEmployee.GroupBy(g => g.Code))
                            {
                                var second = groupedOnEmployee.First();
                                if (!string.IsNullOrEmpty(second.Code))
                                {
                                    foreach (var OnMonth in info.GroupBy(g => CalendarUtility.GetBeginningOfMonth(g.Date)))
                                    {
                                        var third = OnMonth.First();

                                        var head = importHeads.FirstOrDefault(f => f.DateFrom == CalendarUtility.GetBeginningOfMonth(third.Date));

                                        if (head == null)
                                            return new ActionResult("Something is not correct in setup");

                                        var ppEmployee = head.PayrollImportEmployee.FirstOrDefault(f => f.EmployeeId == employee.EmployeeId);

                                        if (ppEmployee == null)
                                        {
                                            ppEmployee = new PayrollImportEmployee()
                                            {
                                                EmployeeId = employee.EmployeeId
                                            };
                                            SetCreatedProperties(ppEmployee);
                                            ppEmployee.PayrollImportHead = head;
                                        }

                                        foreach (var registrationInformation in OnMonth)
                                        {
                                            var timeDeviationCode = timeDeviationCauses.FirstOrDefault(w => !string.IsNullOrEmpty(w.ExtCode) && w.ExtCode.ToLower() == registrationInformation.Code.ToLower());

                                            if (timeDeviationCode == null)
                                            {
                                                foreach (var item in timeDeviationCauses.Where(w => !string.IsNullOrEmpty(w.ExtCode) && w.ExtCode.Contains("#")))
                                                {
                                                    var match = item.ExternalCodes.FirstOrDefault(w => !string.IsNullOrEmpty(w) && w.ToLower() == registrationInformation.Code.ToLower());

                                                    if (!string.IsNullOrWhiteSpace(match))
                                                    {
                                                        timeDeviationCode = item;
                                                        break;
                                                    }
                                                }
                                            }

                                            PayrollImportEmployeeTransaction transaction = new PayrollImportEmployeeTransaction()
                                            {
                                                Date = registrationInformation.Date.Date,
                                                Quantity = registrationInformation.Minutes,
                                                StartTime = registrationInformation.From,
                                                StopTime = registrationInformation.To,
                                                Code = registrationInformation.Code,
                                                Note = registrationInformation.Comment,
                                                TimeDeviationCauseId = timeDeviationCode != null ? timeDeviationCode.TimeDeviationCauseId : (int?)null,
                                                Status = (int)TermGroup_PayrollImportEmployeeTransactionStatus.Unprocessed,
                                                Type = timeDeviationCode != null ? 0 : (int)TermGroup_PayrollImportEmployeeTransactionType.DeviationCause
                                            };
                                            SetCreatedProperties(transaction);
                                            ppEmployee.PayrollImportEmployeeTransaction.Add(transaction);
                                        }
                                    }
                                }
                            }

                            if (sendGoMail)
                            {
                                var user = entities.User.FirstOrDefault(f => employee.UserId == f.UserId);

                                if (user != null)
                                {
                                    int langId = user.LangId ?? (int)TermGroup_Languages.Swedish;
                                    string subject = GetText(12109, 1, langId, "Det finns nytt underlag från försystem att behandla");
                                    string text = subject + Environment.NewLine + Environment.NewLine;
                                    groupedOnEmployee.ToList().ForEach(f => text = text + $"{f.Date.ToShortDateString()} {f.Code} {CalendarUtility.GetHoursAndMinutesString(f.Minutes)} {f.Comment} " + Environment.NewLine);
                                    text = text + Environment.NewLine + GetText(91932, 1, langId, "Hantera underlaget vidare i Min tid/Attestera tid");

                                    MessageEditDTO messageEditForUser = new MessageEditDTO()
                                    {
                                        Entity = SoeEntityType.User,
                                        RecordId = 0,
                                        ActorCompanyId = null,
                                        LicenseId = parameterObject.SoeUser.LicenseId,
                                        SenderUserId = parameterObject.UserId,
                                        Subject = subject,
                                        Text = StringUtility.ConvertNewLineToHtml(text),
                                        ShortText = text,
                                        SenderName = parameterObject.SoeUser.Name,
                                        SenderEmail = "",
                                        Created = DateTime.Now,
                                        SentDate = DateTime.Now,
                                        MessagePriority = TermGroup_MessagePriority.None,
                                        MessageType = TermGroup_MessageType.AutomaticInformation,
                                        MessageDeliveryType = TermGroup_MessageDeliveryType.XEmail,
                                        MessageTextType = TermGroup_MessageTextType.Text,
                                    };

                                    messageEditForUser.Recievers.Add(new MessageRecipientDTO()
                                    {
                                        UserId = user.UserId,
                                        UserName = user.LoginName,
                                        Name = user.Name,
                                        EmailAddress = user.Email,
                                        Type = XEMailRecipientType.User,
                                    });

                                    messageEditForUsers.Add(messageEditForUser);
                                }
                            }
                        }
                        else
                        {
                            groupedOnEmployee.ToList().ForEach(f => f.Status = (int)TermGroup_PayrollImportEmployeeTransactionStatus.Error);
                            groupedOnEmployee.ToList().ForEach(f => f.ErrorMessage = "EmployeeNotFoundForAttestRole NotSaved");
                            groupedOnEmployee.ToList().ForEach(f => f.ErrorNumber = 1);
                            failed.AddRange(groupedOnEmployee.ToList());
                        }
                    }
                }

                var result = SaveChanges(entities);
                if (failed.Any())
                {
                    result.ErrorNumber = 1;
                    result.StringValue = JsonConvert.SerializeObject(failed);
                }

                if (result.Success)
                    messageEditForUsers.ForEach(f => CommunicationManager.SendXEMail(f, actorCompanyId, 0, parameterObject.UserId));

                return result;
            }
        }

        public List<TimeRegistrationInformation> GetTimeRegistrationInformation(int actorCompanyId, List<string> employeeNrs, DateTime fromDate, DateTime toDate)
        {
            var employees = EmployeeManager.GetAllEmployeesByNumbers(actorCompanyId, employeeNrs ?? new List<string>());
            employees = EmployeeManager.GetEmployeesForUsersAttestRoles(out _, actorCompanyId, UserId, RoleId, dateFrom: fromDate, dateTo: toDate, employeeFilter: employeeNrs == null ? null : employees.Select(s => s.EmployeeId).ToList());
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetTimeRegistrationInformation(entities, actorCompanyId, employees.Select(s => s.EmployeeId).ToList(), fromDate, toDate);
        }

        public List<TimeRegistrationInformation> GetTimeRegistrationInformation(CompEntities entities, int actorCompanyId, List<int> employeeIds, DateTime fromDate, DateTime toDate, bool notProcessed = false)
        {
            var payrollImportEmployees = entities.PayrollImportEmployeeTransaction.Include("PayrollImportEmployee.Employee").Where(w =>
                                                                                         w.PayrollImportEmployee.PayrollImportHead.ActorCompanyId == actorCompanyId &&
                                                                                         w.PayrollImportEmployee.PayrollImportHead.State == (int)SoeEntityState.Active &&
                                                                                         w.State == (int)SoeEntityState.Active &&
                                                                                         employeeIds.Contains(w.PayrollImportEmployee.EmployeeId) &&
                                                                                         w.Date >= fromDate &&
                                                                                         w.Date <= toDate).ToList();

            List<TimeRegistrationInformation> timeRegistrations = new List<TimeRegistrationInformation>();

            foreach (var transaction in payrollImportEmployees)
            {
                if (notProcessed && transaction.Status != (int)TermGroup_PayrollImportEmployeeTransactionStatus.Processed)
                {
                    TimeRegistrationInformation timeRegistration = new TimeRegistrationInformation()
                    {
                        Code = transaction.Code,
                        EmployeeNr = transaction.PayrollImportEmployee.Employee.EmployeeNr,
                        Comment = transaction.Note,
                        Date = transaction.Date,
                        From = transaction.StartTime,
                        To = transaction.StopTime,
                        Minutes = Convert.ToInt32(transaction.Quantity),
                        Status = transaction.Status,
                        ErrorMessage = transaction.ErrorMessage
                    };
                    timeRegistrations.Add(timeRegistration);
                }
            }

            return timeRegistrations;
        }

        #endregion

        #region PayrollPriceFormula

        public List<PayrollPriceFormula> GetPayrollPriceFormulas(int actorCompanyId, bool convertToGUI = false, bool onlyActive = true)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollPriceFormula.NoTracking();
            return GetPayrollPriceFormulas(entities, actorCompanyId, convertToGUI, onlyActive);
        }

        public List<PayrollPriceFormula> GetPayrollPriceFormulas(CompEntities entities, int actorCompanyId, bool convertToGUI = false, bool onlyActive = true)
        {
            IQueryable<PayrollPriceFormula> formulas = (from p in entities.PayrollPriceFormula
                                                        where p.ActorCompanyId == actorCompanyId
                                                        orderby p.Name
                                                        select p);
            if (onlyActive)
                formulas = formulas.Where(p => p.State == (int)SoeEntityState.Active);
            else
                formulas = formulas.Where(p => p.State == (int)SoeEntityState.Active || p.State == (int)SoeEntityState.Inactive);

            if (convertToGUI)
            {
                foreach (var formula in formulas)
                {
                    formula.Formula = ConvertPayrollPriceFormulaToGUI(actorCompanyId, formula.Formula);
                }
            }

            return formulas.ToList();
        }

        public List<PayrollPriceFormulaSmallDTO> GetPayrollPriceFormulasForFormulaBuilder(int actorCompanyId, int? excludedFormulaId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetPayrollPriceFormulasForFormulaBuilder(entities, actorCompanyId, excludedFormulaId);
        }

        public List<PayrollPriceFormulaSmallDTO> GetPayrollPriceFormulasForFormulaBuilder(CompEntities entities, int actorCompanyId, int? excludedFormulaId)
        {
            List<PayrollPriceFormulaSmallDTO> formulas = new List<PayrollPriceFormulaSmallDTO>()
            {
                new PayrollPriceFormulaSmallDTO()
                {
                    PayrollPriceFormulaId = 0,
                    Code = String.Empty,
                    Name = " "
                }
            };

            var priceFormulas = GetPayrollPriceFormulas(entities, actorCompanyId);
            foreach (PayrollPriceFormula priceFormula in priceFormulas)
            {
                if (excludedFormulaId.HasValue && excludedFormulaId.Value != 0 && priceFormula.PayrollPriceFormulaId == excludedFormulaId.Value)
                    continue;

                formulas.Add(new PayrollPriceFormulaSmallDTO()
                {
                    PayrollPriceFormulaId = priceFormula.PayrollPriceFormulaId,
                    Code = priceFormula.Code,
                    Name = String.Format("{0} ({1})", priceFormula.Name, priceFormula.Code)
                });
            }

            return formulas;
        }

        public Dictionary<int, string> GetPayrollPriceFormulasDict(int actorCompanyId, bool addEmptyRow, bool useCode = false)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollPriceFormula.NoTracking();
            return GetPayrollPriceFormulasDict(entities, actorCompanyId, addEmptyRow, useCode);
        }

        public Dictionary<int, string> GetPayrollPriceFormulasDict(CompEntities entities, int actorCompanyId, bool addEmptyRow, bool useCode = false)
        {
            Dictionary<int, string> dict = new Dictionary<int, string>();
            if (addEmptyRow)
                dict.Add(0, " ");

            List<PayrollPriceFormula> formulas = GetPayrollPriceFormulas(entities, actorCompanyId, false);
            foreach (PayrollPriceFormula formula in formulas)
            {
                dict.Add(formula.PayrollPriceFormulaId, useCode ? formula.Code : formula.Name);
            }

            return dict;
        }

        public PayrollPriceFormula GetPayrollPriceFormula(int actorCompanyId, int payrollPriceFormulaId, bool convertToGUI = false)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollPriceFormula.NoTracking();
            return GetPayrollPriceFormula(entities, actorCompanyId, payrollPriceFormulaId, convertToGUI);
        }

        public PayrollPriceFormula GetPayrollPriceFormula(CompEntities entities, int actorCompanyId, int payrollPriceFormulaId, bool convertToGUI = false)
        {
            PayrollPriceFormula formula = (from p in entities.PayrollPriceFormula
                                           where p.PayrollPriceFormulaId == payrollPriceFormulaId &&
                                           (p.State == (int)SoeEntityState.Active || p.State == (int)SoeEntityState.Inactive)
                                           select p).FirstOrDefault();

            if (convertToGUI && formula != null)
                formula.Formula = ConvertPayrollPriceFormulaToGUI(actorCompanyId, formula.Formula);

            return formula;
        }

        public PayrollPriceFormula GetPayrollPriceFormula(int actorCompanyId, string code)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollPriceFormula.NoTracking();
            return GetPayrollPriceFormula(entities, actorCompanyId, code);
        }

        public PayrollPriceFormula GetPayrollPriceFormula(CompEntities entities, int actorCompanyId, string code)
        {
            return (from p in entities.PayrollPriceFormula
                    where p.ActorCompanyId == actorCompanyId &&
                    p.Code == code &&
                    p.State == (int)SoeEntityState.Active
                    select p).FirstOrDefault();
        }

        public bool PayrollPriceTypeOrFormulaCodeExists(int actorCompanyId, string code)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.PayrollPriceType.NoTracking();
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollPriceFormula.NoTracking();
            return PayrollPriceTypeOrFormulaCodeExists(entities, actorCompanyId, code);
        }

        public bool PayrollPriceTypeOrFormulaCodeExists(CompEntities entities, int actorCompanyId, string code)
        {
            bool exists = false;

            if (SysDbCache.Instance.SysPayrollPriceViewDTOs.Any(w => w.Code == code))
                return true;

            int sysCountryId = base.GetCompanySysCountryIdFromCache(entities, actorCompanyId);

            exists = (from p in entities.PayrollPriceType
                      where p.ActorCompanyId == actorCompanyId &&
                      p.Code == code &&
                      p.State == (int)SoeEntityState.Active
                      select p).Any();

            if (exists)
                return true;

            exists = (from p in entities.PayrollPriceFormula
                      where p.ActorCompanyId == actorCompanyId &&
                      p.Code == code &&
                      p.State == (int)SoeEntityState.Active
                      select p).Any();

            if (exists)
                return true;

            using var sysEntitiesReadOnly = SysEntitiesProvider.LeaseReadOnlyContext();
            exists = (from p in sysEntitiesReadOnly.SysPayrollPrice
                      where p.SysCountryId == sysCountryId &&
                      p.Code == code
                      select p).Any();

            return exists;
        }

        public string ConvertPayrollPriceFormulaToDB(int actorCompanyId, string formula)
        {
            // Split formula on words and check if the codes exists in different tables
            string[] codes = Regex.Split(formula.Replace(" ", "").ToUpperInvariant(), @"\W");
            foreach (string code in codes.Where(c => c.Length > 0))
            {
                // If number don't try to lookup
                if (Int32.TryParse(code, out _))
                    continue;

                string pattern = @"\b" + code + @"\b";

                #region PriceType

                PayrollPriceType type = GetPayrollPriceType(actorCompanyId, code);
                if (type != null)
                {
                    formula = Regex.Replace(formula, pattern, "PT" + type.PayrollPriceTypeId, RegexOptions.IgnoreCase);
                    continue;
                }

                #endregion

                #region PriceFormula

                PayrollPriceFormula frm = GetPayrollPriceFormula(actorCompanyId, code);
                if (frm != null)
                {
                    formula = Regex.Replace(formula, pattern, "PF" + frm.PayrollPriceFormulaId, RegexOptions.IgnoreCase);
                    continue;
                }

                #endregion

                #region Fixed value

                var sysPayrollPrice = GetSysPayrollPrice(actorCompanyId, code);
                if (sysPayrollPrice != null)
                {
                    formula = Regex.Replace(formula, pattern, "FV" + sysPayrollPrice.SysTermId, RegexOptions.IgnoreCase);
                    continue;
                }

                #endregion
            }

            return formula;
        }

        public ActionResult SavePayrollPriceFormula(PayrollPriceFormulaDTO payrollPriceFormulaInput, int actorCompanyId)
        {
            if (payrollPriceFormulaInput == null)
                return new ActionResult((int)ActionResultSave.EntityIsNull, "PayrollPriceFormula");

            string txt = "";
            if (payrollPriceFormulaInput.State != SoeEntityState.Active)
            {
                if (IsPayrollPriceFormulaInUse(payrollPriceFormulaInput.PayrollPriceFormulaId))
                    txt += GetText(3601, 1, "Varning. Denna Löneformeln används idag") + "\r\n\r\n";

                if (IsPayrollPriceFormulaInUseInFormula(payrollPriceFormulaInput.PayrollPriceFormulaId, payrollPriceFormulaInput.ActorCompanyId))
                    txt += GetText(3602, 1, "Varning. Denna Löneformeln används i en eller flera andra formler");

            }

            // Default result is successful
            ActionResult result = new ActionResult();

            int payrollPriceFormulaId = payrollPriceFormulaInput.PayrollPriceFormulaId;
            payrollPriceFormulaInput.Formula = ConvertPayrollPriceFormulaToDB(actorCompanyId, payrollPriceFormulaInput.FormulaPlain);

            bool codeExists = PayrollPriceTypeOrFormulaCodeExists(actorCompanyId, payrollPriceFormulaInput.Code);

            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    entities.Connection.Open();

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_DEFAULT))
                    {
                        #region PayrollPriceFormula

                        // Get existing
                        PayrollPriceFormula payrollPriceFormula = GetPayrollPriceFormula(entities, actorCompanyId, payrollPriceFormulaId);
                        if (payrollPriceFormula == null)
                        {
                            #region Add

                            if (codeExists)
                                return new ActionResult((int)ActionResultSave.PayrollPriceTypeOrFormulaCodeExists, GetText(3583));

                            payrollPriceFormula = new PayrollPriceFormula()
                            {
                                ActorCompanyId = actorCompanyId,
                            };
                            SetCreatedProperties(payrollPriceFormula);
                            entities.PayrollPriceFormula.AddObject(payrollPriceFormula);

                            #endregion
                        }
                        else
                        {
                            #region Update

                            if (codeExists && payrollPriceFormula.Code != payrollPriceFormulaInput.Code)
                                return new ActionResult((int)ActionResultSave.PayrollPriceTypeOrFormulaCodeExists, GetText(3583));

                            SetModifiedProperties(payrollPriceFormula);

                            #endregion
                        }

                        payrollPriceFormula.Code = payrollPriceFormulaInput.Code.ToUpperInvariant();
                        payrollPriceFormula.Name = payrollPriceFormulaInput.Name;
                        payrollPriceFormula.Description = payrollPriceFormulaInput.Description;
                        payrollPriceFormula.Formula = payrollPriceFormulaInput.Formula;
                        payrollPriceFormula.FormulaPlain = payrollPriceFormulaInput.FormulaPlain;
                        payrollPriceFormula.State = (int)payrollPriceFormulaInput.State;

                        #endregion

                        result = SaveChanges(entities, transaction);
                        if (result.Success)
                        {
                            //Commit transaction
                            transaction.Complete();

                            payrollPriceFormulaId = payrollPriceFormula.PayrollPriceFormulaId;
                        }
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result.Exception = ex;
                    result.IntegerValue = 0;
                }
                finally
                {
                    if (txt != "")
                    {
                        result.CanUserOverride = true;
                        result.ErrorMessage = txt;
                    }

                    if (result.Success)
                    {
                        //Set success properties
                        result.IntegerValue = payrollPriceFormulaId;
                    }
                    else
                        base.LogTransactionFailed(this.ToString(), this.log);

                    entities.Connection.Close();
                }

                return result;
            }
        }

        public ActionResult DeletePayrollPriceFormula(int payrollPriceFormulaId)
        {
            using (CompEntities entities = new CompEntities())
            {
                PayrollPriceFormula payrollPriceFormula = GetPayrollPriceFormula(entities, 0, payrollPriceFormulaId);
                if (payrollPriceFormula == null)
                    return new ActionResult((int)ActionResultDelete.EntityNotFound, "PayrollPriceFormula");

                if (IsPayrollPriceFormulaInUse(payrollPriceFormulaId))
                    return new ActionResult((int)ActionResultDelete.PayrollPriceFormulaInUse, GetText(3586, 1, "Löneformeln används och kan därför ej tas bort"));

                if (IsPayrollPriceFormulaInUseInFormula(payrollPriceFormulaId, payrollPriceFormula.ActorCompanyId))
                    return new ActionResult((int)ActionResultDelete.PayrollPriceFormulaInUseInFormula, GetText(3587, 1, "Löneformeln används i en eller flera andra formler och kan därför ej tas bort"));

                return ChangeEntityState(entities, payrollPriceFormula, SoeEntityState.Deleted, true);
            }
        }

        public PayrollPriceFormulaResultDTO EvaluatePayrollProductPriceTypePeriod(CompEntities entities, PayrollProductPriceTypePeriod productPriceTypePeriod, DateTime date)
        {
            if (productPriceTypePeriod == null || productPriceTypePeriod.PayrollProductPriceType == null)
                return null;

            if (!productPriceTypePeriod.PayrollProductPriceTypeReference.IsLoaded)
                productPriceTypePeriod.PayrollProductPriceTypeReference.Load();
            if (!productPriceTypePeriod.PayrollProductPriceType.PayrollProductSettingReference.IsLoaded)
                productPriceTypePeriod.PayrollProductPriceType.PayrollProductSettingReference.Load();

            if (productPriceTypePeriod.Amount.HasValue)
            {
                return new PayrollPriceFormulaResultDTO()
                {
                    PayrollPriceTypeId = productPriceTypePeriod.PayrollProductPriceType.PayrollPriceTypeId,
                    Amount = productPriceTypePeriod.Amount.Value,
                };
            }
            else
            {
                PayrollPriceTypePeriod priceTypePeriod = ProductManager.GetPayrollPriceTypePeriod(entities, productPriceTypePeriod.PayrollProductPriceType.PayrollPriceTypeId, date);
                return EvaluatePayrollPriceTypePeriod(priceTypePeriod);
            }
        }

        public PayrollPriceFormulaResultDTO EvaluatePayrollPriceTypePeriod(PayrollPriceTypePeriod priceTypePeriod)
        {
            if (priceTypePeriod == null)
                return null;

            return new PayrollPriceFormulaResultDTO()
            {
                PayrollPriceTypeId = priceTypePeriod.PayrollPriceTypeId,
                Amount = priceTypePeriod.Amount,
            };
        }

        public PayrollPriceFormulaResultDTO EvaluatePayrollPriceFormula(int actorCompanyId, int employeeId, int productId, DateTime date, decimal? inputValue = null, EvaluatePayrollPriceFormulaInputDTO iDTO = null)
        {
            Employee employee = EmployeeManager.GetEmployee(employeeId, actorCompanyId, loadEmployment: true);
            Employment employment = employee?.GetEmployment(date);
            if (employment == null)
                return null;

            PayrollProduct payrollProduct = ProductManager.GetPayrollProduct(productId);

            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return EvaluatePayrollPriceFormula(entities, actorCompanyId, employee, employment, payrollProduct, date, inputValue, iDTO);
        }

        public PayrollPriceFormulaResultDTO EvaluatePayrollPriceFormula(int actorCompanyId, int employmentId, int productId, DateTime date, int? payrollGroupPriceFormulaId, int? payrollProductPriceFormulaId, int? payrollPriceFormulaId, decimal? inputValue = null, EvaluatePayrollPriceFormulaInputDTO iDTO = null)
        {
            if (iDTO == null)
                iDTO = new EvaluatePayrollPriceFormulaInputDTO();

            Employment employment = EmployeeManager.GetEmployment(employmentId);
            if (employment == null)
                return new PayrollPriceFormulaResultDTO();

            PayrollProduct payrollProduct = ProductManager.GetPayrollProduct(productId);

            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return EvaluatePayrollPriceFormula(entities, actorCompanyId, employment.EmployeeId, employment, payrollProduct, date, payrollGroupPriceFormulaId, payrollProductPriceFormulaId, payrollPriceFormulaId, inputValue, iDTO);
        }

        public PayrollPriceFormulaResultDTO EvaluatePayrollPriceFormula<T>(int actorCompanyId, T employeeType, Employment employment, PayrollProduct payrollProduct, DateTime date, int? payrollGroupPriceFormulaId = null, int? payrollProductPriceFormulaId = null, int? payrollPriceFormulaId = null, decimal? inputValue = null, EvaluatePayrollPriceFormulaInputDTO iDTO = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return EvaluatePayrollPriceFormula(entities, actorCompanyId, employeeType, employment, payrollProduct, date, payrollGroupPriceFormulaId, payrollProductPriceFormulaId, payrollPriceFormulaId, inputValue, iDTO);
        }

        public PayrollPriceFormulaResultDTO EvaluatePayrollPriceFormula<T>(CompEntities entities, int actorCompanyId, T employeeType, Employment employment, PayrollProduct payrollProduct, DateTime date, decimal? inputValue = null, EvaluatePayrollPriceFormulaInputDTO iDTO = null)
        {
            if (employment == null || payrollProduct == null)
                return null;

            string key = $"EvaluatePayrollPriceFormula#{date}#{employment.EmploymentId}#{actorCompanyId}#{payrollProduct.ProductId}#{inputValue}";
            PayrollPriceFormulaResultDTO formulaResult = BusinessMemoryCache<PayrollPriceFormulaResultDTO>.Get(key);
            if (formulaResult != null)
                return formulaResult.Clone();

            if (iDTO == null)
                iDTO = new EvaluatePayrollPriceFormulaInputDTO();

            int? payrollGroupId = employment.GetPayrollGroupId(date);

            PayrollProductPriceFormula priceFormula;
            if (iDTO.PayrollProductPriceFormulas == null)
                priceFormula = ProductManager.GetPayrollProductPriceFormula(entities, payrollProduct.ProductId, payrollGroupId, date);
            else
                priceFormula = ProductManager.GetPayrollProductPriceFormula(iDTO.PayrollProductPriceFormulas, payrollProduct.ProductId, payrollGroupId, date);

            PayrollProductPriceTypePeriod productPriceTypePeriod;
            if (iDTO.PayrollProductPriceTypes == null)
                productPriceTypePeriod = ProductManager.GetPayrollProductPriceTypePeriod(entities, payrollProduct.ProductId, payrollGroupId, date);
            else
                productPriceTypePeriod = ProductManager.GetPayrollProductPriceTypePeriod(iDTO.PayrollProductPriceTypes, payrollProduct.ProductId, payrollGroupId, date);

            bool usePriceFormula = false;
            bool usePriceType = false;

            if (priceFormula != null && productPriceTypePeriod != null)
            {
                if (priceFormula.FromDate.GetValueOrDefault() >= productPriceTypePeriod.FromDate.GetValueOrDefault())
                    usePriceFormula = true;
                else
                    usePriceType = true;
            }
            else if (priceFormula != null)
            {
                usePriceFormula = true;
            }
            else if (productPriceTypePeriod != null)
            {
                usePriceType = true;
            }

            if (usePriceFormula)
                formulaResult = EvaluatePayrollPriceFormula(entities, actorCompanyId, employeeType, employment, payrollProduct, date, null, priceFormula.PayrollProductPriceFormulaId, null, inputValue, iDTO);
            else if (usePriceType)
                formulaResult = EvaluatePayrollProductPriceTypePeriod(entities, productPriceTypePeriod, date);

            if (formulaResult != null)
                BusinessMemoryCache<PayrollPriceFormulaResultDTO>.Set(key, formulaResult, 5);

            if (formulaResult == null)
                formulaResult = new PayrollPriceFormulaResultDTO();

            return formulaResult.Clone();
        }

        public PayrollPriceFormulaResultDTO EvaluatePayrollPriceFormula<T>(CompEntities entities, int actorCompanyId, T employeeType, Employment employment, PayrollProduct payrollProduct, DateTime date, int? payrollGroupPriceFormulaId, int? payrollProductPriceFormulaId, int? payrollPriceFormulaId, decimal? inputValue = null, EvaluatePayrollPriceFormulaInputDTO iDTO = null, bool isFromOtherFormula = false)
        {
            PayrollPriceFormulaResultDTO formulaResult = new PayrollPriceFormulaResultDTO();

            #region Init

            if (iDTO == null)
                iDTO = new EvaluatePayrollPriceFormulaInputDTO();

            if (isFromOtherFormula)
            {
                string key = $"CircularCheckPF#{date}#{employment.EmploymentId}";
                var circularTime = BusinessMemoryCache<int?>.Get(key);
                if (circularTime.HasValue && circularTime > 20)
                    throw new Exception($"Circular formulas detected id{payrollGroupPriceFormulaId}");
                if (circularTime.HasValue)
                    circularTime = 0;
                circularTime++;
                BusinessMemoryCache<int?>.Set(key, circularTime, 5);
            }

            List<string> identifiers = new List<string>();
            Dictionary<string, string> identifierNames = new Dictionary<string, string>();
            Dictionary<string, string> identifierOrigins = new Dictionary<string, string>();

            #endregion

            #region Prereq

            int employeeId = employment.EmployeeId;
            int payrollProductId = payrollProduct?.ProductId ?? 0;

            // Get formula from payroll group
            PayrollGroupPriceFormula groupFormula = null;
            if (payrollGroupPriceFormulaId.HasValue)
                groupFormula = GetPayrollGroupPriceFormula(entities, payrollGroupPriceFormulaId.Value);

            // Get formula from payroll product
            PayrollProductPriceFormula productFormula = null;
            if (payrollProductPriceFormulaId.HasValue)
            {
                if (iDTO.PayrollProductPriceFormulas == null)
                    productFormula = ProductManager.GetPayrollProductPriceFormula(entities, payrollProductPriceFormulaId.Value);
                else
                    productFormula = iDTO.PayrollProductPriceFormulas.FirstOrDefault(p => p.PayrollProductPriceFormulaId == payrollProductPriceFormulaId.Value);

                if (productFormula != null)
                {
                    if (!productFormula.PayrollProductSettingReference.IsLoaded)
                        productFormula.PayrollProductSettingReference.Load();
                    if (payrollProductId == 0 && productFormula.PayrollProductSetting != null)
                        payrollProductId = productFormula.PayrollProductSetting.ProductId;
                }
            }

            if (!payrollPriceFormulaId.HasValue)
            {
                if (groupFormula != null)
                    payrollPriceFormulaId = groupFormula.PayrollPriceFormulaId;
                else if (productFormula != null)
                    payrollPriceFormulaId = productFormula.PayrollPriceFormulaId;
            }

            // Get formula
            PayrollPriceFormulaDTO priceFormula = null;
            if (payrollPriceFormulaId.HasValue)
            {
                if (iDTO.PayrollPriceFormulas == null)
                    priceFormula = base.GetPayrollPriceFormulaDTOFromCache(entities, payrollPriceFormulaId.Value, CacheConfig.Company(actorCompanyId));
                else
                    priceFormula = iDTO.PayrollPriceFormulas.FirstOrDefault(p => p.PayrollPriceFormulaId == payrollPriceFormulaId.Value).ToDTO();
            }

            if (priceFormula == null)
                return formulaResult;

            string formula = priceFormula.Formula;

            #endregion

            #region Perform

            // Convert parameters to values
            string[] codes = Regex.Split(formula.Replace(" ", "").ToUpperInvariant(), @"\W");
            foreach (string code in codes.Where(c => c.Length > 0))
            {
                string pattern = @"\b" + code + @"\b";
                int id = 0;

                if (code.StartsWith("PT"))
                {
                    #region PriceType

                    if (Int32.TryParse(code.Substring(2), out id))
                    {
                        bool priceTypeFound = false;

                        #region Get PriceType from Employment

                        // Check if price type exists on employment
                        EmploymentPriceType empPriceType = null;

                        if (iDTO.EmploymentPriceTypesDict == null)
                            empPriceType = EmployeeManager.GetEmploymentPriceTypeByPriceType(entities, employment.EmploymentId, id);
                        else
                            empPriceType = iDTO.EmploymentPriceTypesDict.ContainsKey(employment.EmploymentId) ? iDTO.EmploymentPriceTypesDict.GetValue(employment.EmploymentId)?.FirstOrDefault(w => w.PayrollPriceTypeId == id) : null;

                        if (empPriceType != null)
                        {
                            // Replace database code in formula with actual code
                            formula = Regex.Replace(formula, pattern, empPriceType.PayrollPriceType.Code, RegexOptions.IgnoreCase);

                            // Get value
                            decimal? value = empPriceType.GetEmploymentPriceTypeAmount(date);
                            if (value.HasValue)
                            {
                                priceTypeFound = true;
                                AddToIdentifiers(identifiers, empPriceType.PayrollPriceType.Code, value.Value);
                                AddToIdentifierNames(identifierNames, empPriceType.PayrollPriceType.Code, empPriceType.PayrollPriceType.Name);
                                AddToIdentifierOrigins(identifierOrigins, empPriceType.PayrollPriceType.Code, "Employment");
                            }
                        }

                        #endregion

                        if (!priceTypeFound)
                        {
                            // Get price type
                            PayrollPriceTypeDTO priceType = iDTO.PayrollPriceTypes?.FirstOrDefault(p => p.PayrollPriceTypeId == id)?.ToDTO(true);
                            if (priceType == null)
                                priceType = base.GetPayrollPriceTypeFromCache(entities, id, CacheConfig.Company(actorCompanyId));

                            if (priceType != null)
                            {
                                // Replace database code in formula with actual code
                                formula = Regex.Replace(formula, pattern, priceType.Code, RegexOptions.IgnoreCase);

                                // Get value for specified date
                                decimal value = 0;
                                string origin = String.Empty;

                                #region Get PriceType from PayrollGroup

                                // Check if price type exists on payroll group
                                int payrollGroupId = 0;
                                if (groupFormula != null)
                                    payrollGroupId = groupFormula.PayrollGroupId;
                                else if (employment != null)
                                    payrollGroupId = employment.GetPayrollGroupId(date) ?? 0;

                                if (payrollGroupId != 0)
                                {
                                    // Get price type from payroll group
                                    PayrollGroupPriceType groupPriceType = null;
                                    if (iDTO.PayrollGroupPriceTypes == null)
                                        groupPriceType = GetPayrollGroupPriceType(entities, payrollGroupId, id, null);
                                    else
                                        groupPriceType = iDTO.PayrollGroupPriceTypes.FirstOrDefault(p => p.PayrollGroupId == payrollGroupId && p.PayrollPriceTypeId == id && !p.PayrollLevelId.HasValue);

                                    if (groupPriceType != null && !groupPriceType.PayrollGroupPriceTypePeriod.IsNullOrEmpty())
                                    {
                                        var period = groupPriceType.PayrollGroupPriceTypePeriod.Where(p => (!p.FromDate.HasValue || p.FromDate.Value <= date) && p.State == (int)SoeEntityState.Active).OrderBy(p => p.FromDate).LastOrDefault();
                                        if (period != null)
                                        {
                                            value = period.Amount;
                                            origin = "PayrollGroup";
                                            priceTypeFound = true;
                                        }
                                    }
                                }

                                #endregion

                                #region Get PriceType from PayrollProduct

                                // Check if price type exists on payroll product
                                if (!priceTypeFound && productFormula != null)
                                {
                                    // Get price type from payroll product
                                    PayrollProductPriceType productPriceType = null;
                                    if (iDTO.PayrollProductPriceTypes == null)
                                        productPriceType = ProductManager.GetPayrollProductPriceType(entities, payrollProductId, payrollGroupId, id);
                                    else
                                        productPriceType = iDTO.PayrollProductPriceTypes.FirstOrDefault(p => p.PayrollProductSetting.ProductId == payrollProductId && p.PayrollProductSetting.PayrollGroupId == payrollGroupId && p.PayrollProductPriceTypeId == id);

                                    if (productPriceType != null && !productPriceType.PayrollProductPriceTypePeriod.IsNullOrEmpty())
                                    {
                                        var period = productPriceType.PayrollProductPriceTypePeriod.Where(p => (!p.FromDate.HasValue || p.FromDate.Value <= date) && p.State == (int)SoeEntityState.Active).OrderBy(p => p.FromDate).LastOrDefault();
                                        if (period != null)
                                        {
                                            value = period.Amount ?? 0;
                                            origin = "PayrollProduct";
                                            priceTypeFound = true;
                                        }
                                    }
                                }

                                #endregion

                                #region Get PriceType

                                if (!priceTypeFound)
                                {
                                    var period = priceType.Periods?.Where(p => (!p.FromDate.HasValue || p.FromDate.Value <= date)).OrderBy(p => p.FromDate).LastOrDefault();
                                    if (period != null)
                                    {
                                        value = period.Amount;
                                        origin = "PriceType";
                                        priceTypeFound = true;
                                    }
                                }

                                #endregion

                                AddToIdentifiers(identifiers, priceType.Code, value);
                                AddToIdentifierNames(identifierNames, priceType.Code, priceType.Name);
                                AddToIdentifierOrigins(identifierOrigins, priceType.Code, origin);
                            }
                        }
                    }

                    #endregion
                }
                else if (code.StartsWith("PF"))
                {
                    #region PriceFormula

                    if (Int32.TryParse(code.Substring(2), out id))
                    {
                        // Recursive evaluation of formula
                        PayrollPriceFormula payrollPriceFormula = iDTO?.PayrollPriceFormulas?.FirstOrDefault(f => f.PayrollPriceFormulaId == id) ?? GetPayrollPriceFormula(entities, actorCompanyId, id);
                        if (payrollPriceFormula != null)
                        {
                            PayrollProduct formulaPayrollProduct = payrollProduct != null && payrollProduct.ProductId == payrollProductId ? payrollProduct : iDTO.PayrollProducts?.FirstOrDefault(f => f.ProductId == payrollProductId) ?? ProductManager.GetPayrollProduct(entities, payrollProductId);
                            PayrollPriceFormulaResultDTO subResult = EvaluatePayrollPriceFormula(entities, actorCompanyId, employeeType, employment, formulaPayrollProduct, date, null, null, payrollPriceFormula.PayrollPriceFormulaId, inputValue: inputValue, iDTO: iDTO, isFromOtherFormula: true);
                            AddToIdentifierOrigins(identifierOrigins, payrollPriceFormula.Code, subResult.FormulaOrigin);
                            formula = Regex.Replace(formula, pattern, subResult.Amount.ToString(), RegexOptions.IgnoreCase);
                        }
                    }

                    #endregion
                }
                else if (code.StartsWith("FV"))
                {
                    #region Fixed value

                    decimal value = 0;
                    if (Int32.TryParse(code.Substring(2), out int sysTermId))
                    {
                        SysPayrollPriceViewDTO sysPayrollPrice;
                        if (iDTO.SysPayrollPriceViews == null)
                            sysPayrollPrice = GetSysPayrollPrice(entities, actorCompanyId, sysTermId, date, iDTO.SysCountryId);
                        else
                            sysPayrollPrice = GetSysPayrollPrice(entities, iDTO.SysPayrollPriceViews, actorCompanyId, sysTermId, date, iDTO.SysCountryId);

                        if (sysPayrollPrice != null)
                        {
                            formula = Regex.Replace(formula, pattern, sysPayrollPrice.Code, RegexOptions.IgnoreCase);

                            switch ((TermGroup_SysPayrollPriceType)sysPayrollPrice.Type)
                            {
                                case TermGroup_SysPayrollPriceType.SystemPrice:
                                    #region System price

                                    if (sysPayrollPrice.AmountType == (int)TermGroup_SysPayrollPriceAmountType.Percent)
                                        value = sysPayrollPrice.Amount / 100;
                                    else
                                        value = sysPayrollPrice.Amount;
                                    break;

                                #endregion
                                case TermGroup_SysPayrollPriceType.RecordRelatedValue:
                                    #region Record related value

                                    EmployeeVacationSE employeeVacationSE;

                                    switch ((TermGroup_SysPayrollPrice)sysPayrollPrice.SysTermId)
                                    {
                                        #region Common

                                        case TermGroup_SysPayrollPrice.SE_InputValue:
                                            #region Ingående värde

                                            if (inputValue.HasValue)
                                                value = inputValue.Value;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_CalenderDaysInPeriod:
                                            #region Kalenderdagar i period

                                            bool averageCalculated = payrollProduct?.AverageCalculated ?? false;

                                            TimePeriod timePeriod = null;
                                            if (iDTO.TimePeriods == null)
                                                timePeriod = TimePeriodManager.GetTimePeriod(entities, actorCompanyId, date, employment, iDTO.PayrollGroups, usePayrollDate: averageCalculated);
                                            else
                                                timePeriod = TimePeriodManager.GetTimePeriod(entities, iDTO.TimePeriods.Where(x => !x.ExtraPeriod).ToList(), actorCompanyId, employment, date, averageCalculated, iDTO.PayrollGroups);

                                            if (timePeriod != null)
                                            {
                                                if (averageCalculated && timePeriod.PayrollStartDate.HasValue && timePeriod.PayrollStopDate.HasValue)
                                                    value = (decimal)(timePeriod.PayrollStopDate.Value.Date.AddDays(1) - timePeriod.PayrollStartDate.Value.Date).TotalDays;
                                                else
                                                    value = (decimal)(timePeriod.StopDate.Date.AddDays(1) - timePeriod.StartDate.Date).TotalDays;
                                            }
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_WorkDaysInPeriod:
                                            #region Arbetsdagar i period

                                            value = GetNbrOfWorkDaysInPeriod(entities, actorCompanyId, employeeId, date);
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_WorkTimeInHoursInPeriod:
                                            #region Arbetade timmar i perioden

                                            value = GetWorkTimeInHoursInPeriod(entities, actorCompanyId, employeeId, date);

                                            break;
                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_SalaryPromotedAbsenceInPeriod:
                                            #region Semestergrundande frånvaro i perioden

                                            value = GetWorkTimeInHoursInPeriod(entities, actorCompanyId, employeeId, date);
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmploymentDaysInPeriod:
                                            #region Anställningsdagar i period

                                            value = GetNbrOfEmploymentDaysInPeriod(entities, actorCompanyId, employeeType, date);
                                            break;

                                        #endregion

                                        #endregion

                                        #region Schedule

                                        case TermGroup_SysPayrollPrice.SE_ScheduledHoursInPeriod:
                                            value = GetScheduleHoursInPeriod(entities, actorCompanyId, employeeId, date);
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_StandbyHoursInPeriod:
                                            value = GetScheduleHoursInPeriod(entities, actorCompanyId, employeeId, date, standby: true);
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_ScheduleTimeNoScheduleAccordingToScheduleType:
                                            value = GetScheduleHoursInPeriod(entities, actorCompanyId, employeeId, date, timeScheduleTypeIsNotScheduleTime: true);
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_ScheduledHoursInPeriodWithFactorFromScheduleType:
                                            value = GetScheduleHoursInPeriod(entities, actorCompanyId, employeeId, date, includeFactor: true);
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_ScheduleWorkTimeWeekDays:
                                            value = GetScheduleDaysInWeek(entities, actorCompanyId, employeeId, date);
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_ScheduleWorkTimeInWeek:
                                            value = GetScheduleHoursInWeek(entities, actorCompanyId, employeeId, date, includeFactor: true);
                                            break;

                                        #endregion

                                        #region Template schedule
                                        case TermGroup_SysPayrollPrice.SE_TemplateScheduleGrossTimeHolidaySalary:
                                            value = GetTemplateScheduleGrossTime(entities, actorCompanyId, employeeId, date, true);
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_TemplateScheduleGrossTime:
                                            value = GetTemplateScheduleGrossTime(entities, actorCompanyId, employeeId, date, false);
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_TemplateScheduleGrossCostHolidaySalary:
                                            value = GetTemplateScheduleGrossTimeCost(entities, actorCompanyId, employeeId, date, true);
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_TemplateScheduleGrossCost:
                                            value = GetTemplateScheduleGrossTimeCost(entities, actorCompanyId, employeeId, date, false);
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_TemplateScheduleWorkDayAverage:
                                            value = GetTemplateScheduleWorkDayAverage(entities, actorCompanyId, employeeId, date);
                                            break;

                                        #endregion

                                        #region EmployeeGroup

                                        case TermGroup_SysPayrollPrice.SE_EmployeeGroup_WorkTimeWeek:
                                            #region Arbetstimmar per vecka

                                            EmployeeGroup group = employment?.GetEmployeeGroup(date, iDTO.EmployeeGroups);
                                            value = group != null ? Decimal.Divide(group.RuleWorkTimeWeek, 60) : 0;
                                            break;


                                        #endregion

                                        #endregion

                                        #region PayrollGroup

                                        case TermGroup_SysPayrollPrice.SE_PayrollGroup_DivisorHourlyWagesByMonthlyWages:
                                            #region Divisor timlön vid månadslön

                                            int? payrollGroupId = null;
                                            if (groupFormula != null)
                                                payrollGroupId = groupFormula.PayrollGroupId;
                                            else if (employment != null)
                                                payrollGroupId = employment.GetPayrollGroupId(date);
                                            if (payrollGroupId.HasValue)
                                            {
                                                PayrollGroupSetting setting = GetPayrollGroupSetting(entities, payrollGroupId.Value, PayrollGroupSettingType.MonthlyWorkTime, payrollGroups: iDTO?.PayrollGroups);
                                                if (setting != null && setting.DecimalData.HasValue)
                                                    value = setting.DecimalData.Value;
                                            }
                                            break;

                                        #endregion

                                        #endregion

                                        #region Employee

                                        case TermGroup_SysPayrollPrice.SE_Employee_WorkTimeWeek:
                                            #region Veckoarbetstid

                                            value = employment != null ? Decimal.Divide(employment.GetWorkTimeWeek(date), 60) : 0;

                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_Employee_WorkPercentage:
                                            #region Sysselsättningsgrad

                                            value = employment != null ? Decimal.Divide(employment.GetPercent(date), 100) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_Employee_Age:
                                        case TermGroup_SysPayrollPrice.SE_Employee_AgeMonths:
                                            #region Anställd ålder   

                                            Employee employee = entities.Employee.Include("ContactPerson").FirstOrDefault(f => f.EmployeeId == employeeId);
                                            if (employee != null && !string.IsNullOrEmpty(employee.SocialSec))
                                            {
                                                DateTime? birthDate = CalendarUtility.GetBirthDateFromSecurityNumber(employee.SocialSec);
                                                if (birthDate.HasValue)
                                                {
                                                    if ((TermGroup_SysPayrollPrice)sysPayrollPrice.SysTermId == TermGroup_SysPayrollPrice.SE_Employee_Age)
                                                        value = CalendarUtility.AgeYears(birthDate.Value, date);
                                                    else if ((TermGroup_SysPayrollPrice)sysPayrollPrice.SysTermId == TermGroup_SysPayrollPrice.SE_Employee_AgeMonths)
                                                        value = CalendarUtility.AgeMonths(birthDate.Value, date);
                                                }
                                            }

                                            #endregion
                                            break;

                                        #endregion

                                        #region EmployeeFactor

                                        case TermGroup_SysPayrollPrice.SE_EmployeeFactor_CalenderDayFactor:
                                            #region Kalenderdagsfaktor
                                            value = employeeId != 0 ? EmployeeManager.GetEmployeeFactor(entities, employeeId, TermGroup_EmployeeFactorType.CalendarDayFactor, date, iDTO.GetEmployeeFactors(employeeId)) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeFactor_VacationCoefficient:
                                            #region Semesterkoefficient

                                            value = employeeId != 0 ? EmployeeManager.GetEmployeeFactor(entities, employeeId, TermGroup_EmployeeFactorType.VacationCoefficient, date, iDTO.GetEmployeeFactors(employeeId)) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeFactor_VacationDayPercent:
                                            #region Semesterlön per dag

                                            value = employeeId != 0 ? EmployeeManager.GetEmployeeFactor(entities, employeeId, TermGroup_EmployeeFactorType.VacationDayPercent, date, iDTO.GetEmployeeFactors(employeeId)) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeFactor_VacationHourPercent:
                                            #region Semesterlön per timme

                                            value = employeeId != 0 ? EmployeeManager.GetEmployeeFactor(entities, employeeId, TermGroup_EmployeeFactorType.VacationHourPercent, date, iDTO.GetEmployeeFactors(employeeId)) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeFactor_VacationDayPercentFinalSalary:
                                            #region Semesterlön slutlön

                                            value = employeeId != 0 ? EmployeeManager.GetEmployeeFactor(entities, employeeId, TermGroup_EmployeeFactorType.VacationDayPercentFinalSalary, date, iDTO.GetEmployeeFactors(employeeId)) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeFactor_VacationVariablePercent:
                                            #region Semestertillägg rörligt

                                            value = employeeId != 0 ? EmployeeManager.GetEmployeeFactor(entities, employeeId, TermGroup_EmployeeFactorType.VacationVariablePercent, date, iDTO.GetEmployeeFactors(employeeId)) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeFactor_Net:
                                            #region Netto dagare

                                            value = employeeId != 0 ? EmployeeManager.GetEmployeeFactor(entities, employeeId, TermGroup_EmployeeFactorType.Net, date, iDTO.GetEmployeeFactors(employeeId)) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeFactor_VacationVariableAmountPerDay:
                                            #region Semestertillägg rörligt per dag

                                            value = employeeId != 0 ? EmployeeManager.GetEmployeeFactor(entities, employeeId, TermGroup_EmployeeFactorType.VacationVariableAmountPerDay, date, iDTO.GetEmployeeFactors(employeeId)) : 0;
                                            break;

                                        #endregion

                                        case TermGroup_SysPayrollPrice.SE_EmployeeFactor_TimeWorkAccount_PaidLeave:
                                            #region Betald ledighet per timme (ATK)

                                            value = employeeId != 0 ? EmployeeManager.GetEmployeeFactor(entities, employeeId, TermGroup_EmployeeFactorType.TimeWorkAccountPaidLeave, date, iDTO.GetEmployeeFactors(employeeId)) : 0;
                                            break;

                                        #endregion

                                        #endregion

                                        #region EmployeeVacation

                                        case TermGroup_SysPayrollPrice.SE_EmployeeVacation_WorkPercentage_EarningYear:
                                            #region Sysselsättningsgrad intjänandeår

                                            employeeVacationSE = EmployeeManager.GetLatestEmployeeVacationSE(entities, employeeId);
                                            value = employeeVacationSE != null ? Decimal.Divide(employeeVacationSE.EmploymentRatePaid ?? 0, 100) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeVacation_WorkPercentage_SavedYear1:
                                            #region Sysselsättningsgrad sparad år 1

                                            employeeVacationSE = EmployeeManager.GetLatestEmployeeVacationSE(entities, employeeId);
                                            value = employeeVacationSE != null ? Decimal.Divide(employeeVacationSE.EmploymentRateYear1 ?? 0, 100) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeVacation_WorkPercentage_SavedYear2:
                                            #region Sysselsättningsgrad sparad år 2

                                            employeeVacationSE = EmployeeManager.GetLatestEmployeeVacationSE(entities, employeeId);
                                            value = employeeVacationSE != null ? Decimal.Divide(employeeVacationSE.EmploymentRateYear2 ?? 0, 100) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeVacation_WorkPercentage_SavedYear3:
                                            #region Sysselsättningsgrad sparad år 3

                                            employeeVacationSE = EmployeeManager.GetLatestEmployeeVacationSE(entities, employeeId);
                                            value = employeeVacationSE != null ? Decimal.Divide(employeeVacationSE.EmploymentRateYear3 ?? 0, 100) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeVacation_WorkPercentage_SavedYear4:
                                            #region Sysselsättningsgrad sparad år 4

                                            employeeVacationSE = EmployeeManager.GetLatestEmployeeVacationSE(entities, employeeId);
                                            value = employeeVacationSE != null ? Decimal.Divide(employeeVacationSE.EmploymentRateYear4 ?? 0, 100) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeVacation_WorkPercentage_SavedYear5:
                                            #region Sysselsättningsgrad sparad år 5

                                            employeeVacationSE = EmployeeManager.GetLatestEmployeeVacationSE(entities, employeeId);
                                            value = employeeVacationSE != null ? Decimal.Divide(employeeVacationSE.EmploymentRateYear5 ?? 0, 100) : 0;
                                            break;

                                        #endregion
                                        case TermGroup_SysPayrollPrice.SE_EmployeeVacation_WorkPercentage_SavedOverdue:
                                            #region Sysselsättningsgrad förfallna dagar

                                            employeeVacationSE = EmployeeManager.GetLatestEmployeeVacationSE(entities, employeeId);
                                            value = employeeVacationSE != null ? Decimal.Divide(employeeVacationSE.EmploymentRateOverdue ?? 0, 100) : 0;
                                            break;

                                        #endregion

                                        #endregion

                                        #region Absence

                                        case TermGroup_SysPayrollPrice.SE_EmployeeAbsence_AbsenceEntirePeriod:
                                            value = Convert.ToDecimal(IsAbsenceEntirePeriod(entities, actorCompanyId, employeeId, employeeType, date, iDTO?.TimePeriods));
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_EmployeeAbsence_AbsencePercentOfDay:
                                            bool hasPresence = false;
                                            DateTime checkedBackTo = date;
                                            value = Convert.ToDecimal(GetAbsencePercentOfDay(entities, iDTO, actorCompanyId, employeeId, date, payrollProduct, ref hasPresence, ref checkedBackTo));
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_EmployeeAbsence_AbsencePercentPreviousDay:
                                            var dateOfLastAbsence = GetPreviousAbsenceDay(entities, employeeId, date, payrollProduct);
                                            if (dateOfLastAbsence >= date)
                                            {
                                                value = 0;
                                            }
                                            else
                                            {
                                                bool hasPresenceOnPrev = false;
                                                DateTime checkedBackToPrev = dateOfLastAbsence;
                                                value = Convert.ToDecimal(GetAbsencePercentOfDay(entities, iDTO, actorCompanyId, employeeId, dateOfLastAbsence, payrollProduct, ref hasPresenceOnPrev, ref checkedBackToPrev));
                                            }
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_EmployeeAbsence_AbsencePercentNextDay:
                                            var dateOfNextAbsence = GetNextAbsenceDay(entities, employeeId, date, payrollProduct);
                                            if (dateOfNextAbsence == date)
                                            {
                                                //No absence next day
                                                value = 0;
                                            }
                                            else
                                            {
                                                bool hasPresenceOnPrev = false;
                                                DateTime checkedBackToPrev = dateOfNextAbsence;
                                                value = Convert.ToDecimal(GetAbsencePercentOfDay(entities, iDTO, actorCompanyId, employeeId, dateOfNextAbsence, payrollProduct, ref hasPresenceOnPrev, ref checkedBackToPrev));
                                            }
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_EmployeeAbsence_AbsencePercentSameEntirePeriod:
                                            value = Convert.ToDecimal(IsAbsencePercentSameEntirePeriod(entities, actorCompanyId, employeeId, date, payrollProduct, iDTO));
                                            break;
                                        case TermGroup_SysPayrollPrice.SE_EmployeeAbsence_CalculateSicknessSalary:
                                            value = 0;

                                            PayrollGroup payrollGroup = employment.GetPayrollGroup(date, iDTO.PayrollGroups);
                                            if (payrollGroup != null && payrollGroup.TimePeriodHeadId.HasValue)
                                            {
                                                // Get payroll products with setting CalculateSicknessSalary
                                                List<int> payrollProductIds = (from p in entities.Product.OfType<PayrollProduct>()
                                                                               where p.PayrollProductSetting.Any(s => (!s.PayrollGroupId.HasValue || s.PayrollGroupId == payrollGroup.PayrollGroupId) && s.CalculateSicknessSalary)
                                                                               select p.ProductId).ToList();

                                                TimePeriod period = TimePeriodManager.GetTimePeriod(date, payrollGroup.TimePeriodHeadId.Value, actorCompanyId);
                                                value = CalculateSicknessSalary(entities, employment, date, period, payrollProductIds);
                                            }
                                            break;

                                            #endregion
                                    }
                                    break;

                                    #endregion
                            }

                            AddToIdentifiers(identifiers, sysPayrollPrice.Code, value);
                            AddToIdentifierNames(identifierNames, sysPayrollPrice.Code, sysPayrollPrice.Name);
                            AddToIdentifierOrigins(identifierOrigins, sysPayrollPrice.Code, "SysPayrollPrice");
                        }
                    }

                    #endregion
                }
            }

            #endregion

            #region  Create result

            formulaResult.Amount = EvaluateFormulaValue(formula, identifiers);
            formulaResult.Formula = priceFormula.Formula;
            formulaResult.FormulaPlain = priceFormula.FormulaPlain;

            // Get formula in readable format (replace identifiers with actual values)
            // We need to sort the codes in the identifiers and replace longest codes first,
            // Otherwise a shorter code may replace part of a longer code.
            // Eg: If formula contains both KALDAG and KALDAGF, we need to replace KALDAGF first.
            formulaResult.FormulaExtracted = formula;
            formulaResult.FormulaNames = priceFormula.FormulaPlain;
            formulaResult.FormulaOrigin = priceFormula.FormulaPlain;

            // Get all codes
            List<string> identifierCodes = new List<string>();
            Dictionary<string, string> tmpIdentifierCodes = new Dictionary<string, string>();
            int tmpCounter = 0;
            foreach (string identifier in identifiers)
            {
                var items = identifier.Split('=');
                identifierCodes.Add(items[0]);
                tmpIdentifierCodes.Add(items[0], String.Format("TEMP_IDENTIFIER_CODE_{0}", ++tmpCounter));
            }

            // Sort codes
            IEnumerable<string> identifierCodesSorted = StringUtility.SortByLength(identifierCodes, false);
            // Loop through codes, longest first
            foreach (string code in identifierCodesSorted)
            {
                // Get identifier with current code
                string identifier = identifiers.FirstOrDefault(i => i.Contains(code));
                if (!String.IsNullOrEmpty(identifier))
                {
                    // Replace identifiers with actual values
                    var items = identifier.Split('=');
                    formulaResult.FormulaExtracted = formulaResult.FormulaExtracted.Replace(items[0], items[1]);

                    // Replace codes with names
                    KeyValuePair<string, string>? identifierName = identifierNames.FirstOrDefault(i => i.Key == items[0]);
                    if (identifierName != null)
                        formulaResult.FormulaNames = formulaResult.FormulaNames.Replace(identifierName.Value.Key, identifierName.Value.Value);

                    // Get formula with origin (what entity did the value come from)
                    KeyValuePair<string, string>? identifierOrigin = identifierOrigins.FirstOrDefault(i => i.Key == items[0]);
                    if (identifierOrigin != null)
                    {
                        // Replace code with temp name, since it will not be compleately replaced here
                        string tmpIdentifierCode = tmpIdentifierCodes.First(t => t.Key == code).Value;
                        formulaResult.FormulaOrigin = formulaResult.FormulaOrigin.Replace(identifierOrigin.Value.Key, String.Format("{0} ({1})", tmpIdentifierCode, identifierOrigin.Value.Value));
                    }
                }
            }

            // Finally replace the temp names back to its actual codes
            foreach (KeyValuePair<string, string> tmpIdentifierCode in tmpIdentifierCodes)
            {
                formulaResult.FormulaOrigin = formulaResult.FormulaOrigin.Replace(tmpIdentifierCode.Value, tmpIdentifierCode.Key);
            }

            #endregion

            return formulaResult;
        }

        #region Help-methods

        private TimePeriodDTO GetTimePeriodDTO(CompEntities entities, DateTime date, TermGroup_TimePeriodType periodType, int actorCompanyId, bool loadTimePeriodHead = false, List<TimePeriod> timePeriods = null, bool allowExtraPeriod = true)
        {
            string key = $"GetTimePeriodDTO#{date}#{periodType}#{actorCompanyId}#{loadTimePeriodHead}#{allowExtraPeriod}";
            var dto = BusinessMemoryCache<TimePeriodDTO>.Get(key);
            if (dto == null)
            {
                TimePeriod timePeriod = TimePeriodManager.GetTimePeriod(entities, date, TermGroup_TimePeriodType.Payroll, actorCompanyId, timePeriods: timePeriods, allowExtraPeriod: allowExtraPeriod);
                if (timePeriod != null)
                    dto = timePeriod.ToDTO();
            }

            if (dto != null)
                BusinessMemoryCache<TimePeriodDTO>.Set(key, dto, 60);

            return dto;
        }

        private List<TimePayrollTypeSumDTO> GetTimePayrollTypeSumsForPeriod(CompEntities entities, TimePeriodDTO period, int employeeId)
        {
            string key = $"TimePayrollTypeSumDTOsForPeriod#{period.TimePeriodHeadId}#{period.TimePeriodId}#{employeeId}";

            var dtos = BusinessMemoryCache<List<TimePayrollTypeSumDTO>>.Get(key);
            if (dtos != null)
                return dtos;

            dtos = (from t in entities.TimePayrollTransaction
                    where t.TimeBlockDate.Date >= period.StartDate &&
                    t.TimeBlockDate.Date <= period.StopDate &&
                    t.EmployeeId == employeeId &&
                    t.TimeBlockDate.EmployeeId == employeeId &&
                    t.State == (int)SoeEntityState.Active &&
                    t.TimePeriodId == null
                    select new TimePayrollTypeSumDTO
                    {
                        VacationYearEndRowId = t.VacationYearEndRowId,
                        SysPayrollTypeLevel1 = t.SysPayrollTypeLevel1,
                        SysPayrollTypeLevel2 = t.SysPayrollTypeLevel2,
                        SysPayrollTypeLevel3 = t.SysPayrollTypeLevel3,
                        SysPayrollTypeLevel4 = t.SysPayrollTypeLevel4,
                        Quantity = t.Quantity
                    }).ToList();

            BusinessMemoryCache<List<TimePayrollTypeSumDTO>>.Set(key, dtos, 60);
            return dtos;
        }

        private int GetNbrOfWorkDaysInPeriod(CompEntities entities, int actorCompanyId, int employeeId, DateTime date)
        {
            var period = GetTimePeriodDTO(entities, date, TermGroup_TimePeriodType.Payroll, actorCompanyId, allowExtraPeriod: false);
            if (period == null || period.StartDate > period.StopDate)
                return 0;

            string key = $"GetNbrOfWorkDaysInPeriod#{period.TimePeriodHeadId}#{period.TimePeriodId}#{employeeId}";

            int? value = BusinessMemoryCache<int?>.Get(key);
            if (value.HasValue)
                return value.Value;

            // Get work schedule blocks for period
            value = (from tb in entities.TimeScheduleTemplateBlock
                     where tb.EmployeeId == employeeId &&
                     tb.Date >= period.StartDate && tb.Date <= period.StopDate &&
                     tb.StartTime != tb.StopTime &&
                     tb.BreakType == (int)SoeTimeScheduleTemplateBlockBreakType.None &&
                     tb.State == (int)SoeEntityState.Active &&
                     (tb.TimeScheduleTypeId == null || !tb.TimeScheduleType.IsNotScheduleTime) &&
                     !tb.TimeScheduleScenarioHeadId.HasValue
                     group tb by tb.Date into grp
                     select new { Date = grp.Key }).Count();

            BusinessMemoryCache<int?>.Set(key, value.Value, 60);
            return value.Value;
        }

        private int GetNbrOfEmploymentDaysInPeriod<T>(CompEntities entities, int actorCompanyId, T employeeType, DateTime date)
        {
            var period = GetTimePeriodDTO(entities, date, TermGroup_TimePeriodType.Payroll, actorCompanyId, allowExtraPeriod: false);
            if (period == null || period.StartDate > period.StopDate)
                return 0;

            Employee employee = null;
            void LoadEmployee(int employeeId) => employee = EmployeeManager.GetEmployee(entities, employeeId, actorCompanyId, onlyActive: true, loadEmployment: true);

            if (employeeType is Employee emp)
            {
                if (emp != null && !emp.Employment.IsLoaded)
                    LoadEmployee(emp.EmployeeId);
                employee = emp;
            }
            else if (employeeType is int)
                LoadEmployee(Convert.ToInt32(employeeType));

            if (employee == null || !employee.HasActiveEmployments())
                return 0;

            int nbrOfEmploymentDays = 0;
            DateTime currentDate = period.StartDate;
            while (currentDate <= period.StopDate)
            {
                if (employee.HasEmployment(currentDate))
                    nbrOfEmploymentDays++;
                currentDate = currentDate.AddDays(1);
            }
            return nbrOfEmploymentDays;
        }

        private int GetScheduleDaysInWeek(CompEntities entities, int actorCompanyId, int employeeId, DateTime date, bool standby = false, bool timeScheduleTypeIsNotScheduleTime = false)
        {
            List<DateTime> dates = new List<DateTime>();

            var week = CalendarUtility.GetWeek(date);
            string key = $"GetScheduledTimeInInterval#{actorCompanyId}#{employeeId}#{week.DateFrom}#{week.DateTo}";
            List<TimeScheduleTemplateBlock> scheduleBlocks = BusinessMemoryCache<List<TimeScheduleTemplateBlock>>.Get(key);
            if (scheduleBlocks == null)
            {
                scheduleBlocks = TimeScheduleManager.GetTimeScheduleTemplateBlocks(entities, employeeId, week.DateFrom, week.DateTo, includeBreaks: true, includePrel: true);
                BusinessMemoryCache<List<TimeScheduleTemplateBlock>>.Set(key, scheduleBlocks, 20);
            }

            if (!scheduleBlocks.IsNullOrEmpty())
            {
                List<TimeScheduleTypeDTO> timeScheduleTypes = scheduleBlocks.Any(s => s.TimeScheduleTypeId.HasValue) ? base.GetTimeScheduleTypesFromCache(entities, CacheConfig.Company(actorCompanyId), loadFactors: true).ToDTOs(true).ToList() : null;

                foreach (var scheduleBlocksByDate in scheduleBlocks.Where(b => b.Date.HasValue).GroupBy(b => b.Date.Value))
                {
                    List<TimeScheduleTemplateBlock> scheduleBlocksForDate = scheduleBlocksByDate.ToList();
                    foreach (TimeScheduleTemplateBlock scheduleBlock in scheduleBlocksForDate.GetWork(skipZero: true))
                    {
                        if (standby && !scheduleBlock.IsStandby())
                            continue;
                        if (!timeScheduleTypeIsNotScheduleTime && scheduleBlock.IsNotScheduleTime(timeScheduleTypes))
                            continue;

                        dates.Add(scheduleBlocksByDate.Key);
                        break;
                    }
                }
            }

            return dates.Distinct().Count();
        }

        private decimal GetWorkTimeInHoursInPeriod(CompEntities entities, int actorCompanyId, int employeeId, DateTime date)
        {
            var period = GetTimePeriodDTO(entities, date, TermGroup_TimePeriodType.Payroll, actorCompanyId, allowExtraPeriod: false);
            if (period == null || period.StartDate > period.StopDate)
                return 0;

            var transactions = GetTimePayrollTypeSumsForPeriod(entities, period, employeeId);
            decimal minutes = transactions.Where(w => w.IsWorkTime()).Sum(i => i.Quantity);
            return decimal.Round(decimal.Divide(minutes, 60), 2);
        }

        private decimal GetScheduleHoursInWeek(CompEntities entities, int actorCompanyId, int employeeId, DateTime date, bool standby = false, bool includeFactor = false, bool timeScheduleTypeIsNotScheduleTime = false)
        {
            var week = CalendarUtility.GetWeek(date);
            return GetScheduleHoursInPeriod(entities, actorCompanyId, employeeId, week.DateFrom, week.DateTo, standby, includeFactor, timeScheduleTypeIsNotScheduleTime);
        }

        private decimal GetScheduleHoursInPeriod(CompEntities entities, int actorCompanyId, int employeeId, DateTime date, bool standby = false, bool includeFactor = false, bool timeScheduleTypeIsNotScheduleTime = false)
        {
            TimePeriodDTO period = GetTimePeriodDTO(entities, date, TermGroup_TimePeriodType.Payroll, actorCompanyId, allowExtraPeriod: false);
            if (period == null || period.StartDate > period.StopDate)
                return 0;

            return GetScheduleHoursInPeriod(entities, actorCompanyId, employeeId, period.StartDate, period.StopDate, standby, includeFactor, timeScheduleTypeIsNotScheduleTime);
        }

        private decimal GetScheduleHoursInPeriod(CompEntities entities, int actorCompanyId, int employeeId, DateTime startDate, DateTime stopDate, bool standby = false, bool includeFactor = false, bool timeScheduleTypeIsNotScheduleTime = false)
        {
            decimal totalMinutes = 0;

            string key = $"GetScheduledTimeInInterval#{actorCompanyId}#{employeeId}#{startDate}#{stopDate}";
            List<TimeScheduleTemplateBlock> scheduleBlocks = BusinessMemoryCache<List<TimeScheduleTemplateBlock>>.Get(key);
            if (scheduleBlocks == null)
            {
                scheduleBlocks = TimeScheduleManager.GetTimeScheduleTemplateBlocks(entities, employeeId, startDate, stopDate, includeBreaks: true, includePrel: true);
                BusinessMemoryCache<List<TimeScheduleTemplateBlock>>.Set(key, scheduleBlocks, 20);
            }

            if (!scheduleBlocks.IsNullOrEmpty())
            {
                List<TimeScheduleTypeDTO> timeScheduleTypes = scheduleBlocks.Any(s => s.TimeScheduleTypeId.HasValue) ? base.GetTimeScheduleTypesFromCache(entities, CacheConfig.Company(actorCompanyId), loadFactors: true).ToDTOs(true).ToList() : null;
                bool all = !standby && !timeScheduleTypeIsNotScheduleTime && !includeFactor;

                foreach (var scheduleBlocksByDate in scheduleBlocks.Where(b => b.Date.HasValue && !b.IsOnDuty()).GroupBy(b => b.Date.Value))
                {
                    List<TimeScheduleTemplateBlock> scheduleBlocksForDate = scheduleBlocksByDate.ToList();
                    foreach (TimeScheduleTemplateBlock scheduleBlock in scheduleBlocksForDate.GetWork(skipZero: true))
                    {
                        if (standby && scheduleBlock.IsStandby())
                            AddMinutes();
                        else if (timeScheduleTypeIsNotScheduleTime && scheduleBlock.IsNotScheduleTime(timeScheduleTypes))
                            AddMinutes();
                        else if (includeFactor)
                            AddMinutes(addFactorMinutes: true);
                        else if (all)
                            AddMinutes();

                        void AddMinutes(bool addFactorMinutes = false) => totalMinutes += scheduleBlock.GetTotalMinutes(scheduleBlocksForDate, timeScheduleTypes, addFactorMinutes);
                    }
                }
            }

            if (totalMinutes == 0)
                return 0;
            return decimal.Round(decimal.Divide(totalMinutes, 60), 2);
        }

        private decimal GetTemplateScheduleGrossTime(CompEntities entities, int actorCompanyId, int employeeId, DateTime date, bool holidaySalary)
        {
            List<TimeSchedulePlanningDayDTO> items = TimeScheduleManager.GetTimeSchedulePlanningDaysFromTemplate(entities, actorCompanyId, base.RoleId, base.UserId, date, date, null, employeeId.ObjToList(), null, includeGrossNetAndCost: true, includeEmploymentTaxAndSupplementChargeCost: false, loadTasksAndDelivery: false, doNotCheckHoliday: holidaySalary);
            return items.Sum(s => s.GrossTimeDecimal);
        }

        private decimal GetTemplateScheduleGrossTimeCost(CompEntities entities, int actorCompanyId, int employeeId, DateTime date, bool holidaySalary)
        {
            List<TimeSchedulePlanningDayDTO> items = TimeScheduleManager.GetTimeSchedulePlanningDaysFromTemplate(entities, actorCompanyId, base.RoleId, base.UserId, date, date, null, employeeId.ObjToList(), null, includeGrossNetAndCost: true, includeEmploymentTaxAndSupplementChargeCost: false, loadTasksAndDelivery: false, doNotCheckHoliday: holidaySalary);
            return items.Sum(s => s.TotalCost);
        }

        private decimal GetTemplateScheduleWorkDayAverage(CompEntities entities, int actorCompanyId, int employeeId, DateTime date)
        {
            int timeScheduleTemplatePeriodId = TimeScheduleManager.GetTimeScheduleTemplateBlock(entities, employeeId, date)?.TimeScheduleTemplatePeriodId ?? 0;
            if (timeScheduleTemplatePeriodId == 0)
                return decimal.Zero;

            int timeScheduleTemplateHeadId = TimeScheduleManager.GetTimeScheduleTemplatePeriod(entities, timeScheduleTemplatePeriodId, false, false)?.TimeScheduleTemplateHeadId ?? 0;
            if (timeScheduleTemplateHeadId == 0)
                return decimal.Zero;

            string key = $"TemplateScheduleWDA#{actorCompanyId}#{timeScheduleTemplateHeadId}";
            decimal? templateScheduleWDA = BusinessMemoryCache<decimal?>.Get(key);
            if (templateScheduleWDA.HasValue)
                return templateScheduleWDA.Value;

            TimeScheduleTemplateHead timeScheduleTemplateHead = TimeScheduleManager.GetTimeScheduleTemplateHead(entities, timeScheduleTemplateHeadId, actorCompanyId, false);
            if (timeScheduleTemplateHead == null)
                return decimal.Zero;

            var timeScheduleTemplatePeriods = TimeScheduleManager.GetTimeScheduleTemplatePeriods(entities, timeScheduleTemplateHeadId, false);
            if (!timeScheduleTemplatePeriods.Any())
                return decimal.Zero;

            List<TimeScheduleTemplateBlock> shifts = TimeScheduleManager.GetTimeScheduleTemplateBlocksFromPeriods(entities, employeeId, timeScheduleTemplatePeriods.Select(s => s.TimeScheduleTemplatePeriodId).ToList());
            if (!shifts.Any())
                return decimal.Zero;

            int nbrOfShiftDays = shifts.GroupBy(g => g.TimeScheduleTemplatePeriodId).Count();

            templateScheduleWDA = decimal.Round(decimal.Divide(nbrOfShiftDays, (timeScheduleTemplateHead.NoOfDays / 7)), 2);
            BusinessMemoryCache<decimal?>.Set(key, templateScheduleWDA, 60);

            return templateScheduleWDA.Value;
        }

        private bool IsPayrollPriceFormulaInUse(int payrollPriceFormulaId)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            if (entitiesReadOnly.PayrollGroupPriceFormula.Any(p => p.PayrollPriceFormulaId == payrollPriceFormulaId && p.State == (int)SoeEntityState.Active))
                return true;

            if (entitiesReadOnly.PayrollProductPriceFormula.Any(p => p.PayrollPriceFormulaId == payrollPriceFormulaId && p.State == (int)SoeEntityState.Active))
                return true;

            if (entitiesReadOnly.VacationGroupSE.Any(p => p.MonthlySalaryFormulaId == payrollPriceFormulaId && p.VacationGroup.State == (int)SoeEntityState.Active))
                return true;

            if (entitiesReadOnly.VacationGroupSE.Any(p => p.HourlySalaryFormulaId == payrollPriceFormulaId && p.VacationGroup.State == (int)SoeEntityState.Active))
                return true;

            return false;
        }

        private bool IsPayrollPriceFormulaInUseInFormula(int payrollPriceFormulaId, int actorCompanyId)
        {
            return ExistsValueInPayrollPriceFormula(String.Format("PF{0}", payrollPriceFormulaId), actorCompanyId);
        }

        private bool ExistsValueInPayrollPriceFormula(string value, int actorCompanyId)
        {
            // Check if price type exists in a formula
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollPriceFormula.NoTracking();
            var formulas = (from f in entities.PayrollPriceFormula
                            where f.ActorCompanyId == actorCompanyId &&
                            f.Formula.Contains(value) &&
                            f.State == (int)SoeEntityState.Active
                            select f).ToList();

            if (formulas.Any())
            {
                // Loop througt each matching formula to check exact word.
                // Because the query above will return a formula that contains for example PT10 even if we look for PT1.
                foreach (var formula in formulas)
                {
                    // Split on each entry (word) in formula
                    var matches = Regex.Matches(formula.Formula, @"\w+");
                    foreach (Match match in matches)
                    {
                        if (match.Value.Equals(value))
                            return true;
                    }
                }
            }

            return false;
        }

        private bool IsAbsenceEntirePeriod<T>(CompEntities entities, int actorCompanyId, int employeeId, T employeeType, DateTime date, List<TimePeriod> timePeriods = null)
        {
            // Get TimePeriod
            var period = GetTimePeriodDTO(entities, date, TermGroup_TimePeriodType.Payroll, actorCompanyId, timePeriods: timePeriods, allowExtraPeriod: false);
            if (period == null || period.StartDate > period.StopDate)
                return false;

            string key = $"AbsenceEntirePeriod#{actorCompanyId}#{employeeId}#{period.TimePeriodId}";
            bool? absenceEntirePeriod = BusinessMemoryCache<bool?>.Get(key);
            if (absenceEntirePeriod.HasValue)
                return absenceEntirePeriod.Value;

            bool result = true;

            if (IsEndingEmploymentInPeriod(entities, actorCompanyId, employeeId, employeeType, period))
            {
                result = false;
            }
            else
            {
                var transactions = (from t in entities.TimePayrollTransaction
                                    where t.TimeBlockDate.Date >= period.StartDate &&
                                    t.TimeBlockDate.Date <= period.StopDate &&
                                    t.EmployeeId == employeeId &&
                                    t.State == (int)SoeEntityState.Active &&
                                    (!t.TimeBlockId.HasValue || t.TimeBlock.State == (int)SoeEntityState.Active)
                                    select new TimePayrollTypeSumDTO
                                    {
                                        VacationYearEndRowId = t.VacationYearEndRowId,
                                        SysPayrollTypeLevel1 = t.SysPayrollTypeLevel1,
                                        SysPayrollTypeLevel2 = t.SysPayrollTypeLevel2,
                                        SysPayrollTypeLevel3 = t.SysPayrollTypeLevel3,
                                        SysPayrollTypeLevel4 = t.SysPayrollTypeLevel4,
                                        IsAdded = t.IsAdded,
                                    }).ToList();

                transactions = transactions.Where(t => !t.IsAdded && !t.VacationYearEndRowId.HasValue).ToList();


                foreach (var transaction in transactions)
                {
                    if (transaction.IsWork() || transaction.IsTimeScheduledTime())
                        result = false;
                }
            }

            BusinessMemoryCache<bool?>.Set(key, result, 2);

            return result;
        }

        private bool IsEndingEmploymentInPeriod<T>(CompEntities entities, int actorCompanyId, int employeeId, T employeeType, TimePeriodDTO period)
        {
            if (period == null || period.ExtraPeriod)
                return false;

            Employee employee = null;
            if (employeeType is Employee emp && emp.Employment.IsLoaded && !emp.Employment.IsNullOrEmpty())
                employee = emp;
            if (employee == null)
                employee = EmployeeManager.GetEmployee(entities, employeeId, actorCompanyId, onlyActive: true, loadEmployment: true);

            var lastEmployment = employee.GetLastEmployment();
            return lastEmployment != null && lastEmployment.DateTo >= period.StartDate && lastEmployment.DateTo < period.StopDate;
        }

        public bool IsAbsencePercentSameEntirePeriod(CompEntities entities, int actorCompanyId, int employeeId, DateTime date, PayrollProduct payrollProduct, EvaluatePayrollPriceFormulaInputDTO iDTO)
        {
            if (payrollProduct == null || !payrollProduct.IsAbsence())
                return false;

            TimePeriodDTO period = GetTimePeriodDTO(entities, date, TermGroup_TimePeriodType.Payroll, actorCompanyId, allowExtraPeriod: false);
            if (period == null || period.StartDate > period.StopDate)
                return false;

            string key = $"AbsencePercentSameEntirePeriod#{actorCompanyId}#{employeeId}#{period.TimePeriodId}#{payrollProduct.ProductId}";
            bool? absenceEntirePeriod = BusinessMemoryCache<bool?>.Get(key);
            if (absenceEntirePeriod.HasValue)
                return absenceEntirePeriod.Value;

            DateTime lookDate = period.StopDate;
            List<decimal> percents = new List<decimal>();
            DateTime checkedBackTo = lookDate;

            bool result = true;

            while (lookDate >= period.StartDate)
            {
                if (percents.Distinct().Count() > 1)
                {
                    result = false;
                    break;
                }

                bool hasPresence = false;
                decimal percent = decimal.Round(GetAbsencePercentOfDay(entities, iDTO, actorCompanyId, employeeId, lookDate, payrollProduct, ref hasPresence, ref checkedBackTo, doExitOnZeroPresenceDays: true, maxLookBackDate: period.StartDate), 2, MidpointRounding.AwayFromZero);
                lookDate = checkedBackTo;

                if (!percents.Any(p => p == percent) && percent > 0)
                {
                    percents.Add(percent);
                }
                else if (percent == 0 && hasPresence)
                {
                    result = false;
                    break;
                }
                lookDate = lookDate.AddDays(-1);
            }

            if (percents.Count(p => p == 0) == percents.Count)
                result = false;

            BusinessMemoryCache<bool?>.Set(key, result, 10);

            return result;
        }

        public decimal GetAbsencePercentOfDay(CompEntities entities, EvaluatePayrollPriceFormulaInputDTO iDTO, int actorCompanyId, int employeeId, DateTime date, PayrollProduct payrollProduct, ref bool hasPresence, ref DateTime checkedBackTo, bool doExitOnZeroPresenceDays = false, DateTime? maxLookBackDate = null)
        {
            if (payrollProduct == null)
                return 0;

            maxLookBackDate = maxLookBackDate ?? date.AddDays(-100);
            bool isAbsence = payrollProduct.IsAbsence();

            decimal absencePercentOfDay = 0;
            while (date >= maxLookBackDate && absencePercentOfDay == 0)
            {
                checkedBackTo = date;
                if (iDTO.ContainsEmployeeAbsencePercent(employeeId, date, payrollProduct.SysPayrollTypeLevel1, payrollProduct.SysPayrollTypeLevel2, payrollProduct.SysPayrollTypeLevel3))
                {
                    absencePercentOfDay = iDTO.GetEmployeeAbsencePercentValue(employeeId, date, payrollProduct.SysPayrollTypeLevel1, payrollProduct.SysPayrollTypeLevel2, payrollProduct.SysPayrollTypeLevel3);
                }
                else
                {
                    absencePercentOfDay = GetAbsencePercentOfOneDay(entities, actorCompanyId, employeeId, date, payrollProduct, ref hasPresence, isAbsence);
                    iDTO.AddEmployeeAbsencePercent(employeeId, payrollProduct.ProductId, date, absencePercentOfDay, payrollProduct.SysPayrollTypeLevel1, payrollProduct.SysPayrollTypeLevel2, payrollProduct.SysPayrollTypeLevel3);
                    if (doExitOnZeroPresenceDays && absencePercentOfDay == 0 && hasPresence)
                        return absencePercentOfDay;
                }
                date = date.AddDays(-1);
            }

            return absencePercentOfDay;
        }

        private decimal GetAbsencePercentOfOneDay(CompEntities entities, int actorCompanyId, int employeeId, DateTime date, PayrollProduct payrollProduct, ref bool hasPresence, bool onlyAbsence = true)
        {
            TimeBlockDate timeBlockDate = TimeBlockManager.GetTimeBlockDate(entities, actorCompanyId, employeeId, date);
            if (timeBlockDate == null)
                return 0;

            decimal? ratio = timeBlockDate.GetTimeBlockDateDetailRatioFromPayrollType(payrollProduct.SysPayrollTypeLevel3 ?? 0);
            if (ratio.HasValue)
                return ratio.Value == 0 ? ratio.Value : decimal.Round(ratio.Value / 100, 2, MidpointRounding.AwayFromZero);

            decimal scheduleMinutes = TimeScheduleManager.GetScheduleMinutes(entities, actorCompanyId, employeeId, date);
            if (scheduleMinutes == 0)
                return 0;

            var transactionsForDay = (from t in entities.TimePayrollTransaction
                                      where t.TimeBlockDateId == timeBlockDate.TimeBlockDateId &&
                                      t.State == (int)SoeEntityState.Active &&
                                      (!t.TimeBlockId.HasValue || t.TimeBlock.State == (int)SoeEntityState.Active)
                                      select new
                                      {
                                          t.TimeCodeTransactionId,
                                          t.SysPayrollTypeLevel1,
                                          t.SysPayrollTypeLevel2,
                                          t.SysPayrollTypeLevel3,
                                          t.SysPayrollTypeLevel4,
                                          t.Quantity,
                                          t.IsAdded,
                                      }).ToList();

            transactionsForDay = transactionsForDay.Where(x => !x.IsAdded).ToList();
            if (!transactionsForDay.Any())
                return 0;

            var absenceTransactions = (from t in transactionsForDay
                                       where
                                       t.SysPayrollTypeLevel1.HasValue && t.SysPayrollTypeLevel1 == payrollProduct.SysPayrollTypeLevel1 &&
                                       t.SysPayrollTypeLevel2.HasValue && t.SysPayrollTypeLevel2 == payrollProduct.SysPayrollTypeLevel2 &&
                                       t.SysPayrollTypeLevel3.HasValue && t.SysPayrollTypeLevel3 == payrollProduct.SysPayrollTypeLevel3
                                       select t).ToList();

            if (!absenceTransactions.Any() && payrollProduct.IsAbsence_SicknessSalary())
                absenceTransactions = (from t in transactionsForDay
                                       where
                                       t.SysPayrollTypeLevel1.HasValue && t.SysPayrollTypeLevel1 == (int)TermGroup_SysPayrollType.SE_GrossSalary &&
                                       t.SysPayrollTypeLevel2.HasValue && t.SysPayrollTypeLevel2 == (int)TermGroup_SysPayrollType.SE_GrossSalary_Absence &&
                                       t.SysPayrollTypeLevel3.HasValue && t.SysPayrollTypeLevel3 == (int)TermGroup_SysPayrollType.SE_GrossSalary_Absence_Sick
                                       select t).ToList();

            decimal presenceMinutes = transactionsForDay
                .Where(t =>
                    PayrollRulesUtil.IsWork(t.SysPayrollTypeLevel1, t.SysPayrollTypeLevel2, t.SysPayrollTypeLevel3, t.SysPayrollTypeLevel4) ||
                    PayrollRulesUtil.IsTimeScheduledTime(t.SysPayrollTypeLevel1, t.SysPayrollTypeLevel2, t.SysPayrollTypeLevel3, t.SysPayrollTypeLevel4)
                    )
                .Sum(t => t.Quantity);
            decimal absenceMinutes = absenceTransactions
                .Where(t =>
                    !onlyAbsence ||
                    PayrollRulesUtil.IsAbsence(t.SysPayrollTypeLevel1, t.SysPayrollTypeLevel2, t.SysPayrollTypeLevel3, t.SysPayrollTypeLevel4)
                    )
                .Sum(t => t.Quantity);

            decimal percent = decimal.Round(decimal.Divide(absenceMinutes, scheduleMinutes), 4, MidpointRounding.AwayFromZero);
            if (percent > 1)
                percent = 1; //AbsencePercentOfOneDay can not be more than scheduled time

            if (presenceMinutes > 0)
                hasPresence = true;

            return percent;
        }

        private decimal CalculateSicknessSalary(CompEntities entities, Employment employment, DateTime date, TimePeriod period, List<int> payrollProductIds)
        {
            var sicknessTransactions = (from t in entities.TimePayrollTransaction
                                        where t.TimeBlockDate.Date >= period.StartDate &&
                                        t.TimeBlockDate.Date <= period.StopDate &&
                                        t.EmployeeId == employment.EmployeeId &&
                                        t.State == (int)SoeEntityState.Active &&
                                        (!t.TimeBlockId.HasValue || t.TimeBlock.State == (int)SoeEntityState.Active) &&
                                        t.TimePeriodId == null &&
                                        payrollProductIds.Contains(t.ProductId)
                                        select new
                                        {
                                            t.Amount,
                                            Level1 = t.SysPayrollTypeLevel1,
                                            Level2 = t.SysPayrollTypeLevel2,
                                            Level3 = t.SysPayrollTypeLevel3,
                                            Level4 = t.SysPayrollTypeLevel4
                                        }).ToList();

            decimal amount = sicknessTransactions.Sum(t => t.Amount ?? 0);

            var transactions = (from t in entities.TimePayrollTransaction
                                where t.TimeBlockDate.Date >= period.StartDate &&
                                t.TimeBlockDate.Date <= period.StopDate &&
                                t.EmployeeId == employment.EmployeeId &&
                                t.State == (int)SoeEntityState.Active &&
                                (!t.TimeBlockId.HasValue || t.TimeBlock.State == (int)SoeEntityState.Active) &&
                                t.TimePeriodId == null
                                select new TimePayrollTypeSumDTO
                                {
                                    VacationYearEndRowId = t.VacationYearEndRowId,
                                    SysPayrollTypeLevel1 = t.SysPayrollTypeLevel1,
                                    SysPayrollTypeLevel2 = t.SysPayrollTypeLevel2,
                                    SysPayrollTypeLevel3 = t.SysPayrollTypeLevel3,
                                    SysPayrollTypeLevel4 = t.SysPayrollTypeLevel4,
                                    Quantity = t.Quantity,
                                }).ToList();


            transactions = transactions.Where(t => t.IsWorkTime()).ToList();

            decimal hours = Decimal.Divide(transactions.Sum(t => t.Quantity), 60);

            // Veckoarbetstid
            decimal workTimeWeek = 0;
            if (amount != 0 && hours != 0 && employment != null)
                workTimeWeek = Decimal.Divide(employment.GetWorkTimeWeek(date), 60);

            // BUSL = Summa beräkningsunderlag sjuklön / Periodens arbetade timmar (lönetyp) * Veckoarbetstid
            return hours != 0 ? Decimal.Multiply(Decimal.Divide(amount, hours), workTimeWeek) : 0;
        }

        private DateTime GetPreviousAbsenceDay(CompEntities entities, int employeeId, DateTime date, PayrollProduct payrollProduct)
        {
            DateTime startTime = date.AddDays(-5);

            var transactions = (from t in entities.TimePayrollTransaction
                                where t.TimeBlockDate.Date >= startTime &&
                                t.TimeBlockDate.Date < date &&
                                t.EmployeeId == employeeId &&
                                t.ProductId == payrollProduct.ProductId &&
                                t.State == (int)SoeEntityState.Active
                                select new
                                {
                                    t.SysPayrollTypeLevel1,
                                    t.SysPayrollTypeLevel2,
                                    t.SysPayrollTypeLevel3,
                                    t.SysPayrollTypeLevel4,
                                    t.TimeBlockDate.Date,
                                    t.ProductId
                                }).ToList();

            DateTime lastDate = date;

            //Decide the lastest date that has same absence product
            if (transactions.Any(w => w.ProductId == payrollProduct.ProductId))
                lastDate = transactions.Where(w => w.ProductId == payrollProduct.ProductId).OrderBy(o => o.Date).Last().Date;

            //If the last date is not the same as given date or the date before
            if (lastDate != date.AddDays(-1) && lastDate != date)
            {
                //If there is any WORK TIME between the decided last date and the given date, set the last date to the given date
                if (transactions.Any(w => w.Date >= lastDate && w.ProductId != payrollProduct.ProductId && PayrollRulesUtil.IsWorkTime(w.SysPayrollTypeLevel1, w.SysPayrollTypeLevel2, w.SysPayrollTypeLevel3, w.SysPayrollTypeLevel4)))
                    lastDate = date;

                //if decided last date is not the same as given date
                if (lastDate != date)
                {
                    //Look to see if there is NO ABSENCE TIME between the decided last date and the given date, ig no absence time is found set the last date to the given date
                    if (!transactions.All(w => w.Date >= lastDate && PayrollRulesUtil.IsAbsence(w.SysPayrollTypeLevel1, w.SysPayrollTypeLevel2, w.SysPayrollTypeLevel3, w.SysPayrollTypeLevel4)))
                        lastDate = date;
                }
            }

            return lastDate;
        }
        private DateTime GetNextAbsenceDay(CompEntities entities, int employeeId, DateTime date, PayrollProduct payrollProduct)
        {
            DateTime stopTime = date.AddDays(5);

            var transactions = (from t in entities.TimePayrollTransaction
                                where t.TimeBlockDate.Date > date &&
                                t.TimeBlockDate.Date <= stopTime &&
                                t.EmployeeId == employeeId &&
                                t.ProductId == payrollProduct.ProductId &&
                                t.State == (int)SoeEntityState.Active
                                select new
                                {
                                    t.SysPayrollTypeLevel1,
                                    t.SysPayrollTypeLevel2,
                                    t.SysPayrollTypeLevel3,
                                    t.SysPayrollTypeLevel4,
                                    t.TimeBlockDate.Date,
                                    t.ProductId
                                }).ToList();

            DateTime earlistNextDate = date;

            //Decide the earliest next date that has same absence product
            if (transactions.Any(w => w.ProductId == payrollProduct.ProductId))
                earlistNextDate = transactions.Where(w => w.ProductId == payrollProduct.ProductId).OrderBy(o => o.Date).First().Date;

            //If the last date is not the same as given date or the date after that, so there is a gap between the given date and the decided next date
            if (earlistNextDate != date.AddDays(1) && earlistNextDate != date)
            {
                //If there is any WORK TIME in the gap, set the earliest next date to the given date
                if (transactions.Any(w => w.Date <= earlistNextDate && w.ProductId != payrollProduct.ProductId && PayrollRulesUtil.IsWorkTime(w.SysPayrollTypeLevel1, w.SysPayrollTypeLevel2, w.SysPayrollTypeLevel3, w.SysPayrollTypeLevel4)))
                    earlistNextDate = date;

                //if decided last date is not the same as given date
                if (earlistNextDate != date)
                {
                    //Look to see if there is NO ABSENCE TIME between the decided earlist date and the given date, if no absence time is found set the last date to the given date
                    if (!transactions.All(w => w.Date <= earlistNextDate && PayrollRulesUtil.IsAbsence(w.SysPayrollTypeLevel1, w.SysPayrollTypeLevel2, w.SysPayrollTypeLevel3, w.SysPayrollTypeLevel4)))
                        earlistNextDate = date;
                }
            }

            return earlistNextDate;
        }

        private void AddToIdentifiers(List<string> identifiers, string code, decimal amount)
        {
            if (String.IsNullOrEmpty(code))
                return;

            // Check if identifier already exists
            bool exists = false;
            foreach (string identifier in identifiers)
            {
                int pos;
                if ((pos = identifier.IndexOf('=')) > 0)
                {
                    if (identifier.Substring(0, pos).Trim() == code)
                    {
                        exists = true;
                        break;
                    }
                }
            }

            // Add it to the list if it does not exist
            if (!exists)
                identifiers.Add(String.Format("{0}={1}", code, amount));
        }

        private void AddToIdentifierNames(Dictionary<string, string> identifierNames, string code, string name)
        {
            if (!identifierNames.ContainsKey(code))
                identifierNames.Add(code, name);
        }

        private void AddToIdentifierOrigins(Dictionary<string, string> identifierOrigins, string code, string origin)
        {
            if (!identifierOrigins.ContainsKey(code))
                identifierOrigins.Add(code, origin);
        }

        private string ConvertPayrollPriceFormulaToGUI(int actorCompanyId, string formula)
        {
            string[] codes = Regex.Split(formula.Replace(" ", "").ToUpperInvariant(), @"\W");
            foreach (string code in codes.Where(c => c.Length > 0))
            {
                string pattern = @"\b" + code + @"\b";
                int id = 0;

                if (code.StartsWith("PT"))
                {
                    #region PriceType

                    if (Int32.TryParse(code.Substring(2), out id))
                    {
                        using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
                        PayrollPriceTypeDTO payrollPriceType = base.GetPayrollPriceTypeFromCache(entitiesReadOnly, id, CacheConfig.Company(actorCompanyId));
                        if (payrollPriceType != null)
                            formula = Regex.Replace(formula, pattern, payrollPriceType.Code, RegexOptions.IgnoreCase);
                    }

                    #endregion
                }
                else if (code.StartsWith("PF"))
                {
                    #region PriceFormula

                    if (Int32.TryParse(code.Substring(2), out id))
                    {
                        using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
                        PayrollPriceFormulaDTO payrollPriceFormula = base.GetPayrollPriceFormulaDTOFromCache(entitiesReadOnly, id, CacheConfig.Company(actorCompanyId));
                        if (payrollPriceFormula != null)
                            formula = Regex.Replace(formula, pattern, payrollPriceFormula.Code, RegexOptions.IgnoreCase);
                    }

                    #endregion
                }
                else if (code.StartsWith("FV"))
                {
                    #region Fixed value

                    if (Int32.TryParse(code.Substring(2), out id))
                    {
                        var sysPayrollPrice = GetSysPayrollPrice(actorCompanyId, id);
                        if (sysPayrollPrice != null)
                            formula = Regex.Replace(formula, pattern, sysPayrollPrice.Code, RegexOptions.IgnoreCase);
                    }

                    #endregion
                }
            }

            return formula;
        }

        public decimal EvaluateFormulaValue(string formula, List<string> identifiers)
        {
            decimal value = 0;
            ActionResult result = EvaluateFormula(formula, identifiers);
            if (result.Success)
            {
                string res = StringUtility.NullToEmpty(result.StringValue);
                if (!String.IsNullOrEmpty(res))
                    Decimal.TryParse(res, out value);
            }

            return value;
        }

        public ActionResult EvaluateFormula(string formula, List<string> identifiers)
        {
            RpnParser parser = new RpnParser();
            ActionResult result = parser.Parse(formula.Replace(',', '.'), identifiers);

            return result;
        }

        #endregion

        #endregion

        #region PayrollPriceType

        public List<PayrollPriceType> GetPayrollPriceTypes(int actorCompanyId, int? payrollGroupId, bool loadPeriods = false, int? payrollPriceTypeId = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollPriceType.NoTracking();
            return GetPayrollPriceTypes(entities, actorCompanyId, payrollGroupId, loadPeriods, payrollPriceTypeId);
        }

        /// <summary>
        /// Get PayrollPriceTypes
        /// </summary>
        /// <param name="entities">ObjectContext</param>
        /// <param name="actorCompanyId">Company ID</param>
        /// <param name="payrollGroupId">If specified, only return price types connected to the payroll group</param>
        /// <returns>Collection of PayrollPriceTypes</returns>
        public List<PayrollPriceType> GetPayrollPriceTypes(CompEntities entities, int actorCompanyId, int? payrollGroupId, bool loadPeriods = false, int? payrollPriceTypeId = null)
        {
            IQueryable<PayrollPriceType> query = (from p in entities.PayrollPriceType
                                                  where p.ActorCompanyId == actorCompanyId &&
                                                  p.State == (int)SoeEntityState.Active
                                                  select p);

            if (payrollPriceTypeId.HasValue)
                query = query.Where(p => p.PayrollPriceTypeId == payrollPriceTypeId.Value);

            if (loadPeriods)
                query = query.Include("PayrollPriceTypePeriod");

            if (payrollGroupId.HasValue)
                query = query.Where(p => p.PayrollGroupPriceType.Any(g => g.PayrollGroupId == payrollGroupId.Value));

            List<PayrollPriceType> payrollPriceTypes = query.OrderBy(p => p.Name).ToList();
            foreach (PayrollPriceType payrollPriceType in payrollPriceTypes)
            {
                payrollPriceType.TypeName = GetText(payrollPriceType.Type, (int)TermGroup.PayrollPriceTypes);
            }

            return payrollPriceTypes;
        }

        public List<PayrollPriceTypeSmallDTO> GetPayrollPriceTypesSmall(CompEntities entities, int actorCompanyId, bool addEmptyRow)
        {
            List<PayrollPriceTypeSmallDTO> list = new List<PayrollPriceTypeSmallDTO>();
            if (addEmptyRow)
            {
                list.Add(new PayrollPriceTypeSmallDTO()
                {
                    PayrollPriceTypeId = 0,
                    Code = " ",
                    Name = " "
                });
            }

            list.AddRange(GetPayrollPriceTypes(entities, actorCompanyId, null, false).ToSmallDTOs());

            return list;
        }

        public List<PayrollPriceTypeSmallDTO> GetPayrollPriceTypesForFormulaBuilder(int actorCompanyId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetPayrollPriceTypesForFormulaBuilder(entities, actorCompanyId);
        }

        public List<PayrollPriceTypeSmallDTO> GetPayrollPriceTypesForFormulaBuilder(CompEntities entities, int actorCompanyId)
        {
            List<PayrollPriceTypeSmallDTO> result = new List<PayrollPriceTypeSmallDTO>()
            {
                new PayrollPriceTypeSmallDTO()
                {
                    PayrollPriceTypeId = 0,
                    Code = String.Empty,
                    Name = " "
                }
            };

            List<PayrollPriceType> priceTypes = GetPayrollPriceTypes(entities, actorCompanyId, null, false);
            foreach (PayrollPriceType priceType in priceTypes)
            {
                result.Add(new PayrollPriceTypeSmallDTO()
                {
                    PayrollPriceTypeId = priceType.PayrollPriceTypeId,
                    Code = priceType.Code,
                    Name = String.Format("{0} ({1})", priceType.Name, priceType.Code)
                });
            }

            return result;
        }

        public Dictionary<int, string> GetPayrollPriceTypesDict(int actorCompanyId, int? payrollGroupId, bool addEmptyRow = false, bool useCode = false)
        {
            Dictionary<int, string> dict = new Dictionary<int, string>();

            if (addEmptyRow)
                dict.Add(0, " ");

            var priceTypes = GetPayrollPriceTypes(actorCompanyId, payrollGroupId, false);
            foreach (PayrollPriceType priceType in priceTypes)
            {
                dict.Add(priceType.PayrollPriceTypeId, useCode ? priceType.Code : priceType.Name);
            }

            return dict;
        }

        public PayrollPriceType GetPayrollPriceType(int payrollPriceTypeId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollPriceType.NoTracking();
            return GetPayrollPriceType(entities, payrollPriceTypeId);
        }

        public PayrollPriceType GetPayrollPriceType(CompEntities entities, int payrollPriceTypeId)
        {
            return (from p in entities.PayrollPriceType.Include("PayrollPriceTypePeriod")
                    where p.PayrollPriceTypeId == payrollPriceTypeId
                    select p).FirstOrDefault();
        }

        public PayrollPriceType GetPayrollPriceType(int actorCompanyId, string code)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollPriceType.NoTracking();
            return GetPayrollPriceType(entities, actorCompanyId, code);
        }

        public PayrollPriceType GetPayrollPriceType(CompEntities entities, int actorCompanyId, string code)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.PayrollPriceType.NoTracking();
            return (from p in entities.PayrollPriceType
                    where p.ActorCompanyId == actorCompanyId &&
                    p.Code == code &&
                    p.State == (int)SoeEntityState.Active
                    select p).FirstOrDefault();
        }

        public ActionResult SavePayrollPriceType(PayrollPriceTypeDTO payrollPriceTypeInput, int actorCompanyId)
        {
            if (payrollPriceTypeInput == null)
                return new ActionResult((int)ActionResultSave.EntityIsNull, "PayrollPriceType");

            // Default result is successful
            ActionResult result = new ActionResult();

            int payrollPriceTypeId = payrollPriceTypeInput.PayrollPriceTypeId;

            bool codeExists = PayrollPriceTypeOrFormulaCodeExists(actorCompanyId, payrollPriceTypeInput.Code);

            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    entities.Connection.Open();

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_DEFAULT))
                    {
                        #region PayrollPriceType

                        // Get existing
                        PayrollPriceType payrollPriceType = GetPayrollPriceType(entities, payrollPriceTypeId);
                        if (payrollPriceType == null)
                        {
                            if (codeExists)
                                return new ActionResult((int)ActionResultSave.PayrollPriceTypeOrFormulaCodeExists, GetText(3583));

                            #region Add

                            payrollPriceType = new PayrollPriceType()
                            {
                                ActorCompanyId = actorCompanyId,
                            };
                            SetCreatedProperties(payrollPriceType);
                            entities.PayrollPriceType.AddObject(payrollPriceType);

                            #endregion
                        }
                        else
                        {
                            #region Update

                            if (codeExists && payrollPriceType.Code != payrollPriceTypeInput.Code)
                                return new ActionResult((int)ActionResultSave.PayrollPriceTypeOrFormulaCodeExists, GetText(3583));

                            SetModifiedProperties(payrollPriceType);

                            #endregion
                        }

                        payrollPriceType.Type = payrollPriceTypeInput.Type;
                        payrollPriceType.Code = payrollPriceTypeInput.Code.ToUpperInvariant();
                        payrollPriceType.Name = payrollPriceTypeInput.Name;
                        payrollPriceType.Description = payrollPriceTypeInput.Description;
                        payrollPriceType.ConditionAgeYears = payrollPriceTypeInput.ConditionAgeYears;
                        payrollPriceType.ConditionEmployedMonths = payrollPriceTypeInput.ConditionEmployeedMonths;
                        payrollPriceType.ConditionExperienceMonths = payrollPriceTypeInput.ConditionExperienceMonths;
                        payrollPriceType.State = (int)payrollPriceTypeInput.State;

                        #endregion

                        #region PayrollPriceTypePeriod

                        if (payrollPriceType.PayrollPriceTypePeriod != null)
                        {
                            // Update or Delete existing PayrollPriceTypePeriods
                            foreach (PayrollPriceTypePeriod period in payrollPriceType.PayrollPriceTypePeriod.Where(p => p.State == (int)SoeEntityState.Active).ToList())
                            {
                                // Try get Period from input
                                PayrollPriceTypePeriodDTO periodInput = (from p in payrollPriceTypeInput.Periods
                                                                         where p.PayrollPriceTypePeriodId == period.PayrollPriceTypePeriodId
                                                                         select p).FirstOrDefault();

                                if (periodInput != null)
                                {
                                    #region Update

                                    if (period.FromDate != periodInput.FromDate || period.Amount != periodInput.Amount)
                                    {
                                        period.FromDate = periodInput.FromDate;
                                        period.Amount = periodInput.Amount;
                                        SetModifiedProperties(period);
                                    }

                                    #endregion
                                }
                                else
                                {
                                    #region Delete

                                    period.State = (int)SoeEntityState.Deleted;
                                    SetModifiedProperties(period);

                                    #endregion
                                }

                                // Remove from input to prevent adding it again below
                                payrollPriceTypeInput.Periods.Remove(periodInput);
                            }

                            #region Add

                            // Add all periods that is left in the input
                            if (payrollPriceTypeInput.Periods != null)
                            {
                                foreach (PayrollPriceTypePeriodDTO periodInput in payrollPriceTypeInput.Periods)
                                {
                                    PayrollPriceTypePeriod period = new PayrollPriceTypePeriod()
                                    {
                                        FromDate = periodInput.FromDate,
                                        Amount = periodInput.Amount
                                    };
                                    SetCreatedProperties(period);
                                    payrollPriceType.PayrollPriceTypePeriod.Add(period);
                                }
                            }

                            #endregion
                        }


                        #endregion

                        result = SaveChanges(entities, transaction);
                        if (result.Success)
                        {
                            //Commit transaction
                            transaction.Complete();

                            payrollPriceTypeId = payrollPriceType.PayrollPriceTypeId;
                        }
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result.Exception = ex;
                    result.IntegerValue = 0;
                }
                finally
                {
                    if (result.Success)
                    {
                        //Set success properties
                        result.IntegerValue = payrollPriceTypeId;
                    }
                    else
                        base.LogTransactionFailed(this.ToString(), this.log);

                    entities.Connection.Close();
                }
            }

            return result;
        }

        public ActionResult DeletePayrollPriceType(int payrollPriceTypeId)
        {
            using (CompEntities entities = new CompEntities())
            {
                PayrollPriceType payrollPriceType = GetPayrollPriceType(entities, payrollPriceTypeId);
                if (payrollPriceType == null)
                    return new ActionResult((int)ActionResultDelete.EntityNotFound, "PayrollPriceType");
                if (PayrollPriceTypeInUse(payrollPriceTypeId))
                    return new ActionResult((int)ActionResultDelete.PayrollPriceTypeInUse, GetText(3584, 1, "Lönetypen används och kan därför ej tas bort"));
                if (PayrollPriceTypeInUseInFormula(payrollPriceTypeId, payrollPriceType.ActorCompanyId))
                    return new ActionResult((int)ActionResultDelete.PayrollPriceTypeInUseInFormula, GetText(3585, 1, "Lönetypen används i en eller flera formler och kan därför ej tas bort"));

                return ChangeEntityState(entities, payrollPriceType, SoeEntityState.Deleted, true);
            }
        }

        private bool PayrollPriceTypeInUse(int payrollPriceTypeId)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            if (entitiesReadOnly.PayrollGroupPriceType.Any(p => p.PayrollPriceTypeId == payrollPriceTypeId && p.State == (int)SoeEntityState.Active))
                return true;
            if (entitiesReadOnly.PayrollProductPriceType.Any(p => p.PayrollPriceTypeId == payrollPriceTypeId && p.State == (int)SoeEntityState.Active))
                return true;
            if (entitiesReadOnly.EmploymentPriceType.Any(e => e.PayrollPriceTypeId == payrollPriceTypeId && e.State == (int)SoeEntityState.Active))
                return true;
            if (entitiesReadOnly.TimePayrollTransactionExtended.Any(t => t.PayrollPriceTypeId == payrollPriceTypeId && t.State == (int)SoeEntityState.Active))
                return true;
            if (entitiesReadOnly.TimePayrollScheduleTransaction.Any(t => t.PayrollPriceTypeId == payrollPriceTypeId && t.State == (int)SoeEntityState.Active))
                return true;
            if (entitiesReadOnly.PayrollReviewHead.Any(p => p.PayrollPriceTypeId == payrollPriceTypeId && p.State == (int)SoeEntityState.Active))
                return true;
            return false;
        }

        private bool PayrollPriceTypeInUseInFormula(int payrollPriceTypeId, int actorCompanyId)
        {
            return ExistsValueInPayrollPriceFormula(String.Format("PT{0}", payrollPriceTypeId), actorCompanyId);
        }

        public decimal GetPayrollPriceTypeAmount(PayrollPriceType priceTypeWithPeriods, DateTime date)
        {
            decimal amount = 0;
            // Get value from price type itself
            if (priceTypeWithPeriods != null && priceTypeWithPeriods.PayrollPriceTypePeriod != null && priceTypeWithPeriods.PayrollPriceTypePeriod.Count > 0)
            {
                var period = priceTypeWithPeriods.PayrollPriceTypePeriod.Where(p => (!p.FromDate.HasValue || p.FromDate.Value <= date) && p.State == (int)SoeEntityState.Active).OrderBy(p => p.FromDate).LastOrDefault();
                if (period != null)
                    amount = period.Amount;
            }

            return amount;
        }

        #endregion

        #region PayrollReview

        public List<PayrollReviewHead> GetPayrollReviewHeads(int actorCompanyId, bool loadRows, bool loadPayrollGroups, bool loadPayrollPriceTypes, bool loadPayrollLevels, bool setStatusName)
        {
            List<PayrollGroup> payrollGroups = null;
            List<PayrollPriceType> payrollPriceTypes = null;
            List<PayrollLevel> payrollLevels = null;

            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollReviewHead.NoTracking();
            IQueryable<PayrollReviewHead> query = (from p in entities.PayrollReviewHead
                                                   where p.ActorCompanyId == actorCompanyId &&
                                                   p.State == (int)SoeEntityState.Active
                                                   orderby p.Status, p.Name
                                                   select p);

            if (loadRows)
                query = query.Include("PayrollReviewRow");
            if (loadPayrollGroups)
            {
                using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
                payrollGroups = GetPayrollGroupsFromCache(entitiesReadOnly, CacheConfig.Company(actorCompanyId));
                query = query.Include("PayrollReviewHeadPayrollGroup");
            }
            if (loadPayrollPriceTypes)
            {
                using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
                payrollPriceTypes = GetPayrollPriceTypesFromCache(entitiesReadOnly, CacheConfig.Company(actorCompanyId));
                query = query.Include("PayrollReviewHeadPayrollPriceType");
            }
            if (loadPayrollLevels)
            {
                using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
                payrollLevels = GetPayrollLevelsFromCache(entitiesReadOnly, CacheConfig.Company(actorCompanyId));
                query = query.Include("PayrollReviewHeadPayrollLevel");
            }

            List<PayrollReviewHead> heads = (from p in query
                                             where p.ActorCompanyId == actorCompanyId &&
                                             p.State == (int)SoeEntityState.Active
                                             select p).ToList();

            if (heads.Any() && (setStatusName || payrollGroups != null || payrollPriceTypes != null || payrollLevels != null))
            {
                foreach (var head in heads)
                {

                    if (setStatusName)
                        head.StatusName = GetText(head.Status, (int)TermGroup.PayrollReviewStatus);
                    if (payrollGroups != null)
                        head.PayrollGroupNames = head.GetPayrollGroupNames(payrollGroups);
                    if (payrollPriceTypes != null)
                        head.PayrollPriceTypeNames = head.GetPayrollPriceTypeNames(payrollPriceTypes);
                    if (payrollLevels != null)
                    {
                        head.PayrollGroupNames = string.Empty;
                        if (head.GetPayrollLevelIds().Contains(null))
                            head.PayrollLevelNames = GetText(8658, "Saknar Lönenivå") + ", ";

                        head.PayrollLevelNames += head.GetPayrollLevelNames(payrollLevels);
                    }
                }
            }

            return heads.OrderBy(h => h.Status).ThenBy(h => h.Name).ToList();
        }

        public PayrollReviewHead GetPayrollReviewHead(int payrollReviewHeadId, bool loadRows = false, bool loadPayrollGroups = false, bool loadPayrollPriceTypes = false, bool loadPayrollLevels = false, bool setStatusName = false)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollReviewHead.NoTracking();
            return GetPayrollReviewHead(entities, payrollReviewHeadId, loadRows, loadPayrollGroups, loadPayrollPriceTypes, loadPayrollLevels, setStatusName);
        }

        public PayrollReviewHead GetPayrollReviewHead(CompEntities entities, int payrollReviewHeadId, bool loadRows = false, bool loadPayrollGroups = false, bool loadPayrollPriceTypes = false, bool loadPayrollLevels = false, bool setStatusName = false)
        {
            if (payrollReviewHeadId <= 0)
                return null;

            int actorCompanyId = base.ActorCompanyId;
            IQueryable<PayrollReviewHead> query = (from p in entities.PayrollReviewHead
                                                   where p.PayrollReviewHeadId == payrollReviewHeadId &&
                                                   p.ActorCompanyId == actorCompanyId
                                                   select p);

            if (loadRows)
                query = query
                    .Include("PayrollReviewRow.Employee.ContactPerson")
                    .Include("PayrollReviewRow.PayrollGroup")
                    .Include("PayrollReviewRow.PayrollPriceType");
            if (loadPayrollGroups)
                query = query.Include("PayrollReviewHeadPayrollGroup");
            if (loadPayrollPriceTypes)
                query = query.Include("PayrollReviewHeadPayrollPriceType");
            if (loadPayrollLevels)
                query = query.Include("PayrollReviewHeadPayrollLevel");

            PayrollReviewHead head = (from p in query
                                      where p.PayrollReviewHeadId == payrollReviewHeadId &&
                                      p.ActorCompanyId == actorCompanyId
                                      select p).FirstOrDefault();

            if (head != null && setStatusName)
                head.StatusName = GetText(head.Status, (int)TermGroup.PayrollReviewStatus);

            return head;
        }

        public List<PayrollReviewEmployeeDTO> GetEmployeesForPayrollReview(int actorCompanyId, int userId, int roleId, DateTime date, List<int> payrollGroupIds, List<int> payrollPriceTypeIds, List<int?> payrollLevelIds, List<int> employeeIds = null)
        {
            List<PayrollReviewEmployeeDTO> dtos = new List<PayrollReviewEmployeeDTO>();

            if (payrollGroupIds.IsNullOrEmpty() || payrollPriceTypeIds.IsNullOrEmpty())
                return dtos;

            payrollGroupIds = payrollGroupIds.Distinct().ToList();
            payrollPriceTypeIds = payrollPriceTypeIds.Distinct().ToList();
            payrollLevelIds = payrollLevelIds.Distinct().ToList() ?? new List<int?>();

            List<Employee> employees = EmployeeManager.GetEmployeesForUsersAttestRoles(out _, actorCompanyId, userId, roleId, addEmployeeAuthModelInfo: true, loadEmploymentPriceType: true);
            if (employees.IsNullOrEmpty())
                return dtos;

            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            List<PayrollGroup> payrollGroups = (from p in entitiesReadOnly.PayrollGroup
                                                .Include("PayrollGroupPriceType.PayrollGroupPriceTypePeriod")
                                                where p.ActorCompanyId == actorCompanyId &&
                                                p.State == (int)SoeEntityState.Active &&
                                                payrollGroupIds.Contains(p.PayrollGroupId)
                                                select p).ToList();

            List<PayrollLevel> payrollLevels = GetPayrollLevelsFromCache(entitiesReadOnly, CacheConfig.Company(actorCompanyId));
            bool hasLevels = !payrollLevels.IsNullOrEmpty();
            bool hasNullLevel = payrollLevelIds.Contains(null);
            if (hasNullLevel)
                payrollLevelIds.Remove(null);

            bool hasLevelsSelection = !payrollLevelIds.IsNullOrEmpty();

            foreach (Employee employee in employees)
            {
                if (!employeeIds.IsNullOrEmpty() && !employeeIds.Contains(employee.EmployeeId))
                    continue;

                Employment employment = employee.GetEmployment(date);
                if (employment == null)
                    continue;

                int? payrollGroupId = employment.GetPayrollGroupId(date);
                if (!payrollGroupId.HasValue || !payrollGroupIds.Contains(payrollGroupId.Value))
                    continue;

                PayrollGroup payrollGroup = payrollGroups.FirstOrDefault(p => p.PayrollGroupId == payrollGroupId.Value);
                if (payrollGroup == null)
                    continue;

                foreach (int payrollPriceTypeId in payrollPriceTypeIds)
                {
                    EmploymentPriceTypePeriod employmentPriceTypePeriod = employment.GetPeriod(date, payrollPriceTypeId, payrollLevelIds, hasNullLevel, out EmploymentPriceTypePeriod actualPriceTypePeriod);
                    if (employmentPriceTypePeriod == null && hasLevelsSelection && !hasNullLevel)
                        continue;

                    PayrollReviewEmployeeDTO dto = new PayrollReviewEmployeeDTO()
                    {
                        EmployeeId = employee.EmployeeId,
                        EmployeeNr = employee.EmployeeNr,
                        Name = employee.Name,
                        PayrollGroupId = payrollGroupId.Value,
                        PayrollPriceTypeId = payrollPriceTypeId,
                        PayrollLevelId = employmentPriceTypePeriod?.PayrollLevelId,
                        EmploymentAmount = 0,
                    };

                    bool priceTypeExistsOnEmployment = false;
                    bool priceTypeExistsOnPayrollGroup = false;

                    if (employmentPriceTypePeriod != null && employmentPriceTypePeriod.Amount != 0)
                    {
                        dto.EmploymentAmount = employmentPriceTypePeriod.Amount;
                        priceTypeExistsOnEmployment = true;
                    }

                    PayrollGroupPriceType payrollGroupPriceType = payrollGroup.GetPayrollGroupPriceType(payrollPriceTypeId, employmentPriceTypePeriod?.PayrollLevelId);
                    if (payrollGroupPriceType != null)
                    {
                        PayrollGroupPriceTypePeriod payrollGroupPriceTypePeriod = payrollGroupPriceType.GetPeriod(date);
                        if ((payrollGroupPriceType.ShowOnEmployee && actualPriceTypePeriod == null) || (payrollGroupPriceTypePeriod != null && payrollGroupPriceTypePeriod.Amount != 0))
                        {
                            dto.PayrollGroupAmount = payrollGroupPriceTypePeriod?.Amount ?? 0;
                            dto.ReadOnly = payrollGroupPriceType.ReadOnlyOnEmployee;
                            if (!priceTypeExistsOnEmployment)
                                dto.EmploymentAmount = payrollGroupPriceTypePeriod?.Amount ?? 0;
                            priceTypeExistsOnPayrollGroup = true;
                        }
                    }

                    if (hasLevels)
                    {
                        dto.SelectableLevels = new List<PayrollReviewSelectableLevelDTO>();
                        foreach (PayrollGroupPriceType selectablePriceType in payrollGroup.GetPayrollGroupPriceTypes(payrollPriceTypeId, onlyWithLevels: true))
                        {
                            PayrollLevel payrollLevel = payrollLevels.FirstOrDefault(p => p.PayrollLevelId == selectablePriceType.PayrollLevelId.Value);
                            if (payrollLevel == null)
                                continue;

                            PayrollGroupPriceTypePeriod selectablePeriod = selectablePriceType.GetPeriod(date);
                            if (selectablePeriod == null)
                                continue;

                            dto.SelectableLevels.Add(new PayrollReviewSelectableLevelDTO
                            {
                                PayrollLevelId = selectablePriceType.PayrollLevelId.Value,
                                Name = payrollLevel.Name,
                                Amount = selectablePeriod.Amount,
                                FromDate = selectablePeriod.FromDate ?? DateTime.MinValue,
                            });
                        }
                    }

                    if (priceTypeExistsOnEmployment || priceTypeExistsOnPayrollGroup)
                        dtos.Add(dto);
                }
            }

            return dtos;
        }

        public bool ExistsPayrollReviewHead(int actorCompanyId, string name, int? skipPayrollReviewHeadId = null)
        {
            if (name.IsNullOrEmpty())
                return false;

            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            return entitiesReadOnly.PayrollReviewHead.Any(tc =>
                tc.Name.ToLower() == name.ToLower() &&
                tc.ActorCompanyId == actorCompanyId &&
                (!skipPayrollReviewHeadId.HasValue || tc.PayrollReviewHeadId != skipPayrollReviewHeadId.Value) &&
                tc.State == (int)SoeEntityState.Active);
        }

        public ActionResult SavePayrollReview(PayrollReviewHeadDTO payrollReviewInput)
        {
            if (payrollReviewInput == null)
                return new ActionResult((int)ActionResultSave.EntityIsNull, "PayrollReview");
            if (ExistsPayrollReviewHead(base.ActorCompanyId, payrollReviewInput.Name, skipPayrollReviewHeadId: payrollReviewInput.PayrollReviewHeadId.ToNullable()))
                return new ActionResult((int)ActionResultSave.EntityExists, string.Format(GetText(91953, "Finns redan en post med namn {0}"), payrollReviewInput.Name));

            ActionResult result = new ActionResult();

            int payrollReviewHeadId = payrollReviewInput.PayrollReviewHeadId;

            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    entities.Connection.Open();

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_DEFAULT))
                    {
                        #region PayrollReviewHead

                        // Get existing
                        PayrollReviewHead payrollReviewHead = GetPayrollReviewHead(entities, payrollReviewHeadId, loadRows: true, loadPayrollGroups: true, loadPayrollPriceTypes: true, loadPayrollLevels: true);
                        if (payrollReviewHead == null)
                        {
                            #region Add

                            payrollReviewHead = new PayrollReviewHead()
                            {
                                ActorCompanyId = base.ActorCompanyId,
                                DateFrom = payrollReviewInput.DateFrom
                            };
                            SetCreatedProperties(payrollReviewHead);
                            entities.PayrollReviewHead.AddObject(payrollReviewHead);

                            foreach (int payrollGroupId in payrollReviewInput.PayrollGroupIds)
                            {
                                payrollReviewHead.PayrollReviewHeadPayrollGroup.Add(new PayrollReviewHeadPayrollGroup()
                                {
                                    PayrollGroupId = payrollGroupId
                                });
                            }
                            foreach (int payrollPriceTypeId in payrollReviewInput.PayrollPriceTypeIds)
                            {
                                payrollReviewHead.PayrollReviewHeadPayrollPriceType.Add(new PayrollReviewHeadPayrollPriceType()
                                {
                                    PayrollPriceTypeId = payrollPriceTypeId
                                });
                            }
                            foreach (int? payrollLevelId in payrollReviewInput.PayrollLevelIds)
                            {
                                payrollReviewHead.PayrollReviewHeadPayrollLevel.Add(new PayrollReviewHeadPayrollLevel()
                                {
                                    PayrollLevelId = payrollLevelId
                                });
                            }

                            #endregion
                        }
                        else
                        {
                            #region Update

                            SetModifiedProperties(payrollReviewHead);

                            #endregion
                        }

                        payrollReviewHead.Name = payrollReviewInput.Name;
                        payrollReviewHead.Status = (int)payrollReviewInput.Status;

                        #endregion

                        #region PayrollReviewRow

                        #region Update/Delete

                        foreach (PayrollReviewRow row in payrollReviewHead.PayrollReviewRow.ToList())
                        {
                            PayrollReviewRowDTO rowInput = payrollReviewInput.Rows.FirstOrDefault(p => p.PayrollReviewRowId == row.PayrollReviewRowId);
                            if (rowInput != null)
                            {
                                #region Add

                                if (row.PayrollLevelId != rowInput.PayrollLevelId)
                                    row.PayrollLevelId = rowInput.PayrollLevelId;
                                if (row.Adjustment != rowInput.Adjustment)
                                    row.Adjustment = rowInput.Adjustment;
                                if (row.Amount != rowInput.Amount)
                                    row.Amount = Decimal.Round(rowInput.Amount, 2);

                                #endregion
                            }
                            else
                            {
                                #region Delete

                                entities.DeleteObject(row);

                                #endregion
                            }

                            payrollReviewInput.Rows.Remove(rowInput);
                        }

                        #endregion

                        #region Add

                        foreach (PayrollReviewRowDTO rowInput in payrollReviewInput.Rows)
                        {
                            PayrollReviewRow row = new PayrollReviewRow()
                            {
                                EmployeeId = rowInput.EmployeeId,
                                PayrollGroupId = rowInput.PayrollGroupId,
                                PayrollPriceTypeId = rowInput.PayrollPriceTypeId,
                                PayrollLevelId = rowInput.PayrollLevelId,
                                Adjustment = rowInput.Adjustment,
                                Amount = Decimal.Round(rowInput.Amount, 2)
                            };
                            payrollReviewHead.PayrollReviewRow.Add(row);
                        }

                        #endregion

                        #endregion

                        result = SaveChanges(entities, transaction);
                        if (result.Success)
                        {
                            // Commit transaction
                            transaction.Complete();

                            payrollReviewHeadId = payrollReviewHead.PayrollReviewHeadId;
                        }
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result.Exception = ex;
                    result.IntegerValue = 0;
                }
                finally
                {
                    if (result.Success)
                    {
                        // Set success properties
                        result.IntegerValue = payrollReviewHeadId;
                    }
                    else
                        base.LogTransactionFailed(this.ToString(), this.log);

                    entities.Connection.Close();
                }
            }

            return result;
        }

        public ActionResult UpdatePayrollReview(int payrollReviewHeadId, bool keepFuture)
        {
            ActionResult result = new ActionResult();

            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    entities.Connection.Open();

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_DEFAULT))
                    {
                        PayrollReviewHead payrollReviewHead = GetPayrollReviewHead(entities, payrollReviewHeadId, loadRows: true, loadPayrollGroups: true, loadPayrollPriceTypes: true, loadPayrollLevels: true);
                        if (payrollReviewHead == null)
                            return new ActionResult((int)ActionResultSave.EntityNotFound, "PayrollReviewHead");

                        List<TrackChangesDTO> trackChangesItems = new List<TrackChangesDTO>();
                        Dictionary<int, EntityObject> tcDict = new Dictionary<int, EntityObject>();
                        int tempIdCounter = 0;

                        foreach (PayrollReviewRow row in payrollReviewHead.PayrollReviewRow.ToList())
                        {
                            Employee employee = EmployeeManager.GetEmployeeIgnoreState(entities, payrollReviewHead.ActorCompanyId, row.EmployeeId);
                            if (employee == null)
                                continue;

                            // Get employments (from review date and all future)
                            List<Employment> employments = employee.GetEmployments(payrollReviewHead.DateFrom, DateTime.Now.AddYears(100));
                            if (employments.IsNullOrEmpty())
                                continue;

                            foreach (Employment employment in employments)
                            {
                                EmploymentPriceType employmentPriceType = EmployeeManager.GetEmploymentPriceType(entities, employment.EmploymentId, row.PayrollPriceTypeId.Value);
                                if (employmentPriceType == null)
                                {
                                    #region Add EmploymentPriceType

                                    tempIdCounter++;
                                    trackChangesItems.Add(TrackChangesManager.InitTrackChanges(entities, payrollReviewHead.ActorCompanyId, TermGroup_TrackChangesActionMethod.PayrollReview, TermGroup_TrackChangesAction.Insert, SoeEntityType.Employee, employee.EmployeeId, SoeEntityType.EmploymentPriceType, tempIdCounter, SoeEntityType.Employment, employment.EmploymentId));

                                    employmentPriceType = new EmploymentPriceType()
                                    {
                                        PayrollPriceTypeId = row.PayrollPriceTypeId.Value
                                    };
                                    employment.EmploymentPriceType.Add(employmentPriceType);
                                    tcDict.Add(tempIdCounter, employmentPriceType);

                                    #endregion
                                }
                                else
                                {
                                    #region Delete EmploymentPriceTypePeriod (Delete any future periods for this price type if not chosen to keep them)

                                    foreach (EmploymentPriceTypePeriod existingPeriod in employmentPriceType.EmploymentPriceTypePeriod.Where(p => p.FromDate >= payrollReviewHead.DateFrom && p.State == (int)SoeEntityState.Active).ToList())
                                    {
                                        // Always delete existing period if it starts on same date as new
                                        if (!keepFuture || existingPeriod.FromDate == payrollReviewHead.DateFrom)
                                        {
                                            tempIdCounter++;
                                            trackChangesItems.Add(TrackChangesManager.InitTrackChanges(entities, payrollReviewHead.ActorCompanyId, TermGroup_TrackChangesActionMethod.PayrollReview, TermGroup_TrackChangesAction.Delete, SoeEntityType.Employee, employee.EmployeeId, SoeEntityType.EmploymentPriceTypePeriod, tempIdCounter, SoeEntityType.EmploymentPriceType));
                                            tcDict.Add(tempIdCounter, existingPeriod);

                                            ChangeEntityState(entities, existingPeriod, SoeEntityState.Deleted, false);
                                            SetDeletedProperties(existingPeriod);
                                        }
                                    }

                                    #endregion
                                }

                                #region Add EmploymentPriceTypePeriod

                                tempIdCounter++;
                                trackChangesItems.Add(TrackChangesManager.InitTrackChanges(entities, payrollReviewHead.ActorCompanyId, TermGroup_TrackChangesActionMethod.PayrollReview, TermGroup_TrackChangesAction.Insert, SoeEntityType.Employee, employee.EmployeeId, SoeEntityType.EmploymentPriceTypePeriod, tempIdCounter, SoeEntityType.EmploymentPriceType));

                                EmploymentPriceTypePeriod employmentPriceTypePeriod = new EmploymentPriceTypePeriod()
                                {
                                    FromDate = payrollReviewHead.DateFrom,
                                    Amount = row.Amount,
                                    PayrollLevelId = row.PayrollLevelId,
                                };
                                SetCreatedProperties(employmentPriceTypePeriod);
                                employmentPriceType.EmploymentPriceTypePeriod.Add(employmentPriceTypePeriod);
                                tcDict.Add(tempIdCounter, employmentPriceTypePeriod);

                                #endregion
                            }
                        }

                        payrollReviewHead.Status = (int)TermGroup_PayrollReviewStatus.Executed;
                        SetModifiedProperties(payrollReviewHead);

                        result = SaveChanges(entities, transaction);
                        if (result.Success)
                        {
                            #region TrackChanges

                            // Add track changes
                            foreach (TrackChangesDTO dto in trackChangesItems.Where(t => t.Action == TermGroup_TrackChangesAction.Insert))
                            {
                                // Replace temp ids with actual ids created on save
                                if (dto.Entity == SoeEntityType.EmploymentPriceType && tcDict[dto.RecordId] is EmploymentPriceType)
                                {
                                    EmploymentPriceType priceType = tcDict[dto.RecordId] as EmploymentPriceType;
                                    dto.RecordId = priceType.EmploymentPriceTypeId;
                                }
                                else if (dto.Entity == SoeEntityType.EmploymentPriceTypePeriod && tcDict[dto.RecordId] is EmploymentPriceTypePeriod)
                                {
                                    EmploymentPriceTypePeriod period = tcDict[dto.RecordId] as EmploymentPriceTypePeriod;
                                    dto.RecordId = period.EmploymentPriceTypePeriodId;
                                    dto.ParentRecordId = period.EmploymentPriceTypeId;
                                }
                            }

                            if (trackChangesItems.Any())
                                result = TrackChangesManager.AddTrackChanges(entities, transaction, trackChangesItems);

                            #endregion

                            // Commit transaction
                            transaction.Complete();
                        }
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result.Exception = ex;
                }
                finally
                {
                    if (!result.Success)
                        base.LogTransactionFailed(this.ToString(), this.log);

                    entities.Connection.Close();
                }
            }

            return result;
        }

        public ActionResult DeletePayrollReview(int payrollReviewHeadId)
        {
            using (CompEntities entities = new CompEntities())
            {
                PayrollReviewHead payrollRevieHead = GetPayrollReviewHead(entities, payrollReviewHeadId);
                if (payrollRevieHead == null)
                    return new ActionResult((int)ActionResultDelete.EntityNotFound, "PayrollReviewHead");

                return ChangeEntityState(entities, payrollRevieHead, SoeEntityState.Deleted, true);
            }
        }

        public List<PayrollReviewRowDTO> ImportPayrollReview(Stream stream, DateTime date, int actorCompanyId)
        {
            MemoryStream ms = new MemoryStream();
            stream.CopyTo(ms);

            return ImportExportManager.ConvertPayrollReviewExcelToDTOs(ms.ToArray(), date, actorCompanyId);
        }

        public string ExportPayrollReview(PayrollReviewHeadDTO head)
        {
            byte[] bytes = ImportExportManager.ConvertPayrollReviewDTOsToExcel(head.Rows);
            if (bytes == null || bytes.Length == 0)
                return String.Empty;

            string filename = GetText(3650, 1004, "Uppdatera löner") + ".xlsx";
            string url = GeneralManager.GetUrlForDownload(bytes, filename);
            return url;
        }

        #endregion

        #region PayrollStartValueHead

        public List<PayrollStartValueHead> GetPayrollStartValueHeads(int actorCompanyId, bool includeRows, bool includePayrollProduct)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollStartValueHead.NoTracking();
            return GetPayrollStartValueHeads(entities, actorCompanyId, includeRows, includePayrollProduct);
        }

        public List<PayrollStartValueHead> GetPayrollStartValueHeads(CompEntities entities, int actorCompanyId, bool includeRows = false, bool includePayrollProduct = false)
        {
            IQueryable<PayrollStartValueHead> query = entities.PayrollStartValueHead;
            if (includeRows)
                query = query.Include("PayrollStartValueRow");
            if (includePayrollProduct)
                query = query.Include("PayrollStartValueRow.PayrollProduct");

            return (from p in query
                    where p.ActorCompanyId == actorCompanyId &&
                    p.State == (int)SoeEntityState.Active
                    orderby p.DateFrom descending
                    select p).ToList();
        }

        public PayrollStartValueHead GetPayrollStartValueHead(int actorCompanyId, int payrollStartValueHeadId, bool includeRows = false, bool includePayrollProduct = false, bool includeTransaction = false)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.PayrollStartValueHead.NoTracking();
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollStartValueRow.NoTracking();
            return GetPayrollStartValueHead(entities, actorCompanyId, payrollStartValueHeadId, includeRows, includePayrollProduct, includeTransaction);
        }

        public PayrollStartValueHead GetPayrollStartValueHead(CompEntities entities, int actorCompanyId, int payrollStartValueHeadId = 0, bool includeRows = false, bool includePayrollProduct = false, bool includeTransaction = false)
        {
            PayrollStartValueHead head;

            if (payrollStartValueHeadId != 0)
            {
                IQueryable<PayrollStartValueHead> query = entities.PayrollStartValueHead;
                if (includeRows)
                    query = query.Include("PayrollStartValueRow");
                if (includePayrollProduct)
                    query = query.Include("PayrollStartValueRow.PayrollProduct");
                if (includeTransaction)
                    query = query.Include("PayrollStartValueRow.TimePayrollTransaction");

                head = (from p in query
                        where p.ActorCompanyId == actorCompanyId &&
                        p.PayrollStartValueHeadId == payrollStartValueHeadId &&
                        p.State == (int)SoeEntityState.Active
                        select p).FirstOrDefault();
            }
            else
            {
                // TODO: This else block should be removed when multiple imports are fully implemented

                head = (from p in entities.PayrollStartValueHead
                        where p.ActorCompanyId == actorCompanyId &&
                        p.State == (int)SoeEntityState.Active
                        select p).FirstOrDefault();            //There should exist only one active import
            }

            if (head != null && includeTransaction)
            {
                foreach (PayrollStartValueRow row in head.PayrollStartValueRow.Where(r => !r.TimePayrollTransaction.IsNullOrEmpty() && r.State == (int)SoeEntityState.Active))
                {
                    foreach (var transactionsByProduct in row.TimePayrollTransaction.GroupBy(t => t.ProductId))
                    {
                        PayrollProductDTO product = GetPayrollProductFromCache(entities, CacheConfig.Company(actorCompanyId), transactionsByProduct.Key);
                        if (product != null)
                            transactionsByProduct.ToList().ForEach(r => r.CachedProduct = product);
                    }
                }

                foreach (PayrollStartValueRow row in head.PayrollStartValueRow.Where(r => !r.TimePayrollTransaction.IsNullOrEmpty() && r.State == (int)SoeEntityState.Active))
                {
                    foreach (var transactionsByEmployee in row.TimePayrollTransaction.GroupBy(t => t.EmployeeId))
                    {
                        List<TimeBlockDate> timeBlockDates = TimeBlockManager.GetTimeBlockDates(transactionsByEmployee.Key, transactionsByEmployee.Select(x => x.TimeBlockDateId).ToList());
                        foreach (var transaction in transactionsByEmployee)
                        {
                            var timeBlockDate = timeBlockDates.FirstOrDefault(x => x.TimeBlockDateId == transaction.TimeBlockDateId);
                            if (timeBlockDate != null)
                                transaction.CachedTimeBlockDate = timeBlockDate.ToDTO();
                        }
                    }
                }
            }

            if (head != null && includeRows)
                AddAppellation(actorCompanyId, head.PayrollStartValueRow.Where(x => x.State == (int)SoeEntityState.Active).ToList());

            return head;
        }

        public PayrollStartValueHead GetPayrollStartValueHeadWithRows(CompEntities entities, int payrollStartValueHeadId, int actorCompanyId)
        {
            return (from psv in entities.PayrollStartValueHead
                    .Include("PayrollStartValueRow")
                    where psv.PayrollStartValueHeadId == payrollStartValueHeadId &&
                    psv.ActorCompanyId == actorCompanyId &&
                    psv.State == (int)SoeEntityState.Active
                    select psv).FirstOrDefault();
        }

        public ActionResult ImportPayrollStartValueHeadAdd(Stream stream, DateTime dateFrom, DateTime dateTo, string importedFrom, int actorCompanyId)
        {
            if (dateFrom <= CalendarUtility.DATETIME_DEFAULT || dateTo <= CalendarUtility.DATETIME_DEFAULT)
                return new ActionResult(false, (int)ActionResultSave.Unknown, GetText(10058, "Datum måste anges"));

            PayrollStartValueHeadDTO payrollStartValueHead = new PayrollStartValueHeadDTO()
            {
                DateFrom = dateFrom,
                DateTo = dateTo,
                ImportedFrom = importedFrom,

                ActorCompanyId = actorCompanyId,
            };

            (ActionResult result, List<PayrollStartValueRowDTO> rowDtos) = ExcelImportManager.ParsePayrollStartValues(stream, (int)TermGroup_Languages.Swedish, actorCompanyId, payrollStartValueHead.DateFrom, payrollStartValueHead.DateTo);
            if (result.Success)
                return ImportPayrollStartValues(payrollStartValueHead, rowDtos, actorCompanyId, PayrollStartValueUpdateType.None);

            return result;
        }

        public ActionResult ImportPayrollStartValueHeadUpdate(Stream stream, int payrollStartValueHeadId, PayrollStartValueUpdateType updateType, int actorCompanyId)
        {
            PayrollStartValueHeadDTO payrollStartValueHead = GetPayrollStartValueHead(actorCompanyId, payrollStartValueHeadId, includeRows: false).ToDTO(includeRows: false);

            (ActionResult result, List<PayrollStartValueRowDTO> rowDtos) = ExcelImportManager.ParsePayrollStartValues(stream, (int)TermGroup_Languages.Swedish, actorCompanyId, payrollStartValueHead.DateFrom, payrollStartValueHead.DateTo);
            if (result.Success)
                return ImportPayrollStartValues(payrollStartValueHead, rowDtos, actorCompanyId, updateType);

            return result;
        }

        private ActionResult ImportPayrollStartValues(PayrollStartValueHeadDTO inputHead, List<PayrollStartValueRowDTO> inputRows, int actorCompanyId, PayrollStartValueUpdateType updateType)
        {
            ActionResult result = new ActionResult();

            if (inputHead.PayrollStartValueHeadId == 0 && updateType != PayrollStartValueUpdateType.None)
                return new ActionResult(false, (int)ActionResultSave.Unknown, GetText(9323, "Felaktiga inparametrar"));

            if (inputHead.PayrollStartValueHeadId > 0 && updateType == PayrollStartValueUpdateType.None)
                return new ActionResult(false, (int)ActionResultSave.Unknown, GetText(9323, "Felaktiga inparametrar"));

            int payrollStartValueHeadId = 0;
            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    Dictionary<int, List<PayrollStartValueRowDTO>> dict = inputRows.GroupBy(x => x.EmployeeId).ToDictionary(k => k.Key, l => l.ToList());
                    PayrollStartValueHead payrollStartValueHead = null;

                    if (inputHead.PayrollStartValueHeadId > 0)
                    {
                        payrollStartValueHead = PayrollManager.GetPayrollStartValueHeadWithRows(entities, inputHead.PayrollStartValueHeadId, actorCompanyId);
                        if (payrollStartValueHead == null)
                            return new ActionResult(false, (int)ActionResultSave.Unknown, GetText(9977, "Vald import kunde inte hittas."));
                    }

                    if (payrollStartValueHead != null && payrollStartValueHead.PayrollStartValueRow.Any() && updateType != PayrollStartValueUpdateType.None)
                    {
                        string errorMessage = string.Empty;
                        if (updateType == PayrollStartValueUpdateType.Insert)
                        {
                            foreach (var employeeRowsDict in dict)
                            {
                                foreach (var employeeRow in employeeRowsDict.Value)
                                {
                                    if (employeeRow.SysPayrollStartValueId.HasValue && payrollStartValueHead.PayrollStartValueRow.Where(x => x.State == (int)SoeEntityState.Active).Any(i => i.SysPayrollStartValueId == employeeRow.SysPayrollStartValueId && i.EmployeeId == employeeRow.EmployeeId))
                                    {
                                        errorMessage += string.Format(GetText(9978, "Anställd {0} har redan 1 eller flera importerade rader med samma produkt och datum."), employeeRow.EmployeeNr) + Environment.NewLine;
                                        break;
                                    }
                                }
                            }

                            if (!errorMessage.IsNullOrEmpty())
                                errorMessage += GetText(9979, "Rätta filen och försök igen.");
                        }
                        else if (updateType == PayrollStartValueUpdateType.OverWrite)
                        {
                            List<TimePayrollTransaction> timePayrollTransactions = PayrollManager.GetTimePayrollTransactionsFromPayrollStartValueRowIds(entities, actorCompanyId, payrollStartValueHead.PayrollStartValueRow.Select(x => x.PayrollStartValueRowId).ToList());

                            foreach (var employeeRowsDict in dict)
                            {
                                if (timePayrollTransactions.Any(x => x.EmployeeId == employeeRowsDict.Key))
                                    errorMessage += string.Format(GetText(9980, "Kan ej backa importen för anställd {0}."), employeeRowsDict.Value.FirstOrDefault().EmployeeNr) + Environment.NewLine;
                            }

                            if (!errorMessage.IsNullOrEmpty())
                                errorMessage += GetText(9981, "Det finns transaktioner kopplade till existerande startvärden som först måste tas bort.");
                        }

                        if (!errorMessage.IsNullOrEmpty())
                            return new ActionResult(errorMessage);
                    }

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_DEFAULT))
                    {
                        if (entities.Connection.State != ConnectionState.Open)
                            entities.Connection.Open();

                        if (payrollStartValueHead == null)
                        {
                            payrollStartValueHead = new PayrollStartValueHead()
                            {
                                DateFrom = inputHead.DateFrom,
                                DateTo = inputHead.DateTo,
                                ImportedFrom = inputHead.ImportedFrom,

                                //Set FK
                                ActorCompanyId = actorCompanyId,
                            };
                            SetCreatedProperties(payrollStartValueHead);
                            entities.PayrollStartValueHead.AddObject(payrollStartValueHead);

                            if (payrollStartValueHead.PayrollStartValueRow == null)
                                payrollStartValueHead.PayrollStartValueRow = new EntityCollection<PayrollStartValueRow>();

                            result = SaveChanges(entities);
                            if (!result.Success)
                                return result;
                        }

                        payrollStartValueHeadId = payrollStartValueHead.PayrollStartValueHeadId;

                        foreach (var employeeRowsDict in dict)
                        {
                            List<PayrollStartValueRowDTO> employeeRows = employeeRowsDict.Value;

                            if (updateType == PayrollStartValueUpdateType.OverWrite)
                            {
                                var existingRows = payrollStartValueHead.PayrollStartValueRow.Where(x => x.EmployeeId == employeeRowsDict.Key);
                                foreach (var existingRow in existingRows)
                                {
                                    existingRow.State = (int)SoeEntityState.Deleted;
                                    SetModifiedProperties(existingRow);
                                }
                            }

                            foreach (var employeeRow in employeeRows)
                            {
                                var payrollStartValueRow = new PayrollStartValueRow()
                                {
                                    SysPayrollStartValueId = employeeRow.SysPayrollStartValueId,
                                    Quantity = employeeRow.Quantity,
                                    Amount = employeeRow.Amount,
                                    Date = employeeRow.Date,
                                    SysPayrollTypeLevel1 = (employeeRow.SysPayrollTypeLevel1 != 0 ? (int?)employeeRow.SysPayrollTypeLevel1 : null),
                                    SysPayrollTypeLevel2 = (employeeRow.SysPayrollTypeLevel2 != 0 ? (int?)employeeRow.SysPayrollTypeLevel2 : null),
                                    SysPayrollTypeLevel3 = (employeeRow.SysPayrollTypeLevel3 != 0 ? (int?)employeeRow.SysPayrollTypeLevel3 : null),
                                    SysPayrollTypeLevel4 = (employeeRow.SysPayrollTypeLevel4 != 0 ? (int?)employeeRow.SysPayrollTypeLevel4 : null),
                                    ScheduleTimeMinutes = employeeRow.ScheduleTimeMinutes,
                                    AbsenceTimeMinutes = employeeRow.AbsenceTimeMinutes,

                                    //Set FK
                                    ActorCompanyId = actorCompanyId,
                                    EmployeeId = employeeRow.EmployeeId,
                                    ProductId = employeeRow.ProductId,
                                };
                                SetCreatedProperties(payrollStartValueRow);
                                payrollStartValueHead.PayrollStartValueRow.Add(payrollStartValueRow);
                            }

                            result = SaveChanges(entities);
                            if (!result.Success)
                                return result;
                        }

                        if (result.Success)
                            transaction.Complete();
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result = new ActionResult(ex);
                }
                finally
                {
                    if (result.Success)
                    {
                        //Set success properties
                        result.IntegerValue = payrollStartValueHeadId;
                    }
                    else
                        base.LogTransactionFailed(this.ToString(), this.log);

                    entities.Connection.Close();
                }
            }

            return result;
        }

        #endregion

        #region PayrollStartValueRow

        public List<PayrollStartValueRow> GetPayrollStartValueRows(int actorCompanyId, int payrollStartValueHeadId, int employeeId = 0, bool includeAppelation = false, bool includePayrollProduct = false, bool includeTransaction = false)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.PayrollStartValueRow.NoTracking();
            return GetPayrollStartValueRows(entities, actorCompanyId, payrollStartValueHeadId, employeeId, includeAppelation, includePayrollProduct, includeTransaction);
        }

        public List<PayrollStartValueRow> GetPayrollStartValueRows(CompEntities entities, int actorCompanyId, int payrollStartValueHeadId, int employeeId = 0, bool includeAppellation = false, bool includePayrollProduct = false, bool includeTransaction = false)
        {
            IQueryable<PayrollStartValueRow> query = entities.PayrollStartValueRow;

            if (includePayrollProduct)
                query = query.Include("PayrollProduct");
            if (includeTransaction)
            {
                query = query.Include("TimePayrollTransaction.PayrollProduct");
                query = query.Include("TimePayrollTransaction.TimeBlockDate");
            }

            query = (from p in query
                     where p.ActorCompanyId == actorCompanyId &&
                     p.PayrollStartValueHeadId == payrollStartValueHeadId &&
                     p.State == (int)SoeEntityState.Active
                     select p);

            if (employeeId > 0)
                query = query.Where(x => x.EmployeeId == employeeId);

            var rows = query.ToList();
            if (includeAppellation)
                AddAppellation(actorCompanyId, rows);

            return rows;
        }

        public List<int> GetPayrollStartValueRowIdsForVacationDebt(CompEntities entities, int actorCompanyId, int employeeId, List<int> payrollStartValueHeadIds)
        {
            if (payrollStartValueHeadIds.IsNullOrEmpty())
                return new List<int>();

            return (from p in entities.PayrollStartValueRow
                    where p.ActorCompanyId == actorCompanyId &&
                    payrollStartValueHeadIds.Contains(p.PayrollStartValueHeadId) &&
                    p.EmployeeId == employeeId &&
                    p.State == (int)SoeEntityState.Active
                    select p.PayrollStartValueRowId).ToList();
        }

        private void AddAppellation(int actorCompanyId, List<PayrollStartValueRow> rows)
        {
            Company company = CompanyManager.GetCompany(actorCompanyId);
            if (company != null)
            {
                var sysPayrollStartValues = GetSysPayrollStartValues(company.SysCountryId ?? (int)TermGroup_Country.SE);
                var terms = base.GetTermGroupContent(TermGroup.SysPayrollStartValue);

                foreach (var row in rows)
                {
                    if (row.SysPayrollStartValueId.HasValue)
                    {
                        var sysPayrollStartValue = sysPayrollStartValues.FirstOrDefault(x => x.SysPayrollStartValueId == row.SysPayrollStartValueId.Value);
                        if (sysPayrollStartValue != null)
                        {
                            var term = terms.FirstOrDefault(x => x.Id == sysPayrollStartValue.SysTermId);
                            if (term != null)
                                row.Appellation = term.Name;
                        }
                    }
                }
            }
        }

        public List<PayrollStartValueRow> GetPayrollStartValueRows(CompEntities entities, int actorCompanyId, List<int> employeeIds, List<int> payrollStartValueHeadIds)
        {
            var rows = (from psv in entities.PayrollStartValueRow
                        where psv.ActorCompanyId == actorCompanyId &&
                        payrollStartValueHeadIds.Contains(psv.PayrollStartValueHeadId) &&
                        employeeIds.Contains(psv.EmployeeId) &&
                        psv.State == (int)SoeEntityState.Active
                        select psv).ToList();

            return rows;
        }

        public List<int> GetStartValueRowIdsForYear(CompEntities entities, int actorCompanyId, List<int> employeeIds, int year)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            List<PayrollStartValueHead> payrollStartValueHeads = PayrollManager.GetPayrollStartValueHeads(entitiesReadOnly, actorCompanyId);
            var payrollStartValueHeadIds = payrollStartValueHeads.Where(x => x.DateTo.Year == year).Select(x => x.PayrollStartValueHeadId).ToList();

            if (payrollStartValueHeadIds.Any())
            {
                return (from p in entities.PayrollStartValueRow
                        where p.ActorCompanyId == actorCompanyId &&
                         payrollStartValueHeadIds.Contains(p.PayrollStartValueHeadId) &&
                         employeeIds.Contains(p.EmployeeId) &&
                        p.State == (int)SoeEntityState.Active
                        select p.PayrollStartValueRowId).ToList();
            }

            return new List<int>();
        }

        public List<PayrollStartValueRow> GetPayrollStartValueRowsWithTransactions(CompEntities entities, int actorCompanyId, int employeeId, int payrollStartValueHeadId)
        {
            var rows = (from psv in entities.PayrollStartValueRow
                        .Include("TimePayrollTransaction.TimeBlockDate")
                        where psv.ActorCompanyId == actorCompanyId &&
                        psv.PayrollStartValueHeadId == payrollStartValueHeadId &&
                        psv.EmployeeId == employeeId &&
                        psv.State == (int)SoeEntityState.Active
                        select psv).ToList();

            return rows;
        }

        public List<PayrollStartValueRow> GetPayrollStartValueRowsWithTransactions(CompEntities entities, int actorCompanyId, List<int> employeeIds, int payrollStartValueHeadId)
        {
            var rows = (from psv in entities.PayrollStartValueRow
                        .Include("TimePayrollTransaction")
                        where psv.ActorCompanyId == actorCompanyId &&
                        psv.PayrollStartValueHeadId == payrollStartValueHeadId &&
                        employeeIds.Contains(psv.EmployeeId) &&
                        psv.State == (int)SoeEntityState.Active
                        select psv).ToList();

            return rows;
        }

        public List<TimePayrollTransaction> GetTimePayrollTransactionsFromPayrollStartValueRowIds(CompEntities entities, int actorCompanyId, int employeeId, List<int> payrollStartValueRowIds)
        {
            var rows = (from tpt in entities.TimePayrollTransaction
                        .Include("TimeBlockDate")
                        .Include("TimePayrollTransactionExtended")
                        .Include("PayrollProduct")
                        .Include("AccountStd")
                        where tpt.ActorCompanyId == actorCompanyId &&
                        tpt.EmployeeId == employeeId &&
                        tpt.PayrollStartValueRowId.HasValue &&
                        payrollStartValueRowIds.Contains(tpt.PayrollStartValueRowId.Value) &&
                        tpt.State == (int)SoeEntityState.Active
                        select tpt).ToList();

            return rows;
        }

        public List<TimePayrollTransaction> GetTimePayrollTransactionsFromPayrollStartValueRowIds(CompEntities entities, int actorCompanyId, List<int> payrollStartValueRowIds)
        {
            return (from tpt in entities.TimePayrollTransaction
                    where tpt.ActorCompanyId == actorCompanyId &&
                    tpt.PayrollStartValueRowId.HasValue &&
                    payrollStartValueRowIds.Contains(tpt.PayrollStartValueRowId.Value) &&
                    tpt.State == (int)SoeEntityState.Active
                    select tpt).ToList();

        }

        #endregion

        #region RetroactivePayroll

        public List<RetroactivePayroll> GetRetroactivePayrolls(int actorCompanyId, bool loadTimePeriod = false, bool loadEmployees = false)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.RetroactivePayroll.NoTracking();
            IQueryable<RetroactivePayroll> query = entitiesReadOnly.RetroactivePayroll;
            if (loadTimePeriod)
                query = query.Include("TimePeriod.TimePeriodHead");
            if (loadEmployees)
                query = query.Include("RetroactivePayrollEmployee");

            List<RetroactivePayroll> retroactivePayrolls = (from rp in query
                                                            where rp.ActorCompanyId == actorCompanyId &&
                                                            rp.State == (int)SoeEntityState.Active
                                                            select rp).ToList();

            foreach (RetroactivePayroll retroactivePayroll in retroactivePayrolls)
            {
                retroactivePayroll.StatusName = GetText(retroactivePayroll.Status, (int)TermGroup.RetroactivePayrollStatus);
                if (retroactivePayroll.RetroactivePayrollEmployee.IsLoaded)
                    retroactivePayroll.NrOfEmployees = retroactivePayroll.RetroactivePayrollEmployee.Count(i => i.State == (int)SoeEntityState.Active);
            }

            return retroactivePayrolls.OrderByDescending(i => i.TimePeriod.PaymentDate).ToList();
        }

        public List<RetroactivePayroll> GetRetroactivePayrollsForEmployee(int timePeriodId, int employeeId, int actorCompanyId, bool loadTimePeriod = false, bool setNumberOfEmployees = false)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.RetroactivePayroll.NoTracking();
            IQueryable<RetroactivePayroll> query = entitiesReadOnly.RetroactivePayroll;
            if (loadTimePeriod)
                query = query.Include("TimePeriod.TimePeriodHead");
            if (setNumberOfEmployees)
                query = query.Include("RetroactivePayrollEmployee");

            List<RetroactivePayroll> retroactivePayrolls = (from rp in query
                                                            where rp.TimePeriodId == timePeriodId &&
                                                            rp.ActorCompanyId == actorCompanyId &&
                                                            rp.RetroactivePayrollEmployee.Any(i => i.EmployeeId == employeeId && i.State == (int)SoeEntityState.Active) &&
                                                            rp.State == (int)SoeEntityState.Active
                                                            select rp).ToList();

            foreach (RetroactivePayroll retroactivePayroll in retroactivePayrolls)
            {
                retroactivePayroll.StatusName = GetText(retroactivePayroll.Status, (int)TermGroup.RetroactivePayrollStatus);
                if (setNumberOfEmployees)
                    retroactivePayroll.NrOfEmployees = retroactivePayroll.RetroactivePayrollEmployee.Count(i => i.State == (int)SoeEntityState.Active);
            }

            return retroactivePayrolls;
        }

        public RetroactivePayroll GetRetroactivePayroll(int retroactivePayrollId, int actorCompanyId, bool loadTimePeriod = false, bool loadAccounts = false, bool loadEmployees = false)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.RetroactivePayroll.NoTracking();
            IQueryable<RetroactivePayroll> query = entitiesReadOnly.RetroactivePayroll;
            if (loadTimePeriod)
                query = query.Include("TimePeriod.TimePeriodHead");
            if (loadAccounts)
                query = query.Include("RetroactivePayrollAccount");
            if (loadEmployees)
                query = query.Include("RetroactivePayrollEmployee");

            RetroactivePayroll retroactivePayroll = (from rp in query
                                                     where rp.ActorCompanyId == actorCompanyId &&
                                                     rp.RetroactivePayrollId == retroactivePayrollId &&
                                                     rp.State == (int)SoeEntityState.Active
                                                     select rp).FirstOrDefault();

            if (retroactivePayroll != null)
                retroactivePayroll.StatusName = GetText(retroactivePayroll.Status, (int)TermGroup.RetroactivePayrollStatus);

            return retroactivePayroll;
        }

        #endregion

        #region RetroactivePayrollAccount

        public List<RetroactivePayrollAccountDTO> GetRetroactiveAccounts(int retroactivePayrollId, int actorCompanyId)
        {
            List<RetroactivePayrollAccountDTO> retroactiveAccounts = new List<RetroactivePayrollAccountDTO>();

            RetroactivePayroll existingRetroactivePayroll = GetRetroactivePayroll(retroactivePayrollId, actorCompanyId: actorCompanyId, loadAccounts: true);

            List<AccountDim> accountDims = AccountManager.GetAccountDimsByCompany(actorCompanyId);
            foreach (AccountDim accountDim in accountDims.OrderBy(i => i.AccountDimNr))
            {
                RetroactivePayrollAccount existingRetroactiveAccount = existingRetroactivePayroll?.RetroactivePayrollAccount.FirstOrDefault(i => i.AccountDimId == accountDim.AccountDimId && i.State == (int)SoeEntityState.Active);

                AccountDimDTO accountDimDTO = accountDim.ToDTO(includeAccounts: false, includeInternalAccounts: false);
                if (accountDimDTO != null)
                    accountDimDTO.Accounts = AccountManager.GetAccounts(actorCompanyId, accountDim.AccountDimId, 0).ToDTOs();

                RetroactivePayrollAccountDTO retroactiveAccount = new RetroactivePayrollAccountDTO()
                {
                    RetroactivePayrollId = existingRetroactiveAccount?.RetroactivePayrollId ?? 0,
                    RetroactivePayrollAccountId = existingRetroactiveAccount?.RetroactivePayrollAccountId ?? 0,
                    AccountDimId = accountDim.AccountDimId,
                    AccountId = accountDim.IsStandard ? existingRetroactiveAccount?.AccountStdId : existingRetroactiveAccount?.AccountInternalId,
                    Type = (existingRetroactiveAccount != null ? (TermGroup_RetroactivePayrollAccountType)existingRetroactiveAccount.Type : TermGroup_RetroactivePayrollAccountType.TransactionAccount),

                    //Extensions
                    AccountDim = accountDimDTO,
                };

                retroactiveAccounts.Add(retroactiveAccount);
            }

            return retroactiveAccounts;
        }

        #endregion

        #region RetroactivePayrollEmployee

        public List<RetroactivePayrollEmployeeDTO> GetRetroactivePayrollEmployeesForReview(int retroactivePayrollId, int actorCompanyId)
        {
            List<RetroactivePayrollEmployeeDTO> retroEmployeeDTOs = new List<RetroactivePayrollEmployeeDTO>();

            RetroactivePayroll retroactivePayroll = GetRetroactivePayroll(retroactivePayrollId, actorCompanyId);
            if (retroactivePayroll == null)
                return retroEmployeeDTOs;

            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.RetroactivePayrollEmployee.NoTracking();
            List<RetroactivePayrollEmployee> retroEmployees = (from rpe in entities.RetroactivePayrollEmployee
                                                                .Include("Employee.ContactPerson")
                                                                .Include("RetroactivePayrollOutcome")
                                                               where rpe.ActorCompanyId == actorCompanyId &&
                                                               rpe.RetroactivePayrollId == retroactivePayrollId &&
                                                               rpe.State == (int)SoeEntityState.Active
                                                               select rpe).ToList();

            if (retroEmployees.Count == 0)
                return retroEmployeeDTOs;

            entities.TimePayrollTransaction.NoTracking();
            List<TimePayrollTransaction> timePayrollTransactions = (from tpt in entities.TimePayrollTransaction
                                                                    where tpt.RetroactivePayrollOutcomeId.HasValue &&
                                                                    tpt.ActorCompanyId == actorCompanyId &&
                                                                    tpt.TimePeriodId == retroactivePayroll.TimePeriodId &&
                                                                    tpt.State == (int)SoeEntityState.Active
                                                                    select tpt).ToList();

            entities.TimePayrollScheduleTransaction.NoTracking();
            List<TimePayrollScheduleTransaction> timePayrollScheduleTransactions = (from tpt in entities.TimePayrollScheduleTransaction
                                                                                    where tpt.RetroactivePayrollOutcomeId.HasValue &&
                                                                                    tpt.ActorCompanyId == actorCompanyId &&
                                                                                    tpt.TimePeriodId == retroactivePayroll.TimePeriodId &&
                                                                                    tpt.State == (int)SoeEntityState.Active
                                                                                    select tpt).ToList();

            foreach (RetroactivePayrollEmployee retroEmployee in retroEmployees)
            {
                RetroactivePayrollEmployeeDTO retroEmployeeDTO = retroEmployee.ToDTO();
                retroEmployeeDTO.StatusName = GetText(retroEmployee.Status, (int)TermGroup.RetroactivePayrollEmployeeStatus);

                List<RetroactivePayrollOutcome> retroOutcomes = retroEmployee.RetroactivePayrollOutcome.Where(i => i.State == (int)SoeEntityState.Active).ToList();
                retroEmployeeDTO.TotalAmount = retroOutcomes.Sum(i => i.Amount);
                retroEmployeeDTO.HasOutcomes = retroOutcomes.Count > 0;
                retroEmployeeDTO.HasTransactions = retroOutcomes.Any(i => timePayrollTransactions.Any(t => t.EmployeeId == retroEmployee.EmployeeId && t.RetroactivePayrollOutcomeId.Value == i.RetroactivePayrollOutcomeId));
                if (!retroEmployeeDTO.HasTransactions)
                    retroEmployeeDTO.HasTransactions = retroOutcomes.Any(i => timePayrollScheduleTransactions.Any(t => t.EmployeeId == retroEmployee.EmployeeId && t.RetroactivePayrollOutcomeId.Value == i.RetroactivePayrollOutcomeId));

                retroEmployeeDTOs.Add(retroEmployeeDTO);
            }

            return retroEmployeeDTOs;
        }

        public List<RetroactivePayrollEmployeeDTO> GetRetroactiveEmployees(int retroactivePayrollId, int timePeriodId, int actorCompanyId, List<int> filterEmployeeIds = null, bool ignoreEmploymentStopDate = false)
        {
            List<RetroactivePayrollEmployeeDTO> dtos = new List<RetroactivePayrollEmployeeDTO>();

            TimePeriod timePeriod = TimePeriodManager.GetTimePeriod(timePeriodId, actorCompanyId, loadTimePeriodHead: true);
            if (timePeriod == null || !timePeriod.PaymentDate.HasValue)
                return dtos;

            var (startDate, stopDate) = timePeriod.GetRetroactiveDates();
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            bool useAccountHierarchy = base.UseAccountHierarchyOnCompanyFromCache(entities, actorCompanyId);
            List<CompanyCategoryRecord> companyCategoryRecords = !useAccountHierarchy ? CategoryManager.GetCompanyCategoryRecords(SoeCategoryType.Employee, SoeCategoryRecordEntity.Employee, base.ActorCompanyId) : null;
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            List<PayrollGroup> payrollGroups = GetPayrollGroupsFromCache(entitiesReadOnly, CacheConfig.Company(actorCompanyId), true);
            RetroactivePayroll retroPayroll = GetRetroactivePayroll(retroactivePayrollId, actorCompanyId: actorCompanyId, loadEmployees: true);

            //Only load one by one if max 10 employees
            bool hasEmployeeFilter = !filterEmployeeIds.IsNullOrEmpty();
            List<Employee> employees;
            if (hasEmployeeFilter && filterEmployeeIds.Count <= 10)
                employees = EmployeeManager.GetEmployees(actorCompanyId, filterEmployeeIds, onlyActive: true, loadEmployment: true, loadContactPerson: true);
            else
                employees = EmployeeManager.GetAllEmployees(actorCompanyId, active: true, loadEmployment: true);

            List<int> retroActiveEmployeeIds = retroPayroll?.RetroactivePayrollEmployee?.Select(rp => rp.RetroactivePayrollEmployeeId).ToList() ?? new List<int>();
            Dictionary<int, List<RetroactivePayrollOutcome>> retroOutcomesByEmployee =
                retroActiveEmployeeIds.Any() ?
                GetRetroactivePayrollOutcomes(retroActiveEmployeeIds, base.ActorCompanyId)
                    .GroupBy(ro => ro.RetroactivePayrolIEmployeeId)
                    .ToDictionary(k => k.Key, v => v.ToList())
                : new Dictionary<int, List<RetroactivePayrollOutcome>>();

            foreach (Employee employee in employees)
            {
                if (hasEmployeeFilter && !filterEmployeeIds.Contains(employee.EmployeeId))
                    continue;

                RetroactivePayrollEmployee retroEmployee = retroPayroll?.RetroactivePayrollEmployee.FirstOrDefault(i => i.EmployeeId == employee.EmployeeId && i.State == (int)SoeEntityState.Active);
                List<RetroactivePayrollOutcome> retroOutcomes = retroEmployee != null ? retroOutcomesByEmployee.GetList(retroEmployee.RetroactivePayrollEmployeeId) : null;

                Employment employment = employee.GetEmployment(startDate, stopDate, forward: false);
                if (employment == null && (ignoreEmploymentStopDate || retroEmployee != null))
                    employment = employee.GetLastEmployment();
                if (employment == null || (retroPayroll != null && (employee.GetEmployment(retroPayroll.DateFrom, retroPayroll.DateTo ?? stopDate) == null)))
                    continue;

                PayrollGroup payrollGroup = employment.GetPayrollGroup(startDate, stopDate, payrollGroups, forward: false);
                if (payrollGroup == null || payrollGroup.TimePeriodHeadId != timePeriod.TimePeriodHead.TimePeriodHeadId)
                    continue;

                dtos.Add(new RetroactivePayrollEmployeeDTO()
                {
                    ActorCompanyId = actorCompanyId,
                    RetroactivePayrollId = retroPayroll?.RetroactivePayrollId ?? 0,
                    RetroactivePayrollEmployeeId = retroEmployee?.RetroactivePayrollEmployeeId ?? 0,
                    RetroactivePayrollOutcomes = retroOutcomes?.ToDTOs().ToList(),
                    HasOutcomes = !retroOutcomes.IsNullOrEmpty(),
                    HasTransactions = retroOutcomes?.Any(ro => ro.CalculatedHasTransactions) ?? false,
                    Note = retroEmployee?.Note ?? String.Empty,
                    Status = retroEmployee != null ? (TermGroup_SoeRetroactivePayrollEmployeeStatus)retroEmployee.Status : TermGroup_SoeRetroactivePayrollEmployeeStatus.Saved,
                    EmployeeId = employee.EmployeeId,
                    EmployeeNr = employee.EmployeeNr,
                    EmployeeName = employee.Name,
                    PayrollGroupId = payrollGroup.PayrollGroupId,
                    CategoryIds = companyCategoryRecords?.GetCategoryRecords(employee.EmployeeId, startDate, stopDate, onlyDefaultCategories: true).Select(i => i.CategoryId).ToList(),
                });
            }

            return dtos;
        }

        public List<RetroactivePayrollEmployeeDTO> FilterRetroactiveEmployees(int actorCompanyId, int roleId, int userId, List<RetroactivePayrollEmployeeDTO> inputEmployees, int accountId)
        {

            List<int> validEmployees = new List<int>();
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            bool useAccountHierarchy = base.UseAccountHierarchyOnCompanyFromCache(entities, actorCompanyId);
            if (useAccountHierarchy)
            {
                AccountHierarchyInput input = AccountHierarchyInput.GetInstance(AccountHierarchyParamType.OnlyDefaultAccounts);
                using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
                validEmployees = EmployeeManager.GetValidEmployeeByAccountHierarchy(entitiesReadOnly, actorCompanyId, roleId, userId, inputEmployees.Select(x => x.EmployeeId).ToList(), null, DateTime.Today, DateTime.Today, onlyDefaultAccounts: true, accountIds: new List<int> { accountId }, input: input);
            }
            else
            {
                //Currently filter on category is made on the client
            }

            return inputEmployees.Where(x => validEmployees.Contains(x.EmployeeId)).OrderBy(x => x.EmployeeName).ToList();
        }

        #endregion

        #region RetroactivePayrollOutcome

        private List<RetroactivePayrollOutcome> GetRetroactivePayrollOutcomes(List<int> retroActiveEmployeeIds, int actorCompanyId)
        {
            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            var retro = (from rpo in entitiesReadOnly.RetroactivePayrollOutcome
                         where rpo.ActorCompanyId == actorCompanyId &&
                         retroActiveEmployeeIds.Contains(rpo.RetroactivePayrolIEmployeeId) &&
                         rpo.State == (int)SoeEntityState.Active
                         select new
                         {
                             RetroactivePayrollOutcome = rpo,
                             HasTransactions =
                                 rpo.RetroactivePayrollBasis.Any(rb => rb.RetroTimePayrollTransactionId.HasValue && rb.State == (int)SoeEntityState.Active) ||
                                 rpo.RetroactivePayrollScheduleBasis.Any(rb => rb.RetroTimePayrollScheduleTransactionId.HasValue && rb.State == (int)SoeEntityState.Active)
                         }).ToList();

            retro.ForEach(r => r.RetroactivePayrollOutcome.CalculatedHasTransactions = r.HasTransactions);
            return retro.Select(r => r.RetroactivePayrollOutcome).ToList();
        }

        public List<RetroactivePayrollOutcomeDTO> GetRetroactivePayrollOutcomeForEmployee(int actorCompanyId, int retroactivePayrollId, int employeeId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetRetroactivePayrollOutcomeForEmployee(entities, actorCompanyId, retroactivePayrollId, employeeId);
        }

        public List<RetroactivePayrollOutcomeDTO> GetRetroactivePayrollOutcomeForEmployee(CompEntities entities, int actorCompanyId, int retroactivePayrollId, int employeeId)
        {
            List<RetroactivePayrollOutcomeDTO> retroOutComeDTOs = new List<RetroactivePayrollOutcomeDTO>();

            var retroOutComes = (from rpo in entities.RetroactivePayrollOutcome
                    .Include("RetroactivePayrollBasis")
                    .Include("RetroactivePayrollScheduleBasis")
                    .Include("PayrollProduct")
                                 where rpo.ActorCompanyId == actorCompanyId &&
                                 rpo.RetroactivePayrollEmployee.RetroactivePayrollId == retroactivePayrollId &&
                                 rpo.EmployeeId == employeeId &&
                                 rpo.State == (int)SoeEntityState.Active
                                 select rpo).ToList();


            List<GenericType> errorCodes = base.GetTermGroupContent(TermGroup.RetroactivePayrollOutcomeErrorCode, skipUnknown: true);

            foreach (RetroactivePayrollOutcome retroOutcome in retroOutComes)
            {
                var dto = retroOutcome.ToDTO();
                if (retroOutcome.ErrorCode > 0)
                {
                    GenericType errorCode = errorCodes.FirstOrDefault(t => t.Id == retroOutcome.ErrorCode);
                    dto.ErrorCodeText = errorCode != null ? errorCode.Name : String.Empty;
                }

                if (retroOutcome.IsReversed)
                {
                    if (!String.IsNullOrEmpty(dto.ErrorCodeText))
                        dto.ErrorCodeText += ". ";
                    dto.ErrorCodeText = GetText(11714, "Tidigare utbetald retro");
                }

                if (retroOutcome.RetroactivePayrollBasis != null && retroOutcome.RetroactivePayrollBasis.Any(i => i.RetroTimePayrollTransactionId.HasValue))
                    dto.HasTransactions = true;
                else if (retroOutcome.RetroactivePayrollScheduleBasis != null && retroOutcome.RetroactivePayrollScheduleBasis.Any(i => i.RetroTimePayrollScheduleTransactionId.HasValue))
                    dto.HasTransactions = true;

                retroOutComeDTOs.Add(dto);
            }

            return retroOutComeDTOs.OrderBy(i => i.PayrollProductString).ThenBy(i => i.Quantity).ToList();
        }

        public List<AttestPayrollTransactionDTO> GetRetroactivePayrollOutcomeTransactions(int actorCompanyId, int retroactivePayrollOutcomeId, int employeeId)
        {
            List<AttestPayrollTransactionDTO> transactions = new List<AttestPayrollTransactionDTO>();

            #region Prereq

            List<AccountDimDTO> accountDims = AccountManager.GetAccountDimsByCompany(actorCompanyId).ToDTOs();

            #endregion

            #region TimePayrollTransactions

            List<TimePayrollTransaction> timePayrollTransactions = TimeTransactionManager.GetTimePayrollTransactionsForRetro(retroactivePayrollOutcomeId, employeeId, actorCompanyId);
            List<AttestPayrollTransactionDTO> timePayrollTransactionDtos = timePayrollTransactions.ToDTOs(accountDims);
            transactions.AddRange(timePayrollTransactionDtos);

            #endregion

            #region TimePayrollScheduleTransactions

            List<TimePayrollScheduleTransaction> timePayrollScheduleTransactions = TimeTransactionManager.GetTimePayrollScheduleTransactionsForRetro(retroactivePayrollOutcomeId, employeeId, actorCompanyId);
            List<AttestPayrollTransactionDTO> timePayrollScheduleTransactionDtos = timePayrollScheduleTransactions.CreateTransactionItems(accountDims);
            transactions.AddRange(timePayrollScheduleTransactionDtos);

            #endregion

            string termRetro = GetText(8782, "Retroaktiv");

            foreach (var transaction in transactions)
            {
                transaction.RetroTransactionType = termRetro;
            }

            return transactions;
        }

        public List<AttestPayrollTransactionDTO> GetRetroactivePayrollBasis(int actorCompanyId, int retroactivePayrollOutcomeId, int employeeId)
        {
            var accountDims = AccountManager.GetAccountDimsByCompany(actorCompanyId);
            List<AttestPayrollTransactionDTO> transactions = new List<AttestPayrollTransactionDTO>();
            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();

            #region TimePayrollTransaction

            List<RetroactivePayrollBasis> retroactivePayrollBasis = (from t in entitiesReadOnly.RetroactivePayrollBasis
                                                    .Include("BasisTimePayrollTransaction.AccountInternal.Account")
                                                    .Include("BasisTimePayrollTransaction.AccountStd.Account")
                                                    .Include("BasisTimePayrollTransaction.PayrollProduct")
                                                    .Include("BasisTimePayrollTransaction.TimeBlockDate")
                                                                     where t.RetroactivePayrollOutcomeId == retroactivePayrollOutcomeId &&
                                                                         t.State == (int)SoeEntityState.Active
                                                                     select t).ToList();

            List<TimePayrollTransaction> basisTimePayrollTransaction = new List<TimePayrollTransaction>();
            retroactivePayrollBasis.ForEach(x => basisTimePayrollTransaction.Add(x.BasisTimePayrollTransaction));
            basisTimePayrollTransaction = basisTimePayrollTransaction.Where(x => x.ActorCompanyId == actorCompanyId && x.EmployeeId == employeeId).ToList(); //filter on company and employee, just to be sure

            var timePayrollTransactionDtos = basisTimePayrollTransaction.ToDTOs(accountDims.ToDTOs());
            transactions.AddRange(timePayrollTransactionDtos);

            #endregion

            #region TimePayrollScheduleTransaction

            List<RetroactivePayrollScheduleBasis> retroactivePayrollScheduleBasis = (from t in entitiesReadOnly.RetroactivePayrollScheduleBasis
                                                    .Include("BasisTimePayrollScheduleTransaction.AccountInternal.Account")
                                                    .Include("BasisTimePayrollScheduleTransaction.AccountStd.Account")
                                                    .Include("BasisTimePayrollScheduleTransaction.PayrollProduct")
                                                    .Include("BasisTimePayrollScheduleTransaction.TimeBlockDate")
                                                                                     where t.RetroactivePayrollOutcomeId == retroactivePayrollOutcomeId &&
                                                                                         t.State == (int)SoeEntityState.Active
                                                                                     select t).ToList();


            List<TimePayrollScheduleTransaction> basisTimePayrollScheduleTransaction = new List<TimePayrollScheduleTransaction>();
            retroactivePayrollScheduleBasis.ForEach(x => basisTimePayrollScheduleTransaction.Add(x.BasisTimePayrollScheduleTransaction));
            basisTimePayrollScheduleTransaction = basisTimePayrollScheduleTransaction.Where(x => x.ActorCompanyId == actorCompanyId && x.EmployeeId == employeeId).ToList(); //filter on company and employee, just to be sure

            var timePayrollScheduleTransactionDtos = basisTimePayrollScheduleTransaction.CreateTransactionItems(accountDims.ToDTOs());
            transactions.AddRange(timePayrollScheduleTransactionDtos);

            #endregion

            string termBasis = GetText(8783, "Underlag");
            foreach (var transaction in transactions)
            {
                transaction.RetroTransactionType = termBasis;
            }
            return transactions;
        }

        public List<AttestPayrollTransactionDTO> GetRetroactivePayrollBasis(int actorCompanyId, int retroactivePayrollOutcomeId, int employeeId, int retroactiveTimePayrollTransactionId, int retroactiveTimePayrollScheduleTransactionId)
        {
            var accountDims = AccountManager.GetAccountDimsByCompany(actorCompanyId);
            List<AttestPayrollTransactionDTO> transactions = new List<AttestPayrollTransactionDTO>();

            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.RetroactivePayrollScheduleBasis.NoTracking();
            entitiesReadOnly.RetroactivePayrollBasis.NoTracking();
            entitiesReadOnly.TimeBlockDate.NoTracking();

            #region TimePayrollTransaction

            if (retroactiveTimePayrollTransactionId != 0)
            {
                List<RetroactivePayrollBasis> retroactivePayrollBasis = (from t in entitiesReadOnly.RetroactivePayrollBasis
                                                                        .Include("BasisTimePayrollTransaction.AccountInternal.Account")
                                                                        .Include("BasisTimePayrollTransaction.AccountStd.Account")
                                                                        .Include("BasisTimePayrollTransaction.PayrollProduct")
                                                                        .Include("BasisTimePayrollTransaction.TimeBlockDate")
                                                                         where //t.RetroactivePayrollOutcomeId == retroactivePayrollOutcomeId &&
                                                                                 t.RetroTimePayrollTransactionId == retroactiveTimePayrollTransactionId &&
                                                                                 t.State == (int)SoeEntityState.Active
                                                                         select t).ToList();

                List<TimePayrollTransaction> basisTimePayrollTransaction = new List<TimePayrollTransaction>();
                retroactivePayrollBasis.ForEach(x => basisTimePayrollTransaction.Add(x.BasisTimePayrollTransaction));
                basisTimePayrollTransaction = basisTimePayrollTransaction.Where(x => x.ActorCompanyId == actorCompanyId && x.EmployeeId == employeeId).ToList(); //filter on company and employee, just to be sure

                var payrollTransactionDtos = basisTimePayrollTransaction.ToDTOs(accountDims.ToDTOs());
                transactions.AddRange(payrollTransactionDtos);
            }

            #endregion


            #region TimePayrollScheduleTransaction

            if (retroactiveTimePayrollScheduleTransactionId != 0)
            {
                List<RetroactivePayrollScheduleBasis> retroactivePayrollScheduleBasis = (from t in entitiesReadOnly.RetroactivePayrollScheduleBasis
                                                                                        .Include("BasisTimePayrollScheduleTransaction.AccountInternal.Account")
                                                                                        .Include("BasisTimePayrollScheduleTransaction.AccountStd.Account")
                                                                                        .Include("BasisTimePayrollScheduleTransaction.PayrollProduct")
                                                                                        .Include("BasisTimePayrollScheduleTransaction.TimeBlockDate")
                                                                                         where //t.RetroactivePayrollOutcomeId == retroactivePayrollOutcomeId &&
                                                                                                 t.RetroTimePayrollScheduleTransactionId == retroactiveTimePayrollScheduleTransactionId &&
                                                                                                 t.State == (int)SoeEntityState.Active
                                                                                         select t).ToList();

                List<TimePayrollScheduleTransaction> basisTimePayrollScheduleTransaction = new List<TimePayrollScheduleTransaction>();
                retroactivePayrollScheduleBasis.ForEach(x => basisTimePayrollScheduleTransaction.Add(x.BasisTimePayrollScheduleTransaction));
                basisTimePayrollScheduleTransaction = basisTimePayrollScheduleTransaction.Where(x => x.ActorCompanyId == actorCompanyId && x.EmployeeId == employeeId).ToList(); //filter on company and employee, just to be sure

                var payrollScheduleTransactionDtos = basisTimePayrollScheduleTransaction.CreateTransactionItems(accountDims.ToDTOs());
                transactions.AddRange(payrollScheduleTransactionDtos);
            }

            #endregion

            string termBasis = GetText(8783, "Underlag");
            foreach (var transaction in transactions)
            {
                transaction.RetroTransactionType = termBasis;
            }
            return transactions;
        }

        #endregion

        #region SysPayrollStartValue

        private List<SysPayrollStartValue> GetSysPayrollStartValues(int sysCountryId)
        {
            using var sysEntitiesReadOnly = SysEntitiesProvider.LeaseReadOnlyContext();
            return (from spsv in sysEntitiesReadOnly.SysPayrollStartValue
                    where spsv.SysCountryId == sysCountryId
                    select spsv).ToList();
        }

        #endregion

        #region SysPayrollPrice

        public List<SysPayrollPrice> GetSysPayrollPrices(int? sysCountryId, List<TermGroup_SysPayrollPrice> sysPayrollPrices, bool setName, bool setTypeName, bool setAmountTypeName, bool loadIntervals, bool onlyLatest = true, DateTime? date = null)
        {
            List<int> sysTermIds = new List<int>();
            if (sysPayrollPrices != null && sysPayrollPrices.Count > 0)
            {
                foreach (TermGroup_SysPayrollPrice sysPayrollPrice in sysPayrollPrices)
                {
                    sysTermIds.Add((int)sysPayrollPrice);
                }
            }

            using var sysEntitiesReadOnly = SysEntitiesProvider.LeaseReadOnlyContext();
            IQueryable<SysPayrollPrice> oQuery = sysEntitiesReadOnly.Set<SysPayrollPrice>();
            if (loadIntervals)
                oQuery = oQuery.Include("SysPayrollPriceInterval");

            List<SysPayrollPrice> allPrices = (from s in oQuery
                                               where (!sysCountryId.HasValue || s.SysCountryId == sysCountryId) &&
                                               (!sysTermIds.Any() || sysTermIds.Contains(s.SysTermId)) &&
                                               (!date.HasValue || s.FromDate <= date.Value) &&
                                               s.State == (int)SoeEntityState.Active
                                               select s).ToList();

            List<SysPayrollPrice> prices = new List<SysPayrollPrice>();
            if (onlyLatest || date.HasValue)
            {
                foreach (SysPayrollPrice item in allPrices.OrderBy(s => s.Code).ThenByDescending(s => s.FromDate).ToList())
                {
                    if (!prices.Select(s => s.Code).Contains(item.Code))
                        prices.Add(item);
                }
            }
            else
            {
                prices = allPrices;
            }

            if (setName || setTypeName || setAmountTypeName)
            {
                foreach (SysPayrollPrice price in prices)
                {
                    if (setName)
                        price.Name = GetText(price.SysTermId, (int)TermGroup.SysPayrollPrice);
                    if (setTypeName)
                        price.TypeName = GetText(price.Type, (int)TermGroup.SysPayrollPriceType);
                    if (setAmountTypeName)
                    {
                        price.AmountTypeName = GetText(price.AmountType, (int)TermGroup.SysPayrollPriceAmountType);
                        if (price.SysPayrollPriceInterval != null && price.SysPayrollPriceInterval.Count > 0)
                        {
                            foreach (SysPayrollPriceInterval interval in price.SysPayrollPriceInterval)
                            {
                                interval.AmountTypeName = GetText(interval.AmountType, (int)TermGroup.SysPayrollPriceAmountType);
                            }
                        }
                    }
                }
            }

            return prices.OrderBy(s => s.SysTermId).ToList();
        }

        public List<SysPayrollPrice> GetSysPayrollPrices(int sysCountryId, int sysTermId)
        {
            using var sysEntitiesReadOnly = SysEntitiesProvider.LeaseReadOnlyContext();
            return GetSysPayrollPrices(sysEntitiesReadOnly, sysCountryId, sysTermId);
        }

        public List<SysPayrollPrice> GetSysPayrollPrices(SOESysEntities entities, int sysCountryId, int sysTermId)
        {
            return (from s in entities.SysPayrollPrice
                    where s.SysCountryId == sysCountryId &&
                    s.SysTermId == sysTermId &&
                    s.State == (int)SoeEntityState.Active
                    orderby s.FromDate descending
                    select s).ToList();
        }

        public List<SysPayrollPriceSmallDTO> GetPayrollPriceFormulaFixedValuesForFormulaBuilder(int actorCompanyId)
        {
            List<SysPayrollPriceSmallDTO> result = new List<SysPayrollPriceSmallDTO>()
            {
                new SysPayrollPriceSmallDTO()
                {
                    SysTermId = 0,
                    Code = String.Empty,
                    Name = " "
                }
            };

            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            var values = GetSysPayrollPrices(base.GetCompanySysCountryIdFromCache(entitiesReadOnly, actorCompanyId), null, true, false, false, false, true);
            foreach (SysPayrollPrice value in values)
            {
                result.Add(new SysPayrollPriceSmallDTO()
                {
                    SysTermId = value.SysTermId,
                    Code = value.Code,
                    Name = String.Format("{0} ({1})", value.Name, value.Code)
                });
            }

            return result.OrderBy(i => i.Name).ToList();
        }

        public SysPayrollPrice GetSysPayrollPrice(int sysPayrollPriceId, bool setName = false, bool setTypeName = false, bool setAmountTypeName = false)
        {
            using var sysEntitiesReadOnly = SysEntitiesProvider.LeaseReadOnlyContext();
            return GetSysPayrollPrice(sysEntitiesReadOnly, sysPayrollPriceId, setName, setTypeName, setAmountTypeName);
        }

        public SysPayrollPrice GetSysPayrollPrice(SOESysEntities entities, int sysPayrollPriceId, bool setName = false, bool setTypeName = false, bool setAmountTypeName = false)
        {
            SysPayrollPrice price = (from s in entities.SysPayrollPrice.Include("SysPayrollPriceInterval")
                                     where s.SysPayrollPriceId == sysPayrollPriceId
                                     select s).FirstOrDefault();

            if (setName)
                price.Name = GetText(price.SysTermId, (int)TermGroup.SysPayrollPrice);
            if (setTypeName)
                price.TypeName = GetText(price.Type, (int)TermGroup.SysPayrollPriceType);
            if (setAmountTypeName)
            {
                price.AmountTypeName = GetText(price.AmountType, (int)TermGroup.SysPayrollPriceAmountType);
                if (price.SysPayrollPriceInterval != null && price.SysPayrollPriceInterval.Count > 0)
                {
                    foreach (SysPayrollPriceInterval interval in price.SysPayrollPriceInterval)
                    {
                        interval.AmountTypeName = GetText(interval.AmountType, (int)TermGroup.SysPayrollPriceAmountType);
                    }
                }
            }

            return price;
        }

        public SysPayrollPriceViewDTO GetSysPayrollPrice(int actorCompanyId, int sysTermId, DateTime? date = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetSysPayrollPrice(entities, actorCompanyId, sysTermId, date);
        }

        public SysPayrollPriceViewDTO GetSysPayrollPrice(CompEntities entities, int actorCompanyId, int sysTermId, DateTime? date = null, int sysCountryId = 0)
        {
            if (sysCountryId == 0)
                sysCountryId = base.GetCompanySysCountryIdFromCache(entities, actorCompanyId);

            if (date.HasValue)
            {
                return (from p in SysDbCache.Instance.SysPayrollPriceViewDTOs
                        where p.SysCountryId == sysCountryId &&
                        p.SysTermId == sysTermId &&
                       (!p.FromDate.HasValue || p.FromDate.Value <= date)
                        orderby p.FromDate descending
                        select p).FirstOrDefault();
            }
            else
            {
                return (from p in SysDbCache.Instance.SysPayrollPriceViewDTOs
                        where p.SysCountryId == sysCountryId &&
                       p.SysTermId == sysTermId
                        select p).FirstOrDefault();
            }
        }

        public SysPayrollPriceViewDTO GetSysPayrollPrice(CompEntities entities, List<SysPayrollPriceViewDTO> sysPayrollPriceViews, int actorCompanyId, int sysTermId, DateTime? date = null, int sysCountryId = 0)
        {
            if (sysCountryId == 0)
                sysCountryId = base.GetCompanySysCountryIdFromCache(entities, actorCompanyId);

            if (date.HasValue)
            {
                return (from p in sysPayrollPriceViews
                        where p.SysCountryId == sysCountryId &&
                        p.SysTermId == sysTermId &&
                       (!p.FromDate.HasValue || p.FromDate.Value <= date)
                        orderby p.FromDate descending
                        select p).FirstOrDefault();
            }
            else
            {
                return (from p in sysPayrollPriceViews
                        where p.SysCountryId == sysCountryId &&
                       p.SysTermId == sysTermId
                        select p).FirstOrDefault();
            }
        }

        public SysPayrollPriceViewDTO GetSysPayrollPrice(int actorCompanyId, string code, DateTime? date = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetSysPayrollPrice(entities, actorCompanyId, code, date);
        }

        public SysPayrollPriceViewDTO GetSysPayrollPrice(CompEntities entities, int actorCompanyId, string code, DateTime? date = null)
        {
            int sysCountryId = base.GetCompanySysCountryIdFromCache(entities, actorCompanyId);

            if (date.HasValue)
            {
                return (from p in SysDbCache.Instance.SysPayrollPriceViewDTOs
                        where p.SysCountryId == sysCountryId &&
                        p.Code == code &&
                        (!p.FromDate.HasValue || p.FromDate.Value <= date)
                        orderby p.FromDate ascending
                        select p).FirstOrDefault();
            }
            else
            {
                return (from p in SysDbCache.Instance.SysPayrollPriceViewDTOs
                        where p.SysCountryId == sysCountryId &&
                        p.Code == code
                        select p).FirstOrDefault();
            }
        }

        public decimal GetSysPayrollPriceAmount(int actorCompanyId, int sysTermId, DateTime? date = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetSysPayrollPriceAmount(entities, actorCompanyId, sysTermId, date);
        }

        public decimal GetSysPayrollPriceAmount(CompEntities entities, int actorCompanyId, int sysTermId, DateTime? date = null, int sysCountryId = 0, SysPayrollPriceViewDTO sysPayrollPrice = null)
        {
            decimal amount = 0;

            if (sysPayrollPrice == null)
                sysPayrollPrice = GetSysPayrollPrice(entities, actorCompanyId, sysTermId, date, sysCountryId);

            if (sysPayrollPrice != null)
            {
                switch ((TermGroup_SysPayrollPriceAmountType)sysPayrollPrice.AmountType)
                {
                    case TermGroup_SysPayrollPriceAmountType.Amount:
                    case TermGroup_SysPayrollPriceAmountType.Days:
                    case TermGroup_SysPayrollPriceAmountType.Hours:
                    case TermGroup_SysPayrollPriceAmountType.Number:
                        amount = sysPayrollPrice.Amount;
                        break;
                    case TermGroup_SysPayrollPriceAmountType.Percent:
                        amount = Decimal.Divide(sysPayrollPrice.Amount, 100);
                        break;
                    default:
                        amount = sysPayrollPrice.Amount;
                        break;
                }
            }

            return amount;
        }

        public SysPayrollPriceViewDTO GetSysPayrollPriceInterval(int actorCompanyId, int sysTermId, decimal intervalValue, DateTime? date = null, int sysCountryId = 0, List<SysPayrollPriceViewDTO> sysPayrollPriceViews = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetSysPayrollPriceInterval(entities, actorCompanyId, sysTermId, intervalValue, date, sysCountryId, sysPayrollPriceViews);
        }

        public SysPayrollPriceViewDTO GetSysPayrollPriceInterval(CompEntities entities, int actorCompanyId, int sysTermId, decimal intervalValue, DateTime? date = null, int sysCountryId = 0, List<SysPayrollPriceViewDTO> sysPayrollPriceViews = null)
        {
            string key = $"GetSysPayrollPriceInterval#{actorCompanyId}#{sysTermId}#{intervalValue}#{date}#{sysCountryId}";

            SysPayrollPriceViewDTO view = BusinessMemoryCache<SysPayrollPriceViewDTO>.Get(key);
            if (view == null)
            {
                sysCountryId = sysCountryId == 0 ? base.GetCompanySysCountryIdFromCache(entities, actorCompanyId) : sysCountryId;

                if (sysPayrollPriceViews == null)
                {
                    if (date.HasValue)
                    {
                        view = (from p in SysDbCache.Instance.SysPayrollPriceViewDTOs
                                where p.SysCountryId == sysCountryId &&
                                p.SysTermId == sysTermId &&
                                (!p.FromDate.HasValue || p.FromDate.Value <= date) &&
                                (!p.FromInterval.HasValue || p.FromInterval <= intervalValue) &&
                                (!p.ToInterval.HasValue || p.ToInterval >= intervalValue)
                                orderby p.FromDate descending
                                select p).FirstOrDefault();
                    }
                    else
                    {
                        view = (from p in SysDbCache.Instance.SysPayrollPriceViewDTOs
                                where p.SysCountryId == sysCountryId &&
                                p.SysTermId == sysTermId &&
                                (!p.FromInterval.HasValue || p.FromInterval <= intervalValue) &&
                                (!p.ToInterval.HasValue || p.ToInterval >= intervalValue)
                                select p).FirstOrDefault();
                    }
                }
                else
                {
                    if (date.HasValue)
                    {
                        view = (from p in sysPayrollPriceViews
                                where p.SysCountryId == sysCountryId &&
                                p.SysTermId == sysTermId &&
                                (!p.FromDate.HasValue || p.FromDate.Value <= date) &&
                                (!p.FromInterval.HasValue || p.FromInterval <= intervalValue) &&
                                (!p.ToInterval.HasValue || p.ToInterval >= intervalValue)
                                orderby p.FromDate descending
                                select p).FirstOrDefault();
                    }
                    else
                    {
                        view = (from p in sysPayrollPriceViews
                                where p.SysCountryId == sysCountryId &&
                                p.SysTermId == sysTermId &&
                                (!p.FromInterval.HasValue || p.FromInterval <= intervalValue) &&
                                (!p.ToInterval.HasValue || p.ToInterval >= intervalValue)
                                select p).FirstOrDefault();
                    }
                }

                if (view != null)
                    BusinessMemoryCache<SysPayrollPriceViewDTO>.Set(key, view, 15);
            }

            return view;
        }

        public List<SysPayrollPriceViewDTO> GetSysPayrollPriceView(int sysCountryId)
        {
            return (from p in SysDbCache.Instance.SysPayrollPriceViewDTOs
                    where p.SysCountryId == sysCountryId
                    select p).ToList();
        }

        public decimal GetSysPayrollPriceIntervalAmount(int actorCompanyId, int sysTermId, decimal intervalValue, DateTime? date = null, int sysCountryId = 0)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetSysPayrollPriceIntervalAmount(entities, actorCompanyId, sysTermId, intervalValue, date, sysCountryId);
        }

        public decimal GetSysPayrollPriceIntervalAmount(CompEntities entities, int actorCompanyId, int sysTermId, decimal intervalValue, DateTime? date = null, int sysCountryId = 0, SysPayrollPriceViewDTO sysPayrollPrice = null)
        {
            decimal amount = 0;

            if (sysPayrollPrice == null)
                sysPayrollPrice = GetSysPayrollPriceInterval(entities, actorCompanyId, sysTermId, intervalValue, date, sysCountryId);

            if (sysPayrollPrice != null && sysPayrollPrice.IntervalAmountType.HasValue)
            {
                switch ((TermGroup_SysPayrollPriceAmountType)sysPayrollPrice.IntervalAmountType)
                {
                    case TermGroup_SysPayrollPriceAmountType.Amount:
                    case TermGroup_SysPayrollPriceAmountType.Days:
                    case TermGroup_SysPayrollPriceAmountType.Hours:
                    case TermGroup_SysPayrollPriceAmountType.Number:
                        amount = sysPayrollPrice.IntervalAmount ?? 0;
                        break;
                    case TermGroup_SysPayrollPriceAmountType.Percent:
                        amount = Decimal.Divide(sysPayrollPrice.IntervalAmount ?? 0, 100);
                        break;
                    default:
                        amount = sysPayrollPrice.IntervalAmount ?? 0;
                        break;
                }
            }

            return amount;
        }

        public bool ValidatePasswordForSysPayrollPrice(string password)
        {
            const string Prefix = "Idag";
            const string Suffix = "!";
            var validCode = $"{Prefix}{DateTime.Today:yyyyMMdd}{Suffix}";

            return string.Equals(password, validCode, StringComparison.Ordinal);
        }


        public ActionResult SaveSysPayrollPrices(List<SysPayrollPriceDTO> sysPayrollPricesInput)
        {
            if (sysPayrollPricesInput == null)
                return new ActionResult((int)ActionResultSave.EntityIsNull, "SysPayrollPrice");

            // Default result is successful
            ActionResult result = new ActionResult();

            using (SOESysEntities entities = new SOESysEntities())
            {
                try
                {
                    entities.Connection.Open();

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_READUNCOMMITED))
                    {
                        #region Delete

                        foreach (var priceInput in sysPayrollPricesInput.Where(s => s.State == SoeEntityState.Deleted))
                        {
                            // Can't delete all records of a type, so check that there is at least one active left before deleting
                            var activePrices = GetSysPayrollPrices(entities, priceInput.SysCountryId, priceInput.SysTermId);
                            if (!activePrices.Any(s => !sysPayrollPricesInput.Where(p => p.State == SoeEntityState.Deleted).Select(p => p.SysPayrollPriceId).Contains(s.SysPayrollPriceId)))
                            {
                                result = new ActionResult((int)ActionResultSave.SysPayrollPriceLastCannotBeDeleted, priceInput.SysTermId);
                                string msg = String.Format(GetText(17, 384, "Du kan inte ta bort det sista systempriset av typen '{0}', det måste alltid finnas en aktiv kvar!"), priceInput.Name);
                                result.ErrorMessage = msg;
                                return result;
                            }

                            // Get existing
                            SysPayrollPrice price = GetSysPayrollPrice(entities, priceInput.SysPayrollPriceId);
                            if (price != null)
                            {
                                ChangeEntityStateOnEntity(entities, price, SoeEntityState.Deleted, false);
                                if (price.SysPayrollPriceInterval != null)
                                {
                                    foreach (SysPayrollPriceInterval interval in price.SysPayrollPriceInterval)
                                    {
                                        ChangeEntityStateOnEntity(entities, interval, SoeEntityState.Deleted, false);
                                    }
                                }
                                result = SaveChanges(entities, transaction);
                            }
                        }

                        #endregion

                        #region Add/Update

                        foreach (var priceInput in sysPayrollPricesInput.Where(s => s.State != SoeEntityState.Deleted))
                        {
                            #region Validate

                            SysPayrollPrice price = null;
                            if (priceInput.SysPayrollPriceId != 0)
                            {
                                // Check if price was actually updated, otherwise skip it
                                // Do not check prices with intervals
                                price = GetSysPayrollPrice(entities, priceInput.SysPayrollPriceId);
                                if ((price.SysPayrollPriceInterval == null || price.SysPayrollPriceInterval.Count == 0) && (priceInput.Intervals == null || priceInput.Intervals.Count == 0))
                                {
                                    if (price == null || (price.Amount == priceInput.Amount && price.AmountType == (int)priceInput.AmountType && price.FromDate == priceInput.FromDate))
                                        continue;
                                }
                            }

                            // Not allowed to have two records of the same type with null or the same from date
                            var activePrices = GetSysPayrollPrices(entities, priceInput.SysCountryId, priceInput.SysTermId).Where(s => s.SysPayrollPriceId != priceInput.SysPayrollPriceId);
                            if (!priceInput.FromDate.HasValue)
                            {
                                if (activePrices.Any(s => !s.FromDate.HasValue))
                                {
                                    result = new ActionResult((int)ActionResultSave.SysPayrollPriceCannotHaveSameFromDate, priceInput.SysTermId);
                                    string msg = GetText(18, 384, "Det får inte finnas flera systempriser av samma typ med samma datum");
                                    result.ErrorMessage = msg;
                                    return result;
                                }
                            }
                            else
                            {
                                if (activePrices.Any(s => s.FromDate.HasValue && s.FromDate.Value == priceInput.FromDate.Value))
                                {
                                    result = new ActionResult((int)ActionResultSave.SysPayrollPriceCannotHaveSameFromDate, priceInput.SysTermId);
                                    string msg = GetText(18, 384, "Det får inte finnas flera systempriser av samma typ med samma datum");
                                    result.ErrorMessage = msg;
                                    return result;
                                }
                            }

                            #endregion

                            if (price == null)
                            {
                                #region Add

                                #region SysPayrollPrice

                                price = new SysPayrollPrice()
                                {
                                    SysCountryId = priceInput.SysCountryId,
                                    SysTermId = priceInput.SysTermId,
                                    Type = (int)priceInput.Type,
                                    Code = priceInput.Code.ToUpperInvariant(),
                                };
                                SetCreatedPropertiesOnEntity(price);
                                entities.SysPayrollPrice.Add(price);

                                #endregion

                                #region SysPayrollPriceInterval

                                if (priceInput.Intervals != null && priceInput.Intervals.Count > 0)
                                {
                                    SysPayrollPriceInterval interval;
                                    foreach (SysPayrollPriceIntervalDTO intervalInput in priceInput.Intervals)
                                    {
                                        interval = new SysPayrollPriceInterval()
                                        {
                                            FromInterval = intervalInput.FromInterval,
                                            ToInterval = intervalInput.ToInterval,
                                            Amount = intervalInput.Amount,
                                            AmountType = (int)intervalInput.AmountType
                                        };
                                        SetCreatedPropertiesOnEntity(interval);
                                        price.SysPayrollPriceInterval.Add(interval);
                                    }
                                }

                                #endregion

                                #endregion
                            }
                            else
                            {
                                #region Update

                                #region SysPayrollPrice

                                if (price.Amount != priceInput.Amount ||
                                    price.AmountType != (int)priceInput.AmountType ||
                                    price.FromDate != priceInput.FromDate)
                                    SetModifiedPropertiesOnEntity(price);

                                #endregion

                                #region SysPayrollPriceInterval

                                #region Update/Delete

                                // Update or Delete existing SysPayrollPriceIntervals
                                foreach (SysPayrollPriceInterval interval in price.SysPayrollPriceInterval.ToList())
                                {
                                    // Try get row from input
                                    SysPayrollPriceIntervalDTO intervalInput = (from i in priceInput.Intervals
                                                                                where i.SysPayrollPriceIntervalId == interval.SysPayrollPriceIntervalId
                                                                                select i).FirstOrDefault();

                                    if (intervalInput != null)
                                    {
                                        #region Update

                                        // Check if interval was actually updated, otherwise skip it
                                        if (interval.FromInterval != intervalInput.FromInterval ||
                                            interval.ToInterval != intervalInput.ToInterval ||
                                            interval.Amount != intervalInput.Amount ||
                                            interval.AmountType != (int)intervalInput.AmountType)
                                        {
                                            interval.FromInterval = intervalInput.FromInterval;
                                            interval.ToInterval = intervalInput.ToInterval;
                                            interval.Amount = intervalInput.Amount;
                                            interval.AmountType = (int)intervalInput.AmountType;
                                            SetModifiedPropertiesOnEntity(interval);
                                        }

                                        #endregion
                                    }
                                    else
                                    {
                                        #region Delete

                                        ChangeEntityStateOnEntity(entities, interval, SoeEntityState.Deleted, false);

                                        #endregion
                                    }

                                    // Remove from input to prevent adding it again below
                                    priceInput.Intervals.Remove(intervalInput);
                                }

                                #endregion

                                #region Add

                                // Add all rows that is left in the input
                                foreach (SysPayrollPriceIntervalDTO intervalInput in priceInput.Intervals)
                                {
                                    SysPayrollPriceInterval interval = new SysPayrollPriceInterval()
                                    {
                                        FromInterval = intervalInput.FromInterval,
                                        ToInterval = intervalInput.ToInterval,
                                        Amount = intervalInput.Amount,
                                        AmountType = (int)intervalInput.AmountType
                                    };
                                    SetCreatedPropertiesOnEntity(interval);
                                    price.SysPayrollPriceInterval.Add(interval);
                                }

                                #endregion

                                #endregion

                                #endregion
                            }

                            price.Amount = priceInput.Amount;
                            price.AmountType = (int)priceInput.AmountType;
                            price.FromDate = priceInput.FromDate;
                            result = SaveChanges(entities, transaction);
                        }

                        #endregion

                        if (result.Success)
                            transaction.Complete();
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result.Exception = ex;
                }
                finally
                {
                    if (!result.Success)
                        base.LogTransactionFailed(this.ToString(), this.log);

                    entities.Connection.Close();
                }
            }

            return result;
        }

        #endregion

        #region SysPayrollType

        public Dictionary<int, int?> GetSysPayrollTypesDict(int sysCountryId, int? parentId = null)
        {
            using var sysEntitiesReadOnly = SysEntitiesProvider.LeaseReadOnlyContext();
            var query = (from s in sysEntitiesReadOnly.SysPayrollType
                         where s.SysCountryId == sysCountryId
                         select s);

            if (parentId.HasValue)
                query = query.Where(s => s.ParentId == parentId.Value);

            Dictionary<int, int?> dict = new Dictionary<int, int?>();
            foreach (SysPayrollType payrollType in query.ToList())
            {
                dict.Add(payrollType.SysTermId, payrollType.ParentId);
            }

            return dict;
        }

        public List<SysPayrollTypeView> GetSysPayrollTypesView(int sysCountryId, int? parentId, bool addEmptyRow)
        {
            List<SysPayrollTypeView> list = new List<SysPayrollTypeView>();

            using var sysEntitiesReadOnly = SysEntitiesProvider.LeaseReadOnlyContext();
            var payrollTypes = (from s in sysEntitiesReadOnly.SysPayrollTypeView
                                where s.SysCountryId == sysCountryId &&
                                (parentId.HasValue ? s.ParentId == parentId : !s.ParentId.HasValue)
                                select s).OrderBy(i => i.Name);


            if (addEmptyRow)
            {
                list.Add(new SysPayrollTypeView()
                {
                    SysTermId = 0,
                    ParentId = null,
                    Name = " "
                });
            }

            foreach (SysPayrollTypeView payrollType in payrollTypes)
            {
                list.Add(new SysPayrollTypeView()
                {
                    SysTermId = payrollType.SysTermId,
                    ParentId = payrollType.ParentId,
                    Name = payrollType.Name
                });
            }

            return list;
        }

        #endregion

        #region SysVehicleType

        public List<SysVehicleType> GetSysVehicleTypes()
        {
            using var sysEntitiesReadOnly = SysEntitiesProvider.LeaseReadOnlyContext();
            List<SysVehicleType> sysVehicleTypes = (from s in sysEntitiesReadOnly.SysVehicleType
                                                    where s.State == (int)SoeEntityState.Active
                                                    orderby s.ManufacturingYear descending
                                                    select s).ToList();
            return sysVehicleTypes;
        }

        public SysVehicleType GetSysVehicleType(int sysVehicleTypeId)
        {
            using var sysEntitiesReadOnly = SysEntitiesProvider.LeaseReadOnlyContext();
            return GetSysVehicleType(sysEntitiesReadOnly, sysVehicleTypeId);
        }

        public SysVehicleType GetSysVehicleType(SOESysEntities entities, int sysVehicleTypeId)
        {
            SysVehicleType sysVehicleType = (from s in entities.SysVehicleType
                                             where s.SysVehicleTypeId == sysVehicleTypeId
                                             select s).FirstOrDefault();
            return sysVehicleType;
        }

        public SysVehicleType GetSysVehicleTypeByFilename(SOESysEntities entities, string filename)
        {
            SysVehicleType sysVehicleType = (from s in entities.SysVehicleType
                                             where s.Filename == filename &&
                                             s.State == (int)SoeEntityState.Active
                                             select s).FirstOrDefault();
            return sysVehicleType;
        }

        public SysVehicleType GetSysVehicleTypeByYear(int manufacturingYear)
        {
            using var sysEntitiesReadOnly = SysEntitiesProvider.LeaseReadOnlyContext();
            SysVehicleType sysVehicleType = (from s in sysEntitiesReadOnly.SysVehicleType
                                             where s.ManufacturingYear == manufacturingYear &&
                                             s.State == (int)SoeEntityState.Active
                                             orderby s.SysVehicleTypeId descending
                                             select s).FirstOrDefault();
            return sysVehicleType;
        }

        public ActionResult SaveSysVehicleType(Stream stream, string filename, DateTime? dateFrom)
        {
            ActionResult result = new ActionResult(true);

            int year = 0;
            string xml = String.Empty;

            using (stream)
            {
                XDocument xmlDoc = XDocument.Load(stream);
                string val = XmlUtil.GetChildElementValue(xmlDoc, SysVehicleXMLUtility.NODE_MANUFACTURINGYEAR);
                if (!String.IsNullOrEmpty(val) && !Int32.TryParse(val, out year))
                    return new ActionResult((int)ActionResultSave.SysVehicleTypeInvalidXMLYearNotFound, GetText(3589, "Felaktig XML, inget tillverkningsår hittat!"));

                xml = xmlDoc.ToString();
            }

            using (SOESysEntities entities = new SOESysEntities())
            {
                SysVehicleType sysVehicleType = GetSysVehicleTypeByFilename(entities, filename);
                if (sysVehicleType == null)
                {
                    sysVehicleType = new SysVehicleType()
                    {
                        Filename = filename,
                    };
                    entities.SysVehicleType.Add(sysVehicleType);
                    SetCreatedPropertiesOnEntity(sysVehicleType);
                }
                else
                {
                    SetModifiedPropertiesOnEntity(sysVehicleType);
                }

                sysVehicleType.ManufacturingYear = year;
                sysVehicleType.XML = xml;
                sysVehicleType.DateFrom = dateFrom;

                result = SaveChanges(entities);
            }

            return result;
        }

        public ActionResult DeleteSysVehicleType(int sysVehicleTypeId)
        {
            using (SOESysEntities entities = new SOESysEntities())
            {
                SysVehicleType sysVehicleType = GetSysVehicleType(entities, sysVehicleTypeId);
                if (sysVehicleType == null)
                    return new ActionResult((int)ActionResultDelete.EntityNotFound, "SysVehicleType");

                return ChangeEntityStateOnEntity(entities, sysVehicleType, SoeEntityState.Deleted, true);
            }
        }

        public List<int> GetSysVehicleManufacturingYears()
        {
            using var sysEntitiesReadOnly = SysEntitiesProvider.LeaseReadOnlyContext();
            return (from v in sysEntitiesReadOnly.SysVehicleType
                    where v.State == (int)SoeEntityState.Active
                    select v.ManufacturingYear).Distinct().OrderByDescending(v => v).ToList();
        }

        public List<string> GetSysVehicleMakes(TermGroup_VehicleType type, int manufacturingYear)
        {
            XDocument xmlDoc = GetSysVehicleXML(manufacturingYear);

            return SysVehicleXMLUtility.GetVehicleMakes(xmlDoc, type).OrderBy(m => m).ToList();
        }

        public List<GenericType<string, string>> GetSysVehicleModels(TermGroup_VehicleType type, int manufacturingYear, string make)
        {
            XDocument xmlDoc = GetSysVehicleXML(manufacturingYear);

            return SysVehicleXMLUtility.GetSysVehicleModels(xmlDoc, type, make);
        }

        public SysVehicleDTO GetSysVehicle(string modelCode)
        {
            // Model code structure:
            // 99XX999
            // First two digits = Manufacturing year
            // XX = Vehicle make
            // Last three digits = Vehicle model (sequence number)

            // Get manufacturing year from model code
            int manufacturingYear = 2000 + GetManufacturingYear(modelCode);

            XDocument xmlDoc = GetSysVehicleXML(manufacturingYear);
            if (xmlDoc == null)
                return null;

            // Find model code
            foreach (XElement element in xmlDoc.Descendants(SysVehicleXMLUtility.GetNodeNameWithNamespace(xmlDoc, SysVehicleXMLUtility.NODE_MODEL_CODE)))
            {
                if (element.Value == modelCode)
                    return CreateSysVehicleDTO(xmlDoc, element, true);
            }

            return null;
        }

        private SysVehicleDTO CreateSysVehicleDTO(XDocument xmlDoc, XElement element, bool addComparable)
        {
            int manufacturingYear = 0;
            string val = XmlUtil.GetChildElementValue(xmlDoc, SysVehicleXMLUtility.NODE_MANUFACTURINGYEAR);
            if (!String.IsNullOrEmpty(val))
                Int32.TryParse(val, out manufacturingYear);

            string make = element.Parent.Parent.Descendants(SysVehicleXMLUtility.GetNodeNameWithNamespace(xmlDoc, SysVehicleXMLUtility.NODE_MAKE)).FirstOrDefault().Value;
            string model = element.Parent.Descendants(SysVehicleXMLUtility.GetNodeNameWithNamespace(xmlDoc, SysVehicleXMLUtility.NODE_MODEL)).FirstOrDefault().Value;
            string priceString = element.Parent.Descendants(SysVehicleXMLUtility.GetNodeNameWithNamespace(xmlDoc, SysVehicleXMLUtility.NODE_PRICE)).FirstOrDefault().Value;
            Decimal.TryParse(priceString, out decimal price);

            TermGroup_SysVehicleFuelType fuelType = TermGroup_SysVehicleFuelType.Unknown;
            XElement fuelTypeElem = element.Parent.Descendants(SysVehicleXMLUtility.GetNodeNameWithNamespace(xmlDoc, SysVehicleXMLUtility.NODE_FUEL_TYPE)).FirstOrDefault();
            if (fuelTypeElem != null)
                fuelType = SysVehicleXMLUtility.GetFuelTypeByString(fuelTypeElem.Value);

            string compareCode = null;
            XElement compareCodeElem = element.Parent.Descendants(SysVehicleXMLUtility.GetNodeNameWithNamespace(xmlDoc, SysVehicleXMLUtility.NODE_CODE_FOR_COMPARABLE_MODEL)).FirstOrDefault();
            if (compareCodeElem != null)
                compareCode = compareCodeElem.Value;

            decimal priceAdjustment = 0;
            XElement priceAdjustmentElem = element.Parent.Descendants(SysVehicleXMLUtility.GetNodeNameWithNamespace(xmlDoc, SysVehicleXMLUtility.NODE_PRICE_ADJUSTMENT)).FirstOrDefault();
            if (priceAdjustmentElem != null)
                Decimal.TryParse(priceAdjustmentElem.Value, out priceAdjustment);

            decimal priceAfterReduction = 0;
            XElement priceAfterReductionElm = element.Parent.Descendants(SysVehicleXMLUtility.GetNodeNameWithNamespace(xmlDoc, SysVehicleXMLUtility.NODE_PIRCE_AFTERREDUCTION)).FirstOrDefault();
            if (priceAfterReductionElm != null)
                Decimal.TryParse(priceAfterReductionElm.Value, out priceAfterReduction);

            SysVehicleDTO dto = new SysVehicleDTO()
            {
                ManufacturingYear = manufacturingYear,
                ModelCode = element.Value,
                VehicleMake = make,
                VehicleModel = model,
                Price = price,
                FuelType = fuelType,
                CodeForComparableModel = compareCode,
                PriceAdjustment = priceAdjustment,
                priceAfterReduction = priceAfterReduction
            };

            if (compareCode != null && addComparable)
            {
                // Find model code
                foreach (XElement elem in xmlDoc.Descendants(SysVehicleXMLUtility.GetNodeNameWithNamespace(xmlDoc, SysVehicleXMLUtility.NODE_MODEL_CODE)))
                {
                    if (elem.Value == compareCode)
                    {
                        dto.ComparableModel = CreateSysVehicleDTO(xmlDoc, elem, false);
                        break;
                    }
                }
            }

            return dto;
        }

        private int GetManufacturingYear(string modelCode)
        {
            // First two digits in model code is the manufacturing year

            int manufacturingYear = 0;

            if (!String.IsNullOrEmpty(modelCode) && modelCode.Length >= 2)
                Int32.TryParse(modelCode.Left(2), out manufacturingYear);

            return manufacturingYear;
        }

        private XDocument GetSysVehicleXML(int manufacturingYear)
        {
            // Get xml for specified year from database 
            SysVehicleType sysVehicleType = GetSysVehicleTypeByYear(manufacturingYear);
            if (sysVehicleType == null)
                return null;

            string xml = sysVehicleType.XML;
            if (String.IsNullOrEmpty(xml))
                return null;

            XDocument xmlDoc = XDocument.Parse(xml);

            return xmlDoc;
        }

        #endregion

        #region Tax (SE)

        #region Common

        public int CalculateTaxSE(CompEntities entities, int actorCompanyId, DateTime date, decimal amount, Employee employee, decimal baseAmount = 0, bool applyEmploymentHasEnded = false, int sysCountryId = 0, decimal oneTimeTaxTransactionsAmount = 0)
        {
            return (int)(Decimal.Divide(CalculateYearlyTaxSE(entities, actorCompanyId, date, Decimal.Multiply(amount, 12M), employee, baseAmount, applyEmploymentHasEnded, sysCountryId, oneTimeTaxTransactionsAmount), 12M));
        }

        public decimal CalculateYearlyTaxSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, Employee employee, decimal baseAmount = 0, bool applyEmploymentHasEnded = false, int sysCountryId = 0, decimal oneTimeTaxTransactionsAmount = 0)
        {
            #region Prereq            

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get birth date from employee
            DateTime? birthDate = EmployeeManager.GetEmployeeBirthDate(employee);
            if (!birthDate.HasValue)
                return 0;

            // Get tax rate from employee
            EmployeeTaxSE empTax = EmployeeManager.GetEmployeeTaxSE(entities, employee.EmployeeId, date.Year);
            if (empTax == null && !applyEmploymentHasEnded)
                return 0;

            int? taxRate = applyEmploymentHasEnded ? null : empTax.TaxRate;
            TermGroup_EmployeeTaxType type = (empTax == null || (applyEmploymentHasEnded && empTax.Type != (int)TermGroup_EmployeeTaxType.Sink)) ? TermGroup_EmployeeTaxType.SideIncomeTax : (TermGroup_EmployeeTaxType)empTax.Type;

            // Do not round gross salary if side income tax or adjustment.
            decimal annualSalaryNotRounded = annualSalary;
            if (type != TermGroup_EmployeeTaxType.SideIncomeTax && type != TermGroup_EmployeeTaxType.Sink && type != TermGroup_EmployeeTaxType.Adjustment)
                annualSalary = RoundMonthlySalary(annualSalary);

            #endregion

            decimal tax = 0;

            switch (type)
            {
                case TermGroup_EmployeeTaxType.TableTax:
                    #region Table tax

                    if (taxRate.HasValue)
                        tax = CalculateTaxOver80000(entities, actorCompanyId, date, annualSalary, annualSalaryNotRounded, taxRate, birthDate, baseAmount, sysCountryId);

                    break;

                #endregion
                case TermGroup_EmployeeTaxType.SideIncomeTax:
                    #region Side income tax (30%)

                    tax = Decimal.Multiply(annualSalary, 0.3M);

                    break;

                #endregion
                case TermGroup_EmployeeTaxType.Adjustment:
                    #region Adjustment

                    // Adjust annual salary before calling the same tax calculation methods as for table tax
                    if (empTax != null &&
                        (!empTax.AdjustmentPeriodFrom.HasValue || empTax.AdjustmentPeriodFrom.Value <= date) &&
                        (!empTax.AdjustmentPeriodTo.HasValue || empTax.AdjustmentPeriodTo.Value >= date))
                    {
                        switch ((TermGroup_EmployeeTaxAdjustmentType)empTax.AdjustmentType)
                        {
                            case TermGroup_EmployeeTaxAdjustmentType.PercentTax:
                                tax = Decimal.Divide(Decimal.Multiply(annualSalary, empTax.AdjustmentValue ?? 0), 100M);
                                return tax;
                            case TermGroup_EmployeeTaxAdjustmentType.IncreasedTaxBase:
                                annualSalary += empTax.AdjustmentValue.HasValue ? Decimal.Multiply(empTax.AdjustmentValue.Value, 12M) : 0;
                                break;
                            case TermGroup_EmployeeTaxAdjustmentType.DecreasedTaxBase:
                                annualSalary -= empTax.AdjustmentValue.HasValue ? Decimal.Multiply(empTax.AdjustmentValue.Value, 12M) : 0;
                                break;
                            case TermGroup_EmployeeTaxAdjustmentType.NoTax:
                                tax = 0;
                                return tax;
                        }

                        if ((TermGroup_EmployeeTaxAdjustmentType)empTax.AdjustmentType == TermGroup_EmployeeTaxAdjustmentType.IncreasedTaxBase || (TermGroup_EmployeeTaxAdjustmentType)empTax.AdjustmentType == TermGroup_EmployeeTaxAdjustmentType.DecreasedTaxBase)
                            annualSalary = RoundMonthlySalary(annualSalary);
                    }

                    if (annualSalary != 0 && taxRate.HasValue)
                    {
                        if ((TermGroup_EmployeeTaxAdjustmentType)empTax.AdjustmentType == TermGroup_EmployeeTaxAdjustmentType.IncreasedTaxBase || (TermGroup_EmployeeTaxAdjustmentType)empTax.AdjustmentType == TermGroup_EmployeeTaxAdjustmentType.DecreasedTaxBase)
                            tax = CalculateTaxOver80000(entities, actorCompanyId, date, annualSalary, annualSalaryNotRounded, taxRate, birthDate, baseAmount, sysCountryId);
                        else
                            tax = CalculateTableTax(entities, actorCompanyId, date, annualSalary, taxRate.Value, birthDate.Value, baseAmount);
                    }

                    break;

                #endregion
                case TermGroup_EmployeeTaxType.Sink:
                    #region SINK

                    if (empTax != null)
                    {
                        decimal percent = 0M;
                        switch ((TermGroup_EmployeeTaxSinkType)empTax.SinkType)
                        {
                            case TermGroup_EmployeeTaxSinkType.Normal:
                                percent = GetSysPayrollPriceAmount(entities, actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_SINKTax, date);
                                if (percent == 0)
                                    percent = 0.25M;

                                break;
                            case TermGroup_EmployeeTaxSinkType.AthletsArtistSailors:
                                // 15%
                                percent = 0.15M;
                                break;
                            case TermGroup_EmployeeTaxSinkType.NoTax:
                                // 0%
                                percent = 0M;
                                break;
                        }
                        tax = Decimal.Multiply(annualSalary, percent);
                    }
                    break;

                #endregion
                case TermGroup_EmployeeTaxType.SchoolYouth:
                    #region SchoolYouth

                    decimal remaining = GetSchoolYouthRemainingAmount(entities, actorCompanyId, date, employee, empTax);
                    if (remaining <= 0 || ((remaining - (Decimal.Divide(annualSalary, 12M) + oneTimeTaxTransactionsAmount)) < 0))
                    {
                        // Limit has already been reached before this period or reached in current period -> use table tax on current months salary
                        if (taxRate.HasValue)
                            tax = CalculateTableTax(entities, actorCompanyId, date, annualSalary, taxRate.Value, birthDate.Value, baseAmount);
                    }
                    else
                    {
                        // Limit is not reached, no tax
                    }

                    break;

                #endregion
                case TermGroup_EmployeeTaxType.NoTax:
                case TermGroup_EmployeeTaxType.NotSelected:
                    break;
            }

            return tax;
        }

        private decimal GetSchoolYouthRemainingAmount(CompEntities entities, int actorCompanyId, DateTime date, Employee employee, EmployeeTaxSEDTO empTax)
        {
            return GetSchoolYouthRemainingAmount(entities, actorCompanyId, date, employee, empTax?.SchoolYouthLimitInitial ?? 0);
        }
        private decimal GetSchoolYouthRemainingAmount(CompEntities entities, int actorCompanyId, DateTime date, Employee employee, EmployeeTaxSE empTax)
        {
            return GetSchoolYouthRemainingAmount(entities, actorCompanyId, date, employee, empTax?.SchoolYouthLimitInitial ?? 0);
        }
        private decimal GetSchoolYouthRemainingAmount(CompEntities entities, int actorCompanyId, DateTime date, Employee employee, decimal schoolYouthLimitInitial)
        {
            // Get limit (sys price)
            decimal limit = GetSysPayrollPriceAmount(entities, actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_SchoolYouthLimit, date);
            // Get initial amount

            // Get amount used (before current date)
            decimal limitUsed = GetSchoolYouthLimitUsed(entities, actorCompanyId, employee.EmployeeId, date);
            // Calculate remaining amount
            decimal remaining = limit - schoolYouthLimitInitial - limitUsed;
            return remaining;
        }

        private decimal RoundMonthlySalary(decimal annualSalary)
        {
            // Inkomstintervallerna är 100 kr för inkomster upp t.o.m. 20 000 kr.
            // Fr.o.m. 20 001 kr är inkomstintervallerna 200 kr.

            // Round monthly salary up to nearest 100 up to 20.000.
            // Over 20.000 round up to nearest 200.

            decimal roundedAnnualSalary = annualSalary;
            decimal monthlySalary = Decimal.Divide(annualSalary, 12M);
            decimal roundTo = monthlySalary <= 20000 ? 100 : 200;
            if (monthlySalary % roundTo != 0)
            {
                monthlySalary = Decimal.Multiply(Math.Ceiling(Decimal.Divide(monthlySalary, roundTo)), roundTo);
                roundedAnnualSalary = Decimal.Multiply(monthlySalary, 12M);
            }

            return roundedAnnualSalary;
        }

        private decimal CalculateTaxOver80000(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, decimal annualSalaryNotRounded, int? taxRate, DateTime? birthDate, decimal baseAmount = 0, int sysCountryId = 0)
        {
            decimal tax = CalculateTableTax(entities, actorCompanyId, date, annualSalary, taxRate.Value, birthDate.Value, baseAmount, sysCountryId);
            if (annualSalary > Decimal.Multiply(80000, 12M))
            {
                decimal taxPercent = Decimal.Round(Decimal.Divide(tax, annualSalary), 2, MidpointRounding.AwayFromZero);

                tax = Math.Floor(Decimal.Multiply(annualSalaryNotRounded, taxPercent));
            }

            return tax;
        }

        public decimal GetBaseAmountSE(CompEntities entities, int actorCompanyId, DateTime date, int sysCountryId = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            return GetSysPayrollPriceAmount(entities, actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_BaseAmount, date, sysCountryId);
        }

        public decimal GetIncomeBaseAmountSE(CompEntities entities, int actorCompanyId, DateTime date, int sysCountryId = 0)
        {
            // Get SysPayrollPrice for IncomeBaseAmount (Prisbasbelopp)
            return GetSysPayrollPriceAmount(entities, actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_IncomeBaseAmount, date, sysCountryId);
        }

        private decimal CalculateTableTax(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, int taxRate, DateTime birthDate, decimal baseAmount = 0, int sysCountryId = 0)
        {
            decimal baseDeduction = CalculateIncreasedBaseDeductionSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);

            decimal stateIncomeTax = CalculateStateIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount, baseDeduction);
            decimal countyIncomeTax = CalculateCountyIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction);
            decimal publicServiceFee = CalculatePublicServiceFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount, baseDeduction, sysCountryId);
            decimal taxDeductionForNationalPensionFee = CalculateTaxDeductionForNationalPensionFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
            decimal taxDeductionForIncome = CalculateTaxDeductionForIncomeSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
            decimal taxDeductionForServiceIncome = CalculateTaxDeductionForServiceIncomeSE(entities, actorCompanyId, date, annualSalary, countyIncomeTax, taxDeductionForNationalPensionFee, taxDeductionForIncome, baseAmount, baseDeduction);
            decimal nationalPensionFee = CalculateNationalPensionFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount, sysCountryId);
            decimal churchFee = CalculateChurchFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount, baseDeduction);

            decimal tax = 0;
            tax += stateIncomeTax;
            tax += countyIncomeTax;
            tax += publicServiceFee;
            tax -= taxDeductionForNationalPensionFee;
            tax -= taxDeductionForIncome;
            tax -= taxDeductionForServiceIncome;
            tax += nationalPensionFee;
            tax += churchFee;

            return tax;
        }

        public decimal GetSchoolYouthLimitUsed(int actorCompanyId, int employeeId, DateTime date)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.EmployeeTimePeriodValue.NoTracking();
            return GetSchoolYouthLimitUsed(entities, actorCompanyId, employeeId, date);
        }

        public decimal GetSchoolYouthLimitUsed(CompEntities entities, int actorCompanyId, int employeeId, DateTime date)
        {
            // Get all period values for current year before specified date
            decimal limitUsed = (from v in entities.EmployeeTimePeriodValue
                                 where v.EmployeeTimePeriod.ActorCompanyId == actorCompanyId &&
                                 v.EmployeeTimePeriod.EmployeeId == employeeId &&
                                 v.State == (int)SoeEntityState.Active &&
                                 v.EmployeeTimePeriod.State == (int)SoeEntityState.Active &&
                                 (v.EmployeeTimePeriod.Status == (int)SoeEmployeeTimePeriodStatus.Locked || v.EmployeeTimePeriod.Status == (int)SoeEmployeeTimePeriodStatus.Paid) &&
                                 v.EmployeeTimePeriod.TimePeriod.TimePeriodHead.State == (int)SoeEntityState.Active &&
                                 v.EmployeeTimePeriod.TimePeriod.PaymentDate.HasValue && v.EmployeeTimePeriod.TimePeriod.PaymentDate.Value.Year == date.Year && v.EmployeeTimePeriod.TimePeriod.PaymentDate < date &&
                                 v.EmployeeTimePeriod.TimePeriod.State == (int)SoeEntityState.Active &&
                                 v.Type == (int)SoeEmployeeTimePeriodValueType.GrossSalary
                                 select v.Value).DefaultIfEmpty(0).Sum();

            return limitUsed;
        }

        #endregion

        #region Base deduction (Grundavdrag)

        // Grundavdraget baseras på det prisbasbelopp som fastställts för inkomståret.

        // Fr.o.m. inkomståret 2009 infördes det förhöjda grundavdraget för personer över 65 år med låga beskattningsbara inkomster.
        // Det förhöjda grundavdraget påverkar kolumn 2, 3 och 4 i de allmänna tabellerna och kolumn 2 och 3 i sjömansskattetabellerna.
        // Även det förhöjda grundavdraget baseras på det prisbasbelopp som fastställts för inkomståret.

        #region Common

        public decimal CalculateBaseDeductionSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, decimal baseAmount = 0, bool round = true)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction;
            if (annualSalary <= (Decimal.Multiply(baseAmount, 0.99M)))
            {
                #region 0 - 0,99

                // Fastställd förvärvsinkomst överstiger inte 0,99 prisbasbelopp.
                // Grundavdrag = 0,423 prisbasbelopp.
                baseDeduction = Decimal.Multiply(baseAmount, 0.423M);

                #endregion
            }
            else
            {
                if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                {
                    #region 0,99 - 2,72

                    // Fastställd förvärvsinkomst överstiger 0,99 men inte 2,72 prisbasbelopp.
                    // Grundavdrag = 0,423 prisbasbelopp ökat med 20 procent av det belopp med vilket den fastställda förvärvsinkomsten överstiger 0,99 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.423M);
                    baseDeduction += Decimal.Multiply((Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 0.99M))), 0.2M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                    {
                        #region 2,72 - 3,11

                        // Fastställd förvärvsinkomst överstiger 2,72 men inte 3,11 prisbasbelopp.
                        // Grundavdrag = 0,77 prisbasbelopp.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.77M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                        {
                            #region 3,11 - 7,88

                            // Fastställd förvärvsinkomst överstiger 3,11 men inte 7,88 prisbasbelopp.
                            // Grundavdrag = 0,77 prisbasbelopp minskat med 10 procent av det belopp med vilket den fastställda förvärvsinkomsten överstiger 3,11 prisbasbelopp.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.77M);
                            baseDeduction -= Decimal.Multiply((Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 3.11M))), 0.1M);

                            #endregion
                        }
                        else
                        {
                            #region 7,88 -

                            // Fastställd förvärvsinkomst överstiger 7,88 prisbasbelopp.
                            // Grundavdrag = 0,293 prisbasbelopp.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.293M);

                            #endregion
                        }
                    }
                }
            }

            // Grundavdraget får inte överstiga den fastställda förvärvsinkomsten, dvs. bruttolönen för hela året.
            // Grundavdraget avrundas uppåt till jämnt hundratal kronor.

            if (round)
                baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        public decimal CalculateIncreasedBaseDeductionSE(int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return CalculateIncreasedBaseDeductionSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
        }

        public decimal CalculateIncreasedBaseDeductionSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            switch (date.Year)
            {
                case 2014:
                case 2015:
                    return CalculateIncreasedBaseDeductionSE_2014(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
                case 2016:
                case 2017:
                    return CalculateIncreasedBaseDeductionSE_2016(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
                case 2018:
                    return CalculateIncreasedBaseDeductionSE_2018(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
                case 2019:
                    return CalculateIncreasedBaseDeductionSE_2019(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
                case 2020:
                    return CalculateIncreasedBaseDeductionSE_2020(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
                case 2021:
                    return CalculateIncreasedBaseDeductionSE_2021(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
                case 2022:
                    return CalculateIncreasedBaseDeductionSE_2022(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
                case 2023:
                    return CalculateIncreasedBaseDeductionSE_2023(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
                case 2024:
                    return CalculateIncreasedBaseDeductionSE_2024(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
                case 2025:
                    return CalculateIncreasedBaseDeductionSE_2025(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
                case 2026:
                    return CalculateIncreasedBaseDeductionSE_2026(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
                default:
                    return 0;
            }
        }

        #endregion

        #region 2014-2015

        private decimal CalculateIncreasedBaseDeductionSE_2014(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction = 0;

            if (date.Year - birthDate.Year > 65)
            {
                // Get increased base deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.99M)))
                {
                    #region 0 - 0,99

                    // Fastställd förvärvsinkomst överstiger inte 0,99 prisbasbelopp.
                    // Förhöjt grundavdrag = 0,682 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.682M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 1.105M)))
                    {
                        #region 0,99 - 1,105

                        // Fastställd förvärvsinkomst överstiger 0,99 men inte 1,105 prisbasbelopp.
                        // Förhöjt grundavdrag = 0,880 prisbasbelopp minskat med 20 procent av den fastställda förvärvsinkomsten.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.880M);
                        baseDeduction -= Decimal.Multiply(annualSalary, 0.2M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                        {
                            #region 1,105 - 2,72

                            // Fastställd förvärvsinkomst överstiger 1,105 men inte 2,72 prisbasbelopp.
                            // Förhöjt grundavdrag = 0,753 prisbasbelopp minskat med 8,5 procent av den fastställda förvärvsinkomsten.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.753M);
                            baseDeduction -= Decimal.Multiply(annualSalary, 0.085M);

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                            {
                                #region 2,72 - 3,11

                                // Fastställd förvärvsinkomst överstiger 2,72 men inte 3,11 prisbasbelopp.
                                // Förhöjt grundavdrag = 0,208 prisbasbelopp ökat med 11,5 procent av den fastställda förvärvsinkomsten.
                                baseDeduction = Decimal.Multiply(baseAmount, 0.208M);
                                baseDeduction += Decimal.Multiply(annualSalary, 0.115M);

                                #endregion
                            }
                            else
                            {
                                if (annualSalary <= (Decimal.Multiply(baseAmount, 3.69M)))
                                {
                                    #region 3,11 - 3,69

                                    // Fastställd förvärvsinkomst överstiger 3,11 men inte 3,69 prisbasbelopp.
                                    // Förhöjt grundavdrag = 21,5 procent av den fastställda förvärvsinkomsten minskat med 0,103 prisbasbelopp.
                                    baseDeduction = Decimal.Multiply(annualSalary, 0.215M);
                                    baseDeduction -= Decimal.Multiply(baseAmount, 0.103M);

                                    #endregion
                                }
                                else
                                {
                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 4.785M)))
                                    {
                                        #region 3,69 - 4,785

                                        // Fastställd förvärvsinkomst överstiger 3,69 men inte 4,785 prisbasbelopp.
                                        // Förhöjt grundavdrag = 21,5 procent av den fastställda förvärvsinkomsten minskat med 0,103 prisbasbelopp.
                                        baseDeduction = Decimal.Multiply(baseAmount, 0.322M);
                                        baseDeduction += Decimal.Multiply(annualSalary, 0.1M);

                                        #endregion
                                    }
                                    else
                                    {
                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                                        {
                                            #region 4,785 - 7,88

                                            // Fastställd förvärvsinkomst överstiger 4,785 men inte 7,88 prisbasbelopp.
                                            // Förhöjt grundavdrag = 0,753 prisbasbelopp ökat med 1 procent av den fastställda förvärvsinkomsten.
                                            baseDeduction = Decimal.Multiply(baseAmount, 0.753M);
                                            baseDeduction += Decimal.Multiply(annualSalary, 0.01M);

                                            #endregion
                                        }
                                        else
                                        {
                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 12.43M)))
                                            {
                                                #region 7,88 - 12,43

                                                // Fastställd förvärvsinkomst överstiger 7,88 men inte 12,43 prisbasbelopp.
                                                // Förhöjt grundavdrag = 1,541 prisbasbelopp minskat med 9 procent av den fastställda förvärvsinkomsten.
                                                baseDeduction = Decimal.Multiply(baseAmount, 1.541M);
                                                baseDeduction -= Decimal.Multiply(annualSalary, 0.09M);

                                                #endregion
                                            }
                                            else
                                            {
                                                #region 12,43 -

                                                // Fastställd förvärvsinkomst överstiger 12,43 prisbasbelopp.
                                                // Förhöjt grundavdrag = 0,422 prisbasbelopp.
                                                baseDeduction = Decimal.Multiply(baseAmount, 0.422M);

                                                #endregion
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Det förhöjda grundavdraget summeras med ordinarie grundvdrag, varefter summan avrundas uppåt till närmaste hundratal kronor.
            // Observera att delvärdena för det ordinarie och det förhöjda grundavdraget inte ska avrundas innan summeringen.

            // Add ordinary base deduction
            baseDeduction += CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount, false);

            // Round up to nearest 100
            baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        #endregion

        #region 2016-2017

        private decimal CalculateIncreasedBaseDeductionSE_2016(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction = 0;

            if (date.Year - birthDate.Year > 65)
            {
                // Get increased base deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.99M)))
                {
                    #region 0 - 0,99

                    // Fastställd förvärvsinkomst överstiger inte 0,99 prisbasbelopp.
                    // Förhöjt grundavdrag = 0,687 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.687M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 1.11M)))
                    {
                        #region 0,99 - 1,11

                        // Fastställd förvärvsinkomst överstiger 0,99 men inte 1,11 prisbasbelopp.
                        // Förhöjt grundavdrag = 0,885 prisbasbelopp minskat med 20 procent av den fastställda förvärvsinkomsten.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.885M);
                        baseDeduction -= Decimal.Multiply(annualSalary, 0.2M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                        {
                            #region 1,11 - 2,72

                            // Fastställd förvärvsinkomst överstiger 1,11 men inte 2,72 prisbasbelopp.
                            // Förhöjt grundavdrag = 0,609 prisbasbelopp ökat med 4,9 procent av den fastställda förvärvsinkomsten.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.609M);
                            baseDeduction += Decimal.Multiply(annualSalary, 0.049M);

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                            {
                                #region 2,72 - 3,11

                                // Fastställd förvärvsinkomst överstiger 2,72 men inte 3,11 prisbasbelopp.
                                // Förhöjt grundavdrag = 0,741 prisbasbelopp.
                                baseDeduction = Decimal.Multiply(baseAmount, 0.741M);

                                #endregion
                            }
                            else
                            {
                                if (annualSalary <= (Decimal.Multiply(baseAmount, 3.77M)))
                                {
                                    #region 3,11 - 3,77

                                    // Fastställd förvärvsinkomst överstiger 3,11 men inte 3,77 prisbasbelopp.
                                    // Förhöjt grundavdrag = 0,43 prisbasbelopp ökat med 10 procent av den fastställda förvärvsinkomsten.
                                    baseDeduction = Decimal.Multiply(baseAmount, 0.43M);
                                    baseDeduction += Decimal.Multiply(annualSalary, 0.1M);

                                    #endregion
                                }
                                else
                                {
                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 5.4M)))
                                    {
                                        #region 3,77 - 5,4

                                        // Fastställd förvärvsinkomst överstiger 3,69 men inte 5,4 prisbasbelopp.
                                        // Förhöjt grundavdrag = 0,807 prisbasbelopp.
                                        baseDeduction = Decimal.Multiply(baseAmount, 0.807M);

                                        #endregion
                                    }
                                    else
                                    {
                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                                        {
                                            #region 5,4 - 7,88

                                            // Fastställd förvärvsinkomst överstiger 5,4 men inte 7,88 prisbasbelopp.
                                            // Förhöjt grundavdrag = 0,753 prisbasbelopp ökat med 1 procent av den fastställda förvärvsinkomsten.
                                            baseDeduction = Decimal.Multiply(baseAmount, 0.753M);
                                            baseDeduction += Decimal.Multiply(annualSalary, 0.01M);

                                            #endregion
                                        }
                                        else
                                        {
                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 12.43M)))
                                            {
                                                #region 7,88 - 12,43

                                                // Fastställd förvärvsinkomst överstiger 7,88 men inte 12,43 prisbasbelopp.
                                                // Förhöjt grundavdrag = 1,541 prisbasbelopp minskat med 9 procent av den fastställda förvärvsinkomsten.
                                                baseDeduction = Decimal.Multiply(baseAmount, 1.541M);
                                                baseDeduction -= Decimal.Multiply(annualSalary, 0.09M);

                                                #endregion
                                            }
                                            else
                                            {
                                                #region 12,43 -

                                                // Fastställd förvärvsinkomst överstiger 12,43 prisbasbelopp.
                                                // Förhöjt grundavdrag = 0,422 prisbasbelopp.
                                                baseDeduction = Decimal.Multiply(baseAmount, 0.422M);

                                                #endregion
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Det förhöjda grundavdraget summeras med ordinarie grundvdrag, varefter summan avrundas uppåt till närmaste hundratal kronor.
            // Observera att delvärdena för det ordinarie och det förhöjda grundavdraget inte ska avrundas innan summeringen.

            // Add ordinary base deduction
            baseDeduction += CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount, false);

            // Round up to nearest 100
            baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        #endregion

        #region 2018

        private decimal CalculateIncreasedBaseDeductionSE_2018(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction = 0;

            if (date.Year - birthDate.Year > 65)
            {
                // Get increased base deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.99M)))
                {
                    #region 0 - 0,99

                    // Fastställd förvärvsinkomst överstiger inte 0,99 prisbasbelopp.
                    // Förhöjt grundavdrag = 0,687 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.687M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 1.11M)))
                    {
                        #region 0,99 - 1,11

                        // Fastställd förvärvsinkomst överstiger 0,99 men inte 1,11 prisbasbelopp.
                        // Förhöjt grundavdrag = 0,885 prisbasbelopp minskat med 20 procent av den fastställda förvärvsinkomsten.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.885M);
                        baseDeduction -= Decimal.Multiply(annualSalary, 0.2M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                        {
                            #region 1,11 - 2,72

                            // Fastställd förvärvsinkomst överstiger 1,11 men inte 2,72 prisbasbelopp.
                            // Förhöjt grundavdrag = 0,609 prisbasbelopp ökat med 4,9 procent av den fastställda förvärvsinkomsten.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.609M);
                            baseDeduction += Decimal.Multiply(annualSalary, 0.049M);

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 2.94M)))
                            {
                                #region 2,72 - 2,94

                                // Fastställd förvärvsinkomst överstiger 2,72 men inte 2,94 prisbasbelopp.
                                // 33,2 procent av den fastställda förvärvsinkomsten minskat med 0,162 prisbasbelopp
                                baseDeduction = Decimal.Multiply(annualSalary, 0.332M);
                                baseDeduction -= Decimal.Multiply(baseAmount, 0.162M);

                                #endregion
                            }
                            else
                            {
                                if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                                {
                                    #region 2,94 - 3,11

                                    // Fastställd förvärvsinkomst överstiger 2,94 men inte 3,11 prisbasbelopp.
                                    // 0,482 prisbasbelopp ökat med 11,3 % av den fastställda förvärvsinkomsten
                                    baseDeduction = Decimal.Multiply(baseAmount, 0.482M);
                                    baseDeduction += Decimal.Multiply(annualSalary, 0.113M);

                                    #endregion
                                }
                                else
                                {
                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 4.45M)))
                                    {
                                        #region 3,11 - 4,45

                                        // Fastställd förvärvsinkomst överstiger 3,11 men inte 4,45 prisbasbelopp.
                                        // 0,171 prisbasbelopp ökat med 21,3 procent av den fastställda förvärvsinkomsten
                                        baseDeduction = Decimal.Multiply(baseAmount, 0.171M);
                                        baseDeduction += Decimal.Multiply(annualSalary, 0.213M);

                                        #endregion
                                    }
                                    else
                                    {
                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                                        {
                                            #region 4,45 - 7,88

                                            // Fastställd förvärvsinkomst överstiger 4,45 men inte 7,88 prisbasbelopp.
                                            // 1,376 prisbasbelopp minskat med 5,8 procent av den fastställda förvärvsinkomsten
                                            baseDeduction = Decimal.Multiply(baseAmount, 1.376M);
                                            baseDeduction -= Decimal.Multiply(annualSalary, 0.058M);

                                            #endregion
                                        }
                                        else
                                        {
                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 9.15M)))
                                            {
                                                #region 7,88 - 9,15

                                                // Fastställd förvärvsinkomst överstiger 7,88 men inte 9,15 prisbasbelopp.
                                                // 2,164 prisbasbelopp minskat med 15,8 procent av den fastställda förvärvsinkomsten
                                                baseDeduction = Decimal.Multiply(baseAmount, 2.164M);
                                                baseDeduction -= Decimal.Multiply(annualSalary, 0.158M);

                                                #endregion
                                            }
                                            else
                                            {
                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 12.43M)))
                                                {
                                                    #region 9,15 - 12,43

                                                    // Fastställd förvärvsinkomst överstiger 9,15 men inte 12,43 prisbasbelopp.
                                                    // Förhöjt grundavdrag = 1,541 prisbasbelopp minskat med 9 procent av den fastställda förvärvsinkomsten.
                                                    baseDeduction = Decimal.Multiply(baseAmount, 1.541M);
                                                    baseDeduction -= Decimal.Multiply(annualSalary, 0.09M);

                                                    #endregion
                                                }
                                                else
                                                {
                                                    #region 12,43 -

                                                    // Fastställd förvärvsinkomst överstiger 12,43 prisbasbelopp.
                                                    // Förhöjt grundavdrag = 0,422 prisbasbelopp.
                                                    baseDeduction = Decimal.Multiply(baseAmount, 0.422M);

                                                    #endregion
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Det förhöjda grundavdraget summeras med ordinarie grundvdrag, varefter summan avrundas uppåt till närmaste hundratal kronor.
            // Observera att delvärdena för det ordinarie och det förhöjda grundavdraget inte ska avrundas innan summeringen.

            // Add ordinary base deduction
            baseDeduction += CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount, false);

            // Round up to nearest 100
            baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        #endregion

        #region 2019

        private decimal CalculateIncreasedBaseDeductionSE_2019(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction = 0;

            if (date.Year - birthDate.Year > 65)
            {
                // Get increased base deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.99M)))
                {
                    #region 0 - 0,99

                    // Fastställd förvärvsinkomst överstiger inte 0,99 prisbasbelopp.
                    // Förhöjt grundavdrag = 0,687 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.687M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 1.11M)))
                    {
                        #region 0,99 - 1,11

                        // Fastställd förvärvsinkomst överstiger 0,99 men inte 1,11 prisbasbelopp.
                        // Förhöjt grundavdrag = 0,885 prisbasbelopp minskat med 20 procent av den fastställda förvärvsinkomsten.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.885M);
                        baseDeduction -= Decimal.Multiply(annualSalary, 0.2M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                        {
                            #region 1,11 - 2,72

                            // Fastställd förvärvsinkomst överstiger 1,11 men inte 2,72 prisbasbelopp.
                            // Förhöjt grundavdrag = 0,6 prisbasbelopp ökat med 5,7 procent av den fastställda förvärvsinkomsten.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.6M);
                            baseDeduction += Decimal.Multiply(annualSalary, 0.057M);

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                            {
                                #region 2,72 - 3,11

                                // Fastställd förvärvsinkomst överstiger 2,72 men inte 3,11 prisbasbelopp.
                                // 34 procent av den fastställda förvärvsinkomsten minskat med 0,169 prisbasbelopp
                                baseDeduction = Decimal.Multiply(annualSalary, 0.34M);
                                baseDeduction -= Decimal.Multiply(baseAmount, 0.169M);

                                #endregion
                            }
                            else
                            {
                                if (annualSalary <= (Decimal.Multiply(baseAmount, 3.21M)))
                                {
                                    #region 3,11 - 3,21

                                    // Fastställd förvärvsinkomst överstiger 3,11 men inte 3,21 prisbasbelopp.
                                    // 44 procent av den fastställda förvärvsinkomsten minskat med 0,48 prisbasbelopp
                                    baseDeduction = Decimal.Multiply(annualSalary, 0.44M);
                                    baseDeduction -= Decimal.Multiply(baseAmount, 0.48M);

                                    #endregion
                                }
                                else
                                {
                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 4.45M)))
                                    {
                                        #region 3,21 - 4,45

                                        // Fastställd förvärvsinkomst överstiger 3,21 men inte 4,45 prisbasbelopp.
                                        // 0,2017 prisbasbelopp ökat med 22,8 procent av den fastställda förvärvsinkomsten
                                        baseDeduction = Decimal.Multiply(baseAmount, 0.207M);
                                        baseDeduction += Decimal.Multiply(annualSalary, 0.228M);

                                        #endregion
                                    }
                                    else
                                    {
                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 5.31M)))
                                        {
                                            #region 4,45 - 5,31

                                            // Fastställd förvärvsinkomst överstiger 4,45 men inte 5,31 prisbasbelopp.
                                            // 1,397 prisbasbelopp minskat med 3,9 procent av den fastställda förvärvsinkomsten
                                            baseDeduction = Decimal.Multiply(baseAmount, 1.397M);
                                            baseDeduction -= Decimal.Multiply(annualSalary, 0.039M);

                                            #endregion
                                        }
                                        else
                                        {
                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                                            {
                                                #region 5,31 - 7,88

                                                // Fastställd förvärvsinkomst överstiger 5,31 men inte 7,88 prisbasbelopp.
                                                // 0,763 prisbasbelopp ökat med 8 procent av den fastställda förvärvsinkomsten
                                                baseDeduction = Decimal.Multiply(baseAmount, 0.763M);
                                                baseDeduction += Decimal.Multiply(annualSalary, 0.08M);

                                                #endregion
                                            }
                                            else
                                            {
                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                                                {
                                                    #region 7,88 - 8,08

                                                    // Fastställd förvärvsinkomst överstiger 7,88 men inte 8,08 prisbasbelopp.
                                                    // 1,551 prisbasbelopp minskat med 2 procent av den fastställda förvärvsinkomsten
                                                    baseDeduction = Decimal.Multiply(baseAmount, 1.551M);
                                                    baseDeduction -= Decimal.Multiply(annualSalary, 0.02M);

                                                    #endregion
                                                }
                                                else
                                                {
                                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 13.54M)))
                                                    {
                                                        #region 8,08 - 13,54

                                                        // Fastställd förvärvsinkomst överstiger 8,08 men inte 13,54 prisbasbelopp.
                                                        // Förhöjt grundavdrag = 2,399 prisbasbelopp minskat med 12,5 procent av den fastställda förvärvsinkomsten.
                                                        baseDeduction = Decimal.Multiply(baseAmount, 2.399M);
                                                        baseDeduction -= Decimal.Multiply(annualSalary, 0.125M);

                                                        #endregion
                                                    }
                                                    else
                                                    {
                                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 34M)))
                                                        {
                                                            #region 13,54 - 34

                                                            // Fastställd förvärvsinkomst överstiger 8,08 men inte 13,54 prisbasbelopp.
                                                            // Förhöjt grundavdrag = 1,031 prisbasbelopp minskat med 2,4 procent av den fastställda förvärvsinkomsten.
                                                            baseDeduction = Decimal.Multiply(baseAmount, 1.031M);
                                                            baseDeduction -= Decimal.Multiply(annualSalary, 0.024M);

                                                            #endregion
                                                        }
                                                        else
                                                        {
                                                            #region 34 -

                                                            // Fastställd förvärvsinkomst överstiger 34 prisbasbelopp.
                                                            // Förhöjt grundavdrag = 0,215 prisbasbelopp.
                                                            baseDeduction = Decimal.Multiply(baseAmount, 0.215M);

                                                            #endregion
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Det förhöjda grundavdraget summeras med ordinarie grundvdrag, varefter summan avrundas uppåt till närmaste hundratal kronor.
            // Observera att delvärdena för det ordinarie och det förhöjda grundavdraget inte ska avrundas innan summeringen.

            // Add ordinary base deduction
            baseDeduction += CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount, false);

            // Round up to nearest 100
            baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        #endregion

        #region 2020

        private decimal CalculateIncreasedBaseDeductionSE_2020(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction = 0;

            if (date.Year - birthDate.Year > 65)
            {
                // Get increased base deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.99M)))
                {
                    #region 0 - 0,99

                    // Fastställd förvärvsinkomst överstiger inte 0,99 prisbasbelopp.
                    // Förhöjt grundavdrag = 0,687 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.687M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 1.11M)))
                    {
                        #region 0,99 - 1,11

                        // Fastställd förvärvsinkomst överstiger 0,99 men inte 1,11 prisbasbelopp.
                        // Förhöjt grundavdrag = 0,885 prisbasbelopp minskat med 20 procent av den fastställda förvärvsinkomsten.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.885M);
                        baseDeduction -= Decimal.Multiply(annualSalary, 0.2M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                        {
                            #region 1,11 - 2,72

                            // Fastställd förvärvsinkomst överstiger 1,11 men inte 2,72 prisbasbelopp.
                            // Förhöjt grundavdrag = 0,6 prisbasbelopp ökat med 5,7 procent av den fastställda förvärvsinkomsten.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.6M);
                            baseDeduction += Decimal.Multiply(annualSalary, 0.057M);

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                            {
                                #region 2,72 - 3,11

                                // Fastställd förvärvsinkomst överstiger 2,72 men inte 3,11 prisbasbelopp.
                                // 34 procent av den fastställda förvärvsinkomsten minskat med 0,169 prisbasbelopp
                                baseDeduction = Decimal.Multiply(annualSalary, 0.34M);
                                baseDeduction -= Decimal.Multiply(baseAmount, 0.169M);

                                #endregion
                            }
                            else
                            {
                                if (annualSalary <= (Decimal.Multiply(baseAmount, 3.21M)))
                                {
                                    #region 3,11 - 3,21

                                    // Fastställd förvärvsinkomst överstiger 3,11 men inte 3,21 prisbasbelopp.
                                    // 44 procent av den fastställda förvärvsinkomsten minskat med 0,48 prisbasbelopp
                                    baseDeduction = Decimal.Multiply(annualSalary, 0.44M);
                                    baseDeduction -= Decimal.Multiply(baseAmount, 0.48M);

                                    #endregion
                                }
                                else
                                {
                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 4.45M)))
                                    {
                                        #region 3,21 - 4,45

                                        // Fastställd förvärvsinkomst överstiger 3,21 men inte 4,45 prisbasbelopp.
                                        // 0,207 prisbasbelopp ökat med 22,8 procent av den fastställda förvärvsinkomsten
                                        baseDeduction = Decimal.Multiply(baseAmount, 0.207M);
                                        baseDeduction += Decimal.Multiply(annualSalary, 0.228M);

                                        #endregion
                                    }
                                    else
                                    {
                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                                        {
                                            #region 4,45 - 7,88

                                            // Fastställd förvärvsinkomst överstiger 4,45 men inte 7,88 prisbasbelopp.
                                            // 0,488 prisbasbelopp ökat med 16,5 procent av den fastställda förvärvsinkomsten
                                            baseDeduction = Decimal.Multiply(baseAmount, 0.488M);
                                            baseDeduction += Decimal.Multiply(annualSalary, 0.165M);

                                            #endregion
                                        }
                                        else
                                        {
                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                                            {
                                                #region 7,88 - 8,08

                                                // Fastställd förvärvsinkomst överstiger 7,88 men inte 8,08 prisbasbelopp.
                                                // 1,276 prisbasbelopp ökat med 6,5 procent av den fastställda förvärvsinkomsten
                                                baseDeduction = Decimal.Multiply(baseAmount, 1.276M);
                                                baseDeduction += Decimal.Multiply(annualSalary, 0.065M);

                                                #endregion
                                            }
                                            else
                                            {
                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 11.06M)))
                                                {
                                                    #region 8,08 - 11,06

                                                    // Fastställd förvärvsinkomst överstiger 8,08 men inte 11,06 prisbasbelopp.
                                                    // Förhöjt grundavdrag = 2,205 prisbasbelopp minskat med 5 procent av den fastställda förvärvsinkomsten.
                                                    baseDeduction = Decimal.Multiply(baseAmount, 2.205M);
                                                    baseDeduction -= Decimal.Multiply(annualSalary, 0.05M);

                                                    #endregion
                                                }
                                                else
                                                {
                                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 12.15M)))
                                                    {
                                                        #region 11,06 - 12,15

                                                        // Fastställd förvärvsinkomst överstiger 11,06 men inte 12,15 prisbasbelopp.
                                                        // Förhöjt grundavdrag = 7,102 prisbasbelopp minskat med 50 procent av den fastställda förvärvsinkomsten.
                                                        baseDeduction = Decimal.Multiply(baseAmount, 7.102M);
                                                        baseDeduction -= Decimal.Multiply(annualSalary, 0.5M);

                                                        #endregion
                                                    }
                                                    else
                                                    {
                                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 29.65M)))
                                                        {
                                                            #region 12,15 - 29,65

                                                            // Fastställd förvärvsinkomst överstiger 12,15 men inte 29,65 prisbasbelopp.
                                                            // Förhöjt grundavdrag = 1,654 prisbasbelopp minskat med 4,5 procent av den fastställda förvärvsinkomsten.
                                                            baseDeduction = Decimal.Multiply(baseAmount, 1.654M);
                                                            baseDeduction -= Decimal.Multiply(annualSalary, 0.045M);

                                                            #endregion
                                                        }
                                                        else
                                                        {
                                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 34M)))
                                                            {
                                                                #region 29,65 - 34

                                                                // Fastställd förvärvsinkomst överstiger 29,65 men inte 34 prisbasbelopp.
                                                                // Förhöjt grundavdrag = 1,031 prisbasbelopp minskat med 2,4 procent av den fastställda förvärvsinkomsten.
                                                                baseDeduction = Decimal.Multiply(baseAmount, 1.031M);
                                                                baseDeduction -= Decimal.Multiply(annualSalary, 0.024M);

                                                                #endregion
                                                            }
                                                            else
                                                            {
                                                                #region 34 -

                                                                // Fastställd förvärvsinkomst överstiger 34 prisbasbelopp.
                                                                // Förhöjt grundavdrag = 0,215 prisbasbelopp.
                                                                baseDeduction = Decimal.Multiply(baseAmount, 0.215M);

                                                                #endregion
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Det förhöjda grundavdraget summeras med ordinarie grundvdrag, varefter summan avrundas uppåt till närmaste hundratal kronor.
            // Observera att delvärdena för det ordinarie och det förhöjda grundavdraget inte ska avrundas innan summeringen.

            // Add ordinary base deduction
            baseDeduction += CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount, false);

            // Round up to nearest 100
            baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        #endregion

        #region 2021

        private decimal CalculateIncreasedBaseDeductionSE_2021(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction = 0;

            if (date.Year - birthDate.Year > 65)
            {
                // Get increased base deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.99M)))
                {
                    #region 0 - 0,99

                    // Fastställd förvärvsinkomst överstiger inte 0,99 prisbasbelopp.
                    // Förhöjt grundavdrag = 0,687 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.687M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 1.11M)))
                    {
                        #region 0,99 - 1,11

                        // Fastställd förvärvsinkomst överstiger 0,99 men inte 1,11 prisbasbelopp.
                        // Förhöjt grundavdrag = 0,885 prisbasbelopp minskat med 20 procent av den fastställda förvärvsinkomsten.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.885M);
                        baseDeduction -= Decimal.Multiply(annualSalary, 0.2M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                        {
                            #region 1,11 - 2,72

                            // Fastställd förvärvsinkomst överstiger 1,11 men inte 2,72 prisbasbelopp.
                            // Förhöjt grundavdrag = 0,6 prisbasbelopp ökat med 5,7 procent av den fastställda förvärvsinkomsten.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.6M);
                            baseDeduction += Decimal.Multiply(annualSalary, 0.057M);

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                            {
                                #region 2,72 - 3,11

                                // Fastställd förvärvsinkomst överstiger 2,72 men inte 3,11 prisbasbelopp.
                                // 34 procent av den fastställda förvärvsinkomsten minskat med 0,169 prisbasbelopp
                                baseDeduction = Decimal.Multiply(annualSalary, 0.34M);
                                baseDeduction -= Decimal.Multiply(baseAmount, 0.169M);

                                #endregion
                            }
                            else
                            {
                                if (annualSalary <= (Decimal.Multiply(baseAmount, 3.21M)))
                                {
                                    #region 3,11 - 3,21

                                    // Fastställd förvärvsinkomst överstiger 3,11 men inte 3,21 prisbasbelopp.
                                    // 44 procent av den fastställda förvärvsinkomsten minskat med 0,48 prisbasbelopp
                                    baseDeduction = Decimal.Multiply(annualSalary, 0.44M);
                                    baseDeduction -= Decimal.Multiply(baseAmount, 0.48M);

                                    #endregion
                                }
                                else
                                {
                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                                    {
                                        #region 3,21 - 7,88

                                        // Fastställd förvärvsinkomst överstiger 3,21 men inte 7,88 prisbasbelopp.
                                        // 0,207 prisbasbelopp ökat med 22,8 procent av den fastställda förvärvsinkomsten
                                        baseDeduction = Decimal.Multiply(baseAmount, 0.207M);
                                        baseDeduction += Decimal.Multiply(annualSalary, 0.228M);

                                        #endregion
                                    }
                                    else
                                    {
                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                                        {
                                            #region 7,88 - 8,08

                                            // Fastställd förvärvsinkomst överstiger 7,88 men inte 8,08 prisbasbelopp.
                                            // 0,995 prisbasbelopp ökat med 12,8 procent av den fastställda förvärvsinkomsten
                                            baseDeduction = Decimal.Multiply(baseAmount, 0.995M);
                                            baseDeduction += Decimal.Multiply(annualSalary, 0.128M);

                                            #endregion
                                        }
                                        else
                                        {
                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 11.28M)))
                                            {
                                                #region 8,08 - 11,28

                                                // Fastställd förvärvsinkomst överstiger 8,08 men inte 11,28 prisbasbelopp.
                                                // Förhöjt grundavdrag = 2,029 prisbasbelopp.
                                                baseDeduction = Decimal.Multiply(baseAmount, 2.029M);

                                                #endregion
                                            }
                                            else
                                            {
                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 12.53M)))
                                                {
                                                    #region 11,28 - 12,53

                                                    // Fastställd förvärvsinkomst överstiger 11,28 men inte 12,53 prisbasbelopp.
                                                    // Förhöjt grundavdrag = 9,023 prisbasbelopp minskat med 62 procent av den fastställda förvärvsinkomsten.
                                                    baseDeduction = Decimal.Multiply(baseAmount, 9.023M);
                                                    baseDeduction -= Decimal.Multiply(annualSalary, 0.62M);

                                                    #endregion
                                                }
                                                else
                                                {
                                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 13.54M)))
                                                    {
                                                        #region 12,53 - 13,54

                                                        // Fastställd förvärvsinkomst överstiger 12,53 men inte 13,54 prisbasbelopp.
                                                        // Förhöjt grundavdrag = 1,253 prisbasbelopp.
                                                        baseDeduction = Decimal.Multiply(baseAmount, 1.253M);

                                                        #endregion
                                                    }
                                                    else
                                                    {
                                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 35.36M)))
                                                        {
                                                            #region 13,54 - 35,36

                                                            // Fastställd förvärvsinkomst överstiger 13,54 men inte 35,36 prisbasbelopp.
                                                            // Förhöjt grundavdrag = 2,03 prisbasbelopp minskat med 5,74 procent av den fastställda förvärvsinkomsten.
                                                            baseDeduction = Decimal.Multiply(baseAmount, 2.03M);
                                                            baseDeduction -= Decimal.Multiply(annualSalary, 0.0574M);

                                                            #endregion
                                                        }
                                                        else
                                                        {
                                                            #region 35,36 -

                                                            // Fastställd förvärvsinkomst överstiger 35,36 prisbasbelopp.
                                                            // Förhöjt grundavdrag = 0.
                                                            baseDeduction = 0;

                                                            #endregion
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Det förhöjda grundavdraget summeras med ordinarie grundvdrag, varefter summan avrundas uppåt till närmaste hundratal kronor.
            // Observera att delvärdena för det ordinarie och det förhöjda grundavdraget inte ska avrundas innan summeringen.

            // Add ordinary base deduction
            baseDeduction += CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount, false);

            // Round up to nearest 100
            baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        #endregion

        #region 2022

        private decimal CalculateIncreasedBaseDeductionSE_2022(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction = 0;

            if (date.Year - birthDate.Year > 65)
            {
                // Get increased base deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Fastställd förvärvsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Förhöjt grundavdrag = 0,687 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.687M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 1.11M)))
                    {
                        #region 0,91 - 1,11

                        // Fastställd förvärvsinkomst överstiger 0,91 men inte 1,11 prisbasbelopp.
                        // Förhöjt grundavdrag = 0,885 prisbasbelopp minskat med 20 procent av den fastställda förvärvsinkomsten.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.885M);
                        baseDeduction -= Decimal.Multiply(annualSalary, 0.2M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 1.965M)))
                        {
                            #region 1,11 - 1,965

                            // Fastställd förvärvsinkomst överstiger 1,11 men inte 1,965 prisbasbelopp.
                            // Förhöjt grundavdrag = 0,6 prisbasbelopp ökat med 5,7 procent av den fastställda förvärvsinkomsten.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.6M);
                            baseDeduction += Decimal.Multiply(annualSalary, 0.057M);

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                            {
                                #region 1,965 - 2,72

                                // Fastställd förvärvsinkomst överstiger 1,965 men inte 2,72 prisbasbelopp.
                                // Förhöjt grundavdrag = 0,333 prisbasbelopp ökat med 19,49 procent av den fastställda förvärvsinkomsten.
                                baseDeduction = Decimal.Multiply(baseAmount, 0.333M);
                                baseDeduction += Decimal.Multiply(annualSalary, 0.1949M);

                                #endregion
                            }
                            else
                            {
                                if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                                {
                                    #region 2,72 - 3,11

                                    // Fastställd förvärvsinkomst överstiger 2,72 men inte 3,11 prisbasbelopp.
                                    // 39,49 procent av den fastställda förvärvsinkomsten minskat med 0,212 prisbasbelopp
                                    baseDeduction = Decimal.Multiply(annualSalary, 0.3949M);
                                    baseDeduction -= Decimal.Multiply(baseAmount, 0.212M);

                                    #endregion
                                }
                                else
                                {
                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.24M)))
                                    {
                                        #region 3,11 - 3,24

                                        // Fastställd förvärvsinkomst överstiger 3,11 men inte 3,24 prisbasbelopp.
                                        // 49,49 procent av den fastställda förvärvsinkomsten minskat med 0,523 prisbasbelopp
                                        baseDeduction = Decimal.Multiply(annualSalary, 0.4949M);
                                        baseDeduction -= Decimal.Multiply(baseAmount, 0.523M);

                                        #endregion
                                    }
                                    else
                                    {
                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 5.53M)))
                                        {
                                            #region 3,24 - 5,53

                                            // Fastställd förvärvsinkomst överstiger 3,24 men inte 5,53 prisbasbelopp.
                                            // Förhöjt grundavdrag = 0,325 prisbasbelopp ökat med 23,3 procent av den fastställda förvärvsinkomsten.
                                            baseDeduction = Decimal.Multiply(baseAmount, 0.325M);
                                            baseDeduction += Decimal.Multiply(annualSalary, 0.233M);

                                            #endregion
                                        }
                                        else
                                        {
                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                                            {
                                                #region 5,53 - 7,88

                                                // Fastställd förvärvsinkomst överstiger 5,53 men inte 7,88 prisbasbelopp.
                                                // 0,441 prisbasbelopp ökat med 21,2 procent av den fastställda förvärvsinkomsten
                                                baseDeduction = Decimal.Multiply(baseAmount, 0.441M);
                                                baseDeduction += Decimal.Multiply(annualSalary, 0.212M);

                                                #endregion
                                            }
                                            else
                                            {
                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                                                {
                                                    #region 7,88 - 8,08

                                                    // Fastställd förvärvsinkomst överstiger 7,88 men inte 8,08 prisbasbelopp.
                                                    // 1,104 prisbasbelopp ökat med 12,8 procent av den fastställda förvärvsinkomsten
                                                    baseDeduction = Decimal.Multiply(baseAmount, 1.104M);
                                                    baseDeduction += Decimal.Multiply(annualSalary, 0.128M);

                                                    #endregion
                                                }
                                                else
                                                {
                                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 11.48M)))
                                                    {
                                                        #region 8,08 - 11,48

                                                        // Fastställd förvärvsinkomst överstiger 8,08 men inte 11,48 prisbasbelopp.
                                                        // Förhöjt grundavdrag = 2,139 prisbasbelopp.
                                                        baseDeduction = Decimal.Multiply(baseAmount, 2.139M);

                                                        #endregion
                                                    }
                                                    else
                                                    {
                                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 12.8M)))
                                                        {
                                                            #region 11,48 - 12,8

                                                            // Fastställd förvärvsinkomst överstiger 11,48 men inte 12,8 prisbasbelopp.
                                                            // Förhöjt grundavdrag = 9,257 prisbasbelopp minskat med 62 procent av den fastställda förvärvsinkomsten.
                                                            baseDeduction = Decimal.Multiply(baseAmount, 9.257M);
                                                            baseDeduction -= Decimal.Multiply(annualSalary, 0.62M);

                                                            #endregion
                                                        }
                                                        else
                                                        {
                                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 13.54M)))
                                                            {
                                                                #region 12,8 - 13,54

                                                                // Fastställd förvärvsinkomst överstiger 12,8 men inte 13,54 prisbasbelopp.
                                                                // Förhöjt grundavdrag = 1,32 prisbasbelopp.
                                                                baseDeduction = Decimal.Multiply(baseAmount, 1.32M);

                                                                #endregion
                                                            }
                                                            else
                                                            {
                                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 36.54M)))
                                                                {
                                                                    #region 13,54 - 36,54

                                                                    // Fastställd förvärvsinkomst överstiger 13,54 men inte 36,54 prisbasbelopp.
                                                                    // Förhöjt grundavdrag = 2,097 prisbasbelopp minskat med 5,74 procent av den fastställda förvärvsinkomsten.
                                                                    baseDeduction = Decimal.Multiply(baseAmount, 2.097M);
                                                                    baseDeduction -= Decimal.Multiply(annualSalary, 0.0574M);

                                                                    #endregion
                                                                }
                                                                else
                                                                {
                                                                    #region 36,54 -

                                                                    // Fastställd förvärvsinkomst överstiger 36,54 prisbasbelopp.
                                                                    // Förhöjt grundavdrag = 0.
                                                                    baseDeduction = 0;

                                                                    #endregion
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Det förhöjda grundavdraget summeras med ordinarie grundvdrag, varefter summan avrundas uppåt till närmaste hundratal kronor.
            // Observera att delvärdena för det ordinarie och det förhöjda grundavdraget inte ska avrundas innan summeringen.

            // Add ordinary base deduction
            baseDeduction += CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount, false);

            // Round up to nearest 100
            baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        #endregion

        #region 2023

        private decimal CalculateIncreasedBaseDeductionSE_2023(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction = 0;

            if (date.Year - birthDate.Year > 66)
            {
                // Get increased base deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Fastställd förvärvsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Förhöjt grundavdrag = 0,687 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.687M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 1.11M)))
                    {
                        #region 0,91 - 1,11

                        // Fastställd förvärvsinkomst överstiger 0,91 men inte 1,11 prisbasbelopp.
                        // Förhöjt grundavdrag = 0,885 prisbasbelopp minskat med 20 procent av den fastställda förvärvsinkomsten.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.885M);
                        baseDeduction -= Decimal.Multiply(annualSalary, 0.2M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 1.965M)))
                        {
                            #region 1,11 - 1,965

                            // Fastställd förvärvsinkomst överstiger 1,11 men inte 1,965 prisbasbelopp.
                            // Förhöjt grundavdrag = 0,6 prisbasbelopp ökat med 5,7 procent av den fastställda förvärvsinkomsten.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.6M);
                            baseDeduction += Decimal.Multiply(annualSalary, 0.057M);

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                            {
                                #region 1,965 - 2,72

                                // Fastställd förvärvsinkomst överstiger 1,965 men inte 2,72 prisbasbelopp.
                                // Förhöjt grundavdrag = 0,333 prisbasbelopp ökat med 19,49 procent av den fastställda förvärvsinkomsten.
                                baseDeduction = Decimal.Multiply(baseAmount, 0.333M);
                                baseDeduction += Decimal.Multiply(annualSalary, 0.1949M);

                                #endregion
                            }
                            else
                            {
                                if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                                {
                                    #region 2,72 - 3,11

                                    // Fastställd förvärvsinkomst överstiger 2,72 men inte 3,11 prisbasbelopp.
                                    // 39,49 procent av den fastställda förvärvsinkomsten minskat med 0,212 prisbasbelopp
                                    baseDeduction = Decimal.Multiply(annualSalary, 0.3949M);
                                    baseDeduction -= Decimal.Multiply(baseAmount, 0.212M);

                                    #endregion
                                }
                                else
                                {
                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.24M)))
                                    {
                                        #region 3,11 - 3,24

                                        // Fastställd förvärvsinkomst överstiger 3,11 men inte 3,24 prisbasbelopp.
                                        // 49,49 procent av den fastställda förvärvsinkomsten minskat med 0,523 prisbasbelopp
                                        baseDeduction = Decimal.Multiply(annualSalary, 0.4949M);
                                        baseDeduction -= Decimal.Multiply(baseAmount, 0.523M);

                                        #endregion
                                    }
                                    else
                                    {
                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 5.53M)))
                                        {
                                            #region 3,24 - 5,53

                                            // Fastställd förvärvsinkomst överstiger 3,24 men inte 5,53 prisbasbelopp.
                                            // Förhöjt grundavdrag = 0,325 prisbasbelopp ökat med 23,3 procent av den fastställda förvärvsinkomsten.
                                            baseDeduction = Decimal.Multiply(baseAmount, 0.325M);
                                            baseDeduction += Decimal.Multiply(annualSalary, 0.233M);

                                            #endregion
                                        }
                                        else
                                        {
                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                                            {
                                                #region 5,53 - 7,88

                                                // Fastställd förvärvsinkomst överstiger 5,53 men inte 7,88 prisbasbelopp.
                                                // 0,441 prisbasbelopp ökat med 21,2 procent av den fastställda förvärvsinkomsten
                                                baseDeduction = Decimal.Multiply(baseAmount, 0.441M);
                                                baseDeduction += Decimal.Multiply(annualSalary, 0.212M);

                                                #endregion
                                            }
                                            else
                                            {
                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                                                {
                                                    #region 7,88 - 8,08

                                                    // Fastställd förvärvsinkomst överstiger 7,88 men inte 8,08 prisbasbelopp.
                                                    // 1,104 prisbasbelopp ökat med 12,8 procent av den fastställda förvärvsinkomsten
                                                    baseDeduction = Decimal.Multiply(baseAmount, 1.104M);
                                                    baseDeduction += Decimal.Multiply(annualSalary, 0.128M);

                                                    #endregion
                                                }
                                                else
                                                {
                                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 11.48M)))
                                                    {
                                                        #region 8,08 - 11,48

                                                        // Fastställd förvärvsinkomst överstiger 8,08 men inte 11,48 prisbasbelopp.
                                                        // Förhöjt grundavdrag = 2,139 prisbasbelopp.
                                                        baseDeduction = Decimal.Multiply(baseAmount, 2.139M);

                                                        #endregion
                                                    }
                                                    else
                                                    {
                                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 12.8M)))
                                                        {
                                                            #region 11,48 - 12,8

                                                            // Fastställd förvärvsinkomst överstiger 11,48 men inte 12,8 prisbasbelopp.
                                                            // Förhöjt grundavdrag = 9,257 prisbasbelopp minskat med 62 procent av den fastställda förvärvsinkomsten.
                                                            baseDeduction = Decimal.Multiply(baseAmount, 9.257M);
                                                            baseDeduction -= Decimal.Multiply(annualSalary, 0.62M);

                                                            #endregion
                                                        }
                                                        else
                                                        {
                                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 13.54M)))
                                                            {
                                                                #region 12,8 - 13,54

                                                                // Fastställd förvärvsinkomst överstiger 12,8 men inte 13,54 prisbasbelopp.
                                                                // Förhöjt grundavdrag = 1,32 prisbasbelopp.
                                                                baseDeduction = Decimal.Multiply(baseAmount, 1.32M);

                                                                #endregion
                                                            }
                                                            else
                                                            {
                                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 36.54M)))
                                                                {
                                                                    #region 13,54 - 36,54

                                                                    // Fastställd förvärvsinkomst överstiger 13,54 men inte 36,54 prisbasbelopp.
                                                                    // Förhöjt grundavdrag = 2,097 prisbasbelopp minskat med 5,74 procent av den fastställda förvärvsinkomsten.
                                                                    baseDeduction = Decimal.Multiply(baseAmount, 2.097M);
                                                                    baseDeduction -= Decimal.Multiply(annualSalary, 0.0574M);

                                                                    #endregion
                                                                }
                                                                else
                                                                {
                                                                    #region 36,54 -

                                                                    // Fastställd förvärvsinkomst överstiger 36,54 prisbasbelopp.
                                                                    // Förhöjt grundavdrag = 0.
                                                                    baseDeduction = 0;

                                                                    #endregion
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Det förhöjda grundavdraget summeras med ordinarie grundvdrag, varefter summan avrundas uppåt till närmaste hundratal kronor.
            // Observera att delvärdena för det ordinarie och det förhöjda grundavdraget inte ska avrundas innan summeringen.

            // Add ordinary base deduction
            baseDeduction += CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount, false);

            // Round up to nearest 100
            baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        #endregion

        #region 2024

        private decimal CalculateIncreasedBaseDeductionSE_2024(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction = 0;

            if (date.Year - birthDate.Year > 66)
            {
                // Get increased base deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Fastställd förvärvsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Förhöjt grundavdrag = 0,687 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.687M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 1.11M)))
                    {
                        #region 0,91 - 1,11

                        // Fastställd förvärvsinkomst överstiger 0,91 men inte 1,11 prisbasbelopp.
                        // Förhöjt grundavdrag = 0,885 prisbasbelopp minskat med 20 procent av den fastställda förvärvsinkomsten.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.885M);
                        baseDeduction -= Decimal.Multiply(annualSalary, 0.2M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 1.965M)))
                        {
                            #region 1,11 - 1,965

                            // Fastställd förvärvsinkomst överstiger 1,11 men inte 1,965 prisbasbelopp.
                            // Förhöjt grundavdrag = 0,6 prisbasbelopp ökat med 5,7 procent av den fastställda förvärvsinkomsten.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.6M);
                            baseDeduction += Decimal.Multiply(annualSalary, 0.057M);

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                            {
                                #region 1,965 - 2,72

                                // Fastställd förvärvsinkomst överstiger 1,965 men inte 2,72 prisbasbelopp.
                                // Förhöjt grundavdrag = 0,333 prisbasbelopp ökat med 19,49 procent av den fastställda förvärvsinkomsten.
                                baseDeduction = Decimal.Multiply(baseAmount, 0.333M);
                                baseDeduction += Decimal.Multiply(annualSalary, 0.1949M);

                                #endregion
                            }
                            else
                            {
                                if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                                {
                                    #region 2,72 - 3,11

                                    // Fastställd förvärvsinkomst överstiger 2,72 men inte 3,11 prisbasbelopp.
                                    // 39,49 procent av den fastställda förvärvsinkomsten minskat med 0,212 prisbasbelopp
                                    baseDeduction = Decimal.Multiply(annualSalary, 0.3949M);
                                    baseDeduction -= Decimal.Multiply(baseAmount, 0.212M);

                                    #endregion
                                }
                                else
                                {
                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.24M)))
                                    {
                                        #region 3,11 - 3,24

                                        // Fastställd förvärvsinkomst överstiger 3,11 men inte 3,24 prisbasbelopp.
                                        // 49,49 procent av den fastställda förvärvsinkomsten minskat med 0,523 prisbasbelopp
                                        baseDeduction = Decimal.Multiply(annualSalary, 0.4949M);
                                        baseDeduction -= Decimal.Multiply(baseAmount, 0.523M);

                                        #endregion
                                    }
                                    else
                                    {
                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 5.00M)))
                                        {
                                            #region 3,24 - 5,00

                                            // Fastställd förvärvsinkomst överstiger 3,24 men inte 5,00 prisbasbelopp.
                                            // Förhöjt grundavdrag = 0,208 prisbasbelopp ökat med 26,93 procent av den fastställda förvärvsinkomsten.
                                            baseDeduction = Decimal.Multiply(baseAmount, 0.208M);
                                            baseDeduction += Decimal.Multiply(annualSalary, 0.2693M);

                                            #endregion
                                        }
                                        else
                                        {
                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                                            {
                                                #region 5,00 - 7,88

                                                // Fastställd förvärvsinkomst överstiger 5,00 men inte 7,88 prisbasbelopp.
                                                // 0,300 prisbasbelopp ökat med 25,13 procent av den fastställda förvärvsinkomsten
                                                baseDeduction = Decimal.Multiply(baseAmount, 0.300M);
                                                baseDeduction += Decimal.Multiply(annualSalary, 0.2513M);

                                                #endregion
                                            }
                                            else
                                            {
                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                                                {
                                                    #region 7,88 - 8,08

                                                    // Fastställd förvärvsinkomst överstiger 7,88 men inte 8,08 prisbasbelopp.
                                                    // 0,986 prisbasbelopp ökat med 16,43 procent av den fastställda förvärvsinkomsten
                                                    baseDeduction = Decimal.Multiply(baseAmount, 0.986M);
                                                    baseDeduction += Decimal.Multiply(annualSalary, 0.1643M);

                                                    #endregion
                                                }
                                                else
                                                {
                                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 10.74M)))
                                                    {
                                                        #region 8,08 - 10,74

                                                        // Fastställd förvärvsinkomst överstiger 8,08 men inte 10,74 prisbasbelopp.
                                                        // Förhöjt grundavdrag = 2,313 prisbasbelopp.
                                                        baseDeduction = Decimal.Multiply(baseAmount, 2.313M);

                                                        #endregion
                                                    }
                                                    else
                                                    {
                                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 12.16M)))
                                                        {
                                                            #region 10,74 - 12,16

                                                            // Fastställd förvärvsinkomst överstiger 10,74 men inte 12,16 prisbasbelopp.
                                                            // Förhöjt grundavdrag = 8,972 prisbasbelopp minskat med 62 procent av den fastställda förvärvsinkomsten.
                                                            baseDeduction = Decimal.Multiply(baseAmount, 8.972M);
                                                            baseDeduction -= Decimal.Multiply(annualSalary, 0.62M);

                                                            #endregion
                                                        }
                                                        else
                                                        {
                                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 13.54M)))
                                                            {
                                                                #region 12,16 - 13,54

                                                                // Fastställd förvärvsinkomst överstiger 12,16 men inte 13,54 prisbasbelopp.
                                                                // Förhöjt grundavdrag = 1,430 prisbasbelopp.
                                                                baseDeduction = Decimal.Multiply(baseAmount, 1.430M);

                                                                #endregion
                                                            }
                                                            else
                                                            {
                                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 38.42M)))
                                                                {
                                                                    #region 13,54 - 38,42

                                                                    // Fastställd förvärvsinkomst överstiger 13,54 men inte 38,42 prisbasbelopp.
                                                                    // Förhöjt grundavdrag = 2,206 prisbasbelopp minskat med 5,74 procent av den fastställda förvärvsinkomsten.
                                                                    baseDeduction = Decimal.Multiply(baseAmount, 2.206M);
                                                                    baseDeduction -= Decimal.Multiply(annualSalary, 0.0574M);

                                                                    #endregion
                                                                }
                                                                else
                                                                {
                                                                    #region 38,42 -

                                                                    // Fastställd förvärvsinkomst överstiger 38,42 prisbasbelopp.
                                                                    // Förhöjt grundavdrag = 0.
                                                                    baseDeduction = 0;

                                                                    #endregion
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Det förhöjda grundavdraget summeras med ordinarie grundvdrag, varefter summan avrundas uppåt till närmaste hundratal kronor.
            // Observera att delvärdena för det ordinarie och det förhöjda grundavdraget inte ska avrundas innan summeringen.

            // Add ordinary base deduction
            baseDeduction += CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount, false);

            // Round up to nearest 100
            baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        #endregion

        #region 2025

        private decimal CalculateIncreasedBaseDeductionSE_2025(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction = 0;

            if (date.Year - birthDate.Year > 66)
            {
                // Get increased base deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Fastställd förvärvsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Förhöjt grundavdrag = 0,687 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.687M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 1.11M)))
                    {
                        #region 0,91 - 1,11

                        // Fastställd förvärvsinkomst överstiger 0,91 men inte 1,11 prisbasbelopp.
                        // Förhöjt grundavdrag = 0,885 prisbasbelopp minskat med 20 procent av den fastställda förvärvsinkomsten.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.885M);
                        baseDeduction -= Decimal.Multiply(annualSalary, 0.2M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 1.965M)))
                        {
                            #region 1,11 - 1,965

                            // Fastställd förvärvsinkomst överstiger 1,11 men inte 1,965 prisbasbelopp.
                            // Förhöjt grundavdrag = 0,6 prisbasbelopp ökat med 5,7 procent av den fastställda förvärvsinkomsten.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.6M);
                            baseDeduction += Decimal.Multiply(annualSalary, 0.057M);

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                            {
                                #region 1,965 - 2,72

                                // Fastställd förvärvsinkomst överstiger 1,965 men inte 2,72 prisbasbelopp.
                                // Förhöjt grundavdrag = 0,333 prisbasbelopp ökat med 19,49 procent av den fastställda förvärvsinkomsten.
                                baseDeduction = Decimal.Multiply(baseAmount, 0.333M);
                                baseDeduction += Decimal.Multiply(annualSalary, 0.1949M);

                                #endregion
                            }
                            else
                            {
                                if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                                {
                                    #region 2,72 - 3,11

                                    // Fastställd förvärvsinkomst överstiger 2,72 men inte 3,11 prisbasbelopp.
                                    // 39,49 procent av den fastställda förvärvsinkomsten minskat med 0,212 prisbasbelopp
                                    baseDeduction = Decimal.Multiply(annualSalary, 0.3949M);
                                    baseDeduction -= Decimal.Multiply(baseAmount, 0.212M);

                                    #endregion
                                }
                                else
                                {
                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.24M)))
                                    {
                                        #region 3,11 - 3,24

                                        // Fastställd förvärvsinkomst överstiger 3,11 men inte 3,24 prisbasbelopp.
                                        // 49,49 procent av den fastställda förvärvsinkomsten minskat med 0,523 prisbasbelopp
                                        baseDeduction = Decimal.Multiply(annualSalary, 0.4949M);
                                        baseDeduction -= Decimal.Multiply(baseAmount, 0.523M);

                                        #endregion
                                    }
                                    else
                                    {
                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 5.00M)))
                                        {
                                            #region 3,24 - 5,00

                                            // Fastställd förvärvsinkomst överstiger 3,24 men inte 5,00 prisbasbelopp.
                                            // Förhöjt grundavdrag = 0,096 prisbasbelopp ökat med 30,40 procent av den fastställda förvärvsinkomsten.
                                            baseDeduction = Decimal.Multiply(baseAmount, 0.096M);
                                            baseDeduction += Decimal.Multiply(annualSalary, 0.3040M);

                                            #endregion
                                        }
                                        else
                                        {
                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                                            {
                                                #region 5,00 - 7,88

                                                // Fastställd förvärvsinkomst överstiger 5,00 men inte 7,88 prisbasbelopp.
                                                // 0,186 prisbasbelopp ökat med 28,60 procent av den fastställda förvärvsinkomsten
                                                baseDeduction = Decimal.Multiply(baseAmount, 0.186M);
                                                baseDeduction += Decimal.Multiply(annualSalary, 0.2860M);

                                                #endregion
                                            }
                                            else
                                            {
                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                                                {
                                                    #region 7,88 - 8,08

                                                    // Fastställd förvärvsinkomst överstiger 7,88 men inte 8,08 prisbasbelopp.
                                                    // 0,872 prisbasbelopp ökat med 19,90 procent av den fastställda förvärvsinkomsten
                                                    baseDeduction = Decimal.Multiply(baseAmount, 0.872M);
                                                    baseDeduction += Decimal.Multiply(annualSalary, 0.1990M);

                                                    #endregion
                                                }
                                                else
                                                {
                                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 10.94M)))
                                                    {
                                                        #region 8,08 - 10,94

                                                        // Fastställd förvärvsinkomst överstiger 8,08 men inte 10,94 prisbasbelopp.
                                                        // Förhöjt grundavdrag = 2,48 prisbasbelopp.
                                                        baseDeduction = Decimal.Multiply(baseAmount, 2.48M);

                                                        #endregion
                                                    }
                                                    else
                                                    {
                                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 12.47M)))
                                                        {
                                                            #region 10,94 - 12,47

                                                            // Fastställd förvärvsinkomst överstiger 10,94 men inte 12,47 prisbasbelopp.
                                                            // Förhöjt grundavdrag = 9,263 prisbasbelopp minskat med 62 procent av den fastställda förvärvsinkomsten.
                                                            baseDeduction = Decimal.Multiply(baseAmount, 9.263M);
                                                            baseDeduction -= Decimal.Multiply(annualSalary, 0.62M);

                                                            #endregion
                                                        }
                                                        else
                                                        {
                                                            #region 12,47 - 

                                                            // Fastställd förvärvsinkomst överstiger 12,47 
                                                            // Förhöjt grundavdrag = 1,532 prisbasbelopp.
                                                            baseDeduction = Decimal.Multiply(baseAmount, 1.532M);

                                                            #endregion

                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Det förhöjda grundavdraget summeras med ordinarie grundvdrag, varefter summan avrundas uppåt till närmaste hundratal kronor.
            // Observera att delvärdena för det ordinarie och det förhöjda grundavdraget inte ska avrundas innan summeringen.

            // Add ordinary base deduction
            baseDeduction += CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount, false);

            // Round up to nearest 100
            baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        #endregion

        #region 2026

        private decimal CalculateIncreasedBaseDeductionSE_2026(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Get base deduction based on income relative to base amount
            decimal baseDeduction = 0;

            if (date.Year - birthDate.Year > 66)
            {
                // Get increased base deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Fastställd förvärvsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Förhöjt grundavdrag = 0,687 prisbasbelopp.
                    baseDeduction = Decimal.Multiply(baseAmount, 0.687M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 1.11M)))
                    {
                        #region 0,91 - 1,11

                        // Fastställd förvärvsinkomst överstiger 0,91 men inte 1,11 prisbasbelopp.
                        // Förhöjt grundavdrag = 0,885 prisbasbelopp minskat med 20 procent av den fastställda förvärvsinkomsten.
                        baseDeduction = Decimal.Multiply(baseAmount, 0.885M);
                        baseDeduction -= Decimal.Multiply(annualSalary, 0.2M);

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 1.965M)))
                        {
                            #region 1,11 - 1,965

                            // Fastställd förvärvsinkomst överstiger 1,11 men inte 1,965 prisbasbelopp.
                            // Förhöjt grundavdrag = 0,6 prisbasbelopp ökat med 5,7 procent av den fastställda förvärvsinkomsten.
                            baseDeduction = Decimal.Multiply(baseAmount, 0.6M);
                            baseDeduction += Decimal.Multiply(annualSalary, 0.057M);

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 2.72M)))
                            {
                                #region 1,965 - 2,72

                                // Fastställd förvärvsinkomst överstiger 1,965 men inte 2,72 prisbasbelopp.
                                // Förhöjt grundavdrag = 0,333 prisbasbelopp ökat med 19,49 procent av den fastställda förvärvsinkomsten.
                                baseDeduction = Decimal.Multiply(baseAmount, 0.333M);
                                baseDeduction += Decimal.Multiply(annualSalary, 0.1949M);

                                #endregion
                            }
                            else
                            {
                                if (annualSalary <= (Decimal.Multiply(baseAmount, 3.11M)))
                                {
                                    #region 2,72 - 3,11

                                    // Fastställd förvärvsinkomst överstiger 2,72 men inte 3,11 prisbasbelopp.
                                    // 39,49 procent av den fastställda förvärvsinkomsten minskat med 0,212 prisbasbelopp
                                    baseDeduction = Decimal.Multiply(annualSalary, 0.3949M);
                                    baseDeduction -= Decimal.Multiply(baseAmount, 0.212M);

                                    #endregion
                                }
                                else
                                {
                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.24M)))
                                    {
                                        #region 3,11 - 3,24

                                        // Fastställd förvärvsinkomst överstiger 3,11 men inte 3,24 prisbasbelopp.
                                        // 49,49 procent av den fastställda förvärvsinkomsten minskat med 0,523 prisbasbelopp
                                        baseDeduction = Decimal.Multiply(annualSalary, 0.4949M);
                                        baseDeduction -= Decimal.Multiply(baseAmount, 0.523M);

                                        #endregion
                                    }
                                    else
                                    {
                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 5.00M)))
                                        {
                                            #region 3,24 - 5,00

                                            // Fastställd förvärvsinkomst överstiger 3,24 men inte 5,00 prisbasbelopp.
                                            // 35,6 procent av den fastställda förvärvsinkomsten minskat med 0,073 prisbasbelopp                                                                                        
                                            baseDeduction = Decimal.Multiply(annualSalary, 0.356M);
                                            baseDeduction -= Decimal.Multiply(baseAmount, 0.073M);

                                            #endregion
                                        }
                                        else
                                        {
                                            if (annualSalary <= (Decimal.Multiply(baseAmount, 7.88M)))
                                            {
                                                #region 5,00 - 7,88

                                                // Fastställd förvärvsinkomst överstiger 5,00 men inte 7,88 prisbasbelopp.
                                                // 0,017 prisbasbelopp ökat med 33,80 procent av den fastställda förvärvsinkomsten
                                                baseDeduction = Decimal.Multiply(baseAmount, 0.017M);
                                                baseDeduction += Decimal.Multiply(annualSalary, 0.3380M);

                                                #endregion
                                            }
                                            else
                                            {
                                                if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                                                {
                                                    #region 7,88 - 8,08

                                                    // Fastställd förvärvsinkomst överstiger 7,88 men inte 8,08 prisbasbelopp.
                                                    // 0,703 prisbasbelopp ökat med 25,10 procent av den fastställda förvärvsinkomsten
                                                    baseDeduction = Decimal.Multiply(baseAmount, 0.703M);
                                                    baseDeduction += Decimal.Multiply(annualSalary, 0.2510M);

                                                    #endregion
                                                }
                                                else
                                                {
                                                    if (annualSalary <= (Decimal.Multiply(baseAmount, 11.16M)))
                                                    {
                                                        #region 8,08 - 11,16

                                                        // Fastställd förvärvsinkomst överstiger 8,08 men inte 11,16 prisbasbelopp.
                                                        // Förhöjt grundavdrag = 2,732 prisbasbelopp.
                                                        baseDeduction = Decimal.Multiply(baseAmount, 2.732M);

                                                        #endregion
                                                    }
                                                    else
                                                    {
                                                        if (annualSalary <= (Decimal.Multiply(baseAmount, 12.84M)))
                                                        {
                                                            #region 11,16 - 12,84

                                                            // Fastställd förvärvsinkomst överstiger 11,16 men inte 12,84 prisbasbelopp.
                                                            // Förhöjt grundavdrag = 9,651 prisbasbelopp minskat med 62 procent av den fastställda förvärvsinkomsten.
                                                            baseDeduction = Decimal.Multiply(baseAmount, 9.651M);
                                                            baseDeduction -= Decimal.Multiply(annualSalary, 0.62M);

                                                            #endregion
                                                        }
                                                        else
                                                        {
                                                            #region 12,84 - 

                                                            // Fastställd förvärvsinkomst överstiger 12,84 
                                                            // Förhöjt grundavdrag = 1,691 prisbasbelopp.
                                                            baseDeduction = Decimal.Multiply(baseAmount, 1.691M);

                                                            #endregion

                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Det förhöjda grundavdraget summeras med ordinarie grundvdrag, varefter summan avrundas uppåt till närmaste hundratal kronor.
            // Observera att delvärdena för det ordinarie och det förhöjda grundavdraget inte ska avrundas innan summeringen.

            // Add ordinary base deduction
            baseDeduction += CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount, false);

            // Round up to nearest 100
            baseDeduction = Decimal.Multiply(Math.Ceiling(Decimal.Divide(baseDeduction, 100M)), 100M);

            if (baseDeduction > annualSalary)
                baseDeduction = annualSalary;

            return baseDeduction;
        }

        #endregion

        #endregion

        #region Income tax (Inkomstskatt)

        // Årsinkomsten räknas fram på så sätt att det högsta beloppet inom varje inkomstskikt i skattetabellerna multipliceras med antalet lönetillfällen per år.
        // Avrundning ska göras nedåt till helt hundratal.
        // Om det t.ex. är fråga om månadslön som ligger inom inkomstskiktet 21 201 – 21 400 kr i månadstabellen, multipliceras 21 400 med 12.
        // Om månadsinkomsten skulle vara lägre än det högsta beloppet i inkomstskiktet kan man inte göra en exakt beräkning och multiplicera detta lägre belopp med 12 för att få fram årsinkomsten.

        #region State (Statlig inkomstskatt)

        // Uträknat belopp (högsta beloppet i inkomstskiktet x 12) utgör beräknad årsinkomst. Beloppet utgör även beräknad fastställd förvärvsinkomst till statlig inkomstskatt.
        // Från den fastställda förvärvsinkomsten görs sedan avdrag för grundavdrag för att få fram den beskattningsbara förvärvsinkomsten.
        // Statlig inkomstskatt ska betalas med 20 % av den del av den beskattningsbara förvärvsinkomsten som överstiger XXX XXX kr
        // och med ytterligare 5% på den del av den beskattningsbara förvärvsinkomsten som överstiger YYY YYY kr.

        public decimal CalculateStateIncomeTaxSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0, decimal baseDeduction = 0)
        {
            // Same calculation for all years, only different amount limits

            decimal limit1amount;
            decimal limit1percent = 20;
            decimal limit2amount = 0;
            decimal limit2percent = 5;

            switch (date.Year)
            {
                case 2014:
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 420 800 kr och ytterligare 5 procent av den del av den beskattningsbara förförvärvsinkomsten
                    // som överstiger 602 600 kr
                    limit1amount = 420800;
                    limit2amount = 602600;
                    break;
                case 2015:
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 430 200 kr och ytterligare 5 procent av den del av den beskattningsbara förförvärvsinkomsten
                    // som överstiger 616 100 kr
                    limit1amount = 430200;
                    limit2amount = 616100;
                    break;
                case 2016:
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 430 200 kr och ytterligare 5 procent av den del av den beskattningsbara förförvärvsinkomsten
                    // som överstiger 625 800 kr
                    limit1amount = 430200;
                    limit2amount = 625800;
                    break;
                case 2017:
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 438 900 kr och ytterligare 5 procent av den del av den beskattningsbara förförvärvsinkomsten
                    // som överstiger 638 500 kr
                    limit1amount = 438900;
                    limit2amount = 638500;
                    break;
                case 2018:
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 455 300 kr och ytterligare 5 procent av den del av den beskattningsbara förförvärvsinkomsten
                    // som överstiger 662 300 kr
                    limit1amount = 455300;
                    limit2amount = 662300;
                    break;
                case 2019:
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 490 700 kr och ytterligare 5 procent av den del av den beskattningsbara förförvärvsinkomsten
                    // som överstiger 689 300 kr
                    limit1amount = 490700;
                    limit2amount = 689300;
                    break;
                case 2020:
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 509 300 kr. De ytterligare 5 % statlig inkomstskatt utgår fr.o.m. inkomståret 2020.
                    limit1amount = 509300;
                    break;
                case 2021:
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 523 200 kr.
                    limit1amount = 523200;
                    break;
                case 2022:
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 540 700 kr.
                    limit1amount = 540700;
                    break;
                case 2023:
                case 2024:  // Ingen förändring från 2023
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 598 500 kr.
                    limit1amount = 598500;
                    break;
                case 2025:
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 625 800 kr.
                    limit1amount = 625800;
                    break;
                case 2026:
                    // Statlig inkomstskatt på förvärvsinkomster utgör 20 procent av den del av den beskattningsbara förvärvsinkomsten
                    // som överstiger 643 000 kr.
                    limit1amount = 643000;
                    break;
                default:
                    return 0;
            }

            if (baseDeduction == 0)
                baseDeduction = CalculateIncreasedBaseDeductionSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
            annualSalary -= baseDeduction;

            if (annualSalary <= limit1amount)
                return 0;

            decimal tax = Decimal.Multiply((Decimal.Subtract(annualSalary, limit1amount)), (Decimal.Divide(limit1percent, 100M)));

            if (limit2amount > 0 && annualSalary > limit2amount)
                tax += Decimal.Multiply((Decimal.Subtract(annualSalary, limit2amount)), (Decimal.Divide(limit2percent, 100M)));

            return tax;
        }

        #endregion

        #region County (Kommunal inkomstskatt)

        // Den till kommunal inkomstskatt fastställda och beskattningsbara förvärvsinkomsten beräknas på samma sätt som sägs om statlig inkomstskatt.
        // Den kommunala inkomstskatten består av kommunalskatt och landstingsskatt.

        // Skattetabellerna ska ange skatteavdraget med utgångspunkt från att kommunal inkomstskatt, begravningsavgift och avgift till registrerat trossamfund
        // beräknas efter en sammanlagd skatte- och avgiftssats i hela krontal, vid 50 avrundas nedåt.
        // För att få fram kommunal inkomstskatt, begravningsavgift och avgift till trossamfund ska den kommunalt beskattningsbara förvärvsinkomsten
        // multipliceras med den sammanlagda skatte- och avgiftssatsen.
        // Begravningsavgift och avgift till trossamfund ska anses ingå i den sammanlagda skatte- och avgiftssatsen med 1,16 procentenheter.

        public decimal CalculateCountyIncomeTaxSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, int taxRate, decimal baseAmount = 0, decimal baseDeduction = 0)
        {
            if (baseDeduction == 0)
                baseDeduction = CalculateIncreasedBaseDeductionSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);

            decimal tax = Decimal.Multiply(Decimal.Subtract(annualSalary, baseDeduction), Decimal.Divide((Decimal.Subtract(taxRate, GetChurchFeeRateSE(date))), 100M));

            // Avrundas till hela krontal, vid 50 öre avrundas nedåt.
            //tax *= 100M;
            //if (tax % 50 == 0)
            //    tax = (int)Decimal.Divide(tax, 100M);
            //else
            //    tax = Math.Round(Decimal.Divide(tax, 100M), 0, MidpointRounding.AwayFromZero);

            // Se tekniska beskrivningen för hur kommunalskattska beräknas: Efter uträkning bortfaller öretal.
            tax = Math.Truncate(tax);

            return tax;
        }

        #endregion

        #endregion

        #region Public service fee

        // Fr.o.m. inkomståret 2019 ingår Public service-avgift (Radio och TV-avgift) i skattetabellerna.
        // Avgiften ingår i samtliga kolumner både i de Allmänna skattetabellerna samt i Sjöinkomsttabellerna.
        // Avgiften baseras på inkomstbasbeloppet.

        public decimal CalculatePublicServiceFeeSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0, decimal baseDeduction = 0, int sysCountryId = 0)
        {
            decimal baseAmountLimit;

            switch (date.Year)
            {
                case 2019:
                case 2020:
                    baseAmountLimit = 2.092M;
                    break;
                case 2021:
                    baseAmountLimit = 1.95M;
                    break;
                case 2022:
                    baseAmountLimit = 1.87M;
                    break;
                case 2023:
                    baseAmountLimit = 1.75M;
                    break;
                case 2024:
                    baseAmountLimit = 1.60M;
                    break;
                case 2025:
                    baseAmountLimit = 1.55M;
                    break;
                case 2026:
                    baseAmountLimit = 1.42M;
                    break;
                default:
                    return 0;
            }

            if (baseDeduction == 0)
                baseDeduction = CalculateIncreasedBaseDeductionSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);
            annualSalary -= baseDeduction;

            decimal incomeBaseAmount = GetIncomeBaseAmountSE(entities, actorCompanyId, date, sysCountryId);

            decimal fee;

            // Get fee based on income relative to income base amount
            if (annualSalary <= (Decimal.Multiply(incomeBaseAmount, baseAmountLimit)))
            {
                #region 0 - limit

                // Beskattningsbar förvärvsinkomst överstiger inte X,XXX inkomstbasbelopp.
                // Avgift = 1 procent av beskattningsbar förvärvsinkomst

                fee = Decimal.Multiply(annualSalary, 0.01M);

                #endregion
            }
            else
            {
                #region limit -

                // Beskattningsbar förvärvsinkomst överstiger X,XXX inkomstbasbelopp.
                // Avgift = 1 procent av X,XXX inkomstbasbelopp

                fee = Decimal.Multiply(Decimal.Multiply(incomeBaseAmount, baseAmountLimit), 0.01M);

                #endregion
            }

            // Remove decimals
            fee = Math.Truncate(fee);

            return fee;
        }

        #endregion

        #region National pension fee (Allmän pensionsavgift)

        public decimal CalculateNationalPensionFeeSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0, int sysCountryId = 0)
        {
            // Same calculation for all years
            // Only different amount limits

            // Allmän pensionsavgift ska inte betalas av personer som är födda 1937 eller tidigare.
            // Någon nedre åldersgräns för uttag av avgiften finns inte.
            if (birthDate.Year <= 1937)
                return 0;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Allmän pensionsavgift betalas inte av den som har pensionsgrundande inkomster under året som understiger 42,3 % av prisbasbeloppet.
            if (annualSalary < Decimal.Multiply(baseAmount, 0.423M))
                return 0;

            // Avgiftstaket för den allmänna pensionsavgiften har fastställts till XX XXX kr.
            decimal limitAmount = GetIncomeBaseAmountSE(entities, actorCompanyId, date, sysCountryId);
            decimal maxIncome = Decimal.Multiply(limitAmount, 8.07M);
            if (annualSalary > maxIncome)
                annualSalary = maxIncome;

            // För inkomståret ska allmän pensionsavgift betalas med 7 % på avgiftsunderlaget.
            decimal fee = Decimal.Multiply(annualSalary, 0.07M);

            // Allmän pensionsavgift ska avrundas till närmast hela hundratal kronor. Avgift som slutar på 50 kr avrundas till närmaste lägre hundratal kronor.
            if (fee % 50 == 0)
                fee = (int)Decimal.Divide(fee, 100M);
            else
                fee = Math.Round(Decimal.Divide(fee, 100M), 0, MidpointRounding.AwayFromZero);
            fee *= 100M;

            return fee;
        }

        #endregion

        #region Tax deduction (Skattereduktion)

        // I de allmänna skattetabellerna ingår för inkomståret 2014 två typer av skattereduktion, skattereduktion för allmän pensionsavgift och skattereduktion för arbetsinkomst.
        // Begravningsavgift och avgift till trossamfund får inte påverkas av någon skattereduktion.
        // Dessa avgifter ingår i de sammanlagda skatte- och avgiftssatserna (29-40) som tabellerna är upprättade i.
        // Vid beräkning av den totala skatten har detta betydelse vid låga inkomstskikt.

        // För att få korrekta skatteavdrag i tabellverken ska, vid beräkning av skattereduktion, begravningsavgift och avgift till registrerat trossamfund beräknas ingå
        // i de sammanlagda skatte- och avgiftssatserna med 1,2 procentenheter.

        // Skattereduktion för arbetsinkomst ska göras efter skattereduktion för allmän pensionsavgift.

        #region Tax deduction for national pension fee (Skattereduktion för allmän pensionsavgift)

        // Skattereduktionen för allmän pensionsavgift är 100 % av avgiften, som beräknas i CalculateNationalPensionFeeSE.
        // Skattereduktion för allmän pensionsavgift får inte överstiga summan av statlig och kommunal inkomstskatt,
        // enligt CalculateStateIncomeTaxSE och CalculateCountyIncomeTaxSE.

        public decimal CalculateTaxDeductionForNationalPensionFeeSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, int taxRate, decimal baseAmount = 0, decimal baseDeduction = 0, int sysCountryId = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date, sysCountryId);

            // Get national pension fee
            decimal fee = CalculateNationalPensionFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount, sysCountryId);

            // Get state and county tax
            decimal tax = CalculateStateIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount, baseDeduction) + CalculateCountyIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction);

            // Fee can not exceed state and county tax
            if (fee > tax)
                fee = tax;

            return fee;
        }

        #endregion

        #region Tax deduction for income (Skattereduktion för arbetsinkomst)

        // Med arbetsinkomst menas i detta sammanhang fastställd förvärvsinkomst eller årsinkomst.

        // Skattereduktionen för arbetsinkomst ska endast räknas av mot kommunal inkomstskatt.
        // Vid beräkningen av skattereduktionen ska arbetsinkomsten avrundas nedåt till helt hundratal kronor.
        // Uträkningen av reduktionen görs med decimaler och avrundas nedåt till hel krona.
        // Skattereduktion för den som vid inkomstårets ingång inte fyllt 65 år räknas på följande sätt:

        #region Common

        public decimal CalculateTaxDeductionForIncomeSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, int taxRate, decimal baseAmount = 0, decimal baseDeduction = 0, int sysCountryId = 0)
        {
            switch (date.Year)
            {
                case 2014:
                case 2015:
                    return CalculateTaxDeductionForIncomeSE_2014(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction);
                case 2016:
                case 2017:
                case 2018:
                    return CalculateTaxDeductionForIncomeSE_2016(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
                case 2019:
                case 2020:
                case 2021:
                    return CalculateTaxDeductionForIncomeSE_2019(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
                case 2022:
                    return CalculateTaxDeductionForIncomeSE_2022(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
                case 2023:
                    return CalculateTaxDeductionForIncomeSE_2023(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
                case 2024:
                    return CalculateTaxDeductionForIncomeSE_2024(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
                case 2025:
                    return CalculateTaxDeductionForIncomeSE_2025(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
                case 2026:
                    return CalculateTaxDeductionForIncomeSE_2026(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
                default:
                    return 0;
            }
        }

        #endregion

        #region 2014-2015

        public decimal CalculateTaxDeductionForIncomeSE_2014(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, int taxRate, decimal baseAmount = 0, decimal baseDeduction = 0)
        {
            decimal deduction;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Round down to nearest 100
            annualSalary = Decimal.Multiply(Math.Floor(Decimal.Divide(annualSalary, 100M)), 100M);

            if (date.Year - birthDate.Year <= 65)
            {
                #region Skattereduktion för den som vid inkomstårets ingång inte fyllt 65 år

                // Grundavdrag
                if (baseDeduction == 0)
                    baseDeduction = CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount);

                // Get tax deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Arbetsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Skattereduktion = skillnaden mellan arbetsinkomsten och grundavdraget, multiplicerat med skattesatsen för kommunal inkomstskatt
                    // (exkl. 1,2 procentenheter för begravningsavgift och avgift till trossamfund).

                    deduction = Decimal.Subtract(annualSalary, baseDeduction);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 2.94M)))
                    {
                        #region 0,91 - 2,94

                        // Arbetsinkomst överstiger 0,91 men inte 2,94 prisbasbelopp.
                        // Skattereduktion = skillnaden mellan å ena sidan av 0,91 prisbasbelopp och 33,2 procent av arbetsinkomsten mellan 0,91 och 2,94 prisbasbelopp och å andra sidan av grundavdraget,
                        // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,2 procentenheter för begravningsavgift och avgift till trossamfund).

                        deduction = Decimal.Multiply(baseAmount, 0.91M);
                        deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 0.91M)), 0.332M);
                        deduction -= baseDeduction;

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                        {
                            #region 2,94 - 8,08

                            // Arbetsinkomst överstiger 2,94 men inte 8,08 prisbasbelopp.
                            // Skattereduktion = skillnaden mellan å ena sidan av 1,584 prisbasbelopp och 11,1 procent av arbetsinkomsten mellan 2,94 och 8,08 prisbasbelopp och å andra sidan av grundavdraget,
                            // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,2 procentenheter för begravningsavgift och avgift till trossamfund).

                            deduction = Decimal.Multiply(baseAmount, 1.584M);
                            deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 2.94M)), 0.111M);
                            deduction -= baseDeduction;

                            #endregion
                        }
                        else
                        {
                            #region 8,08 -

                            // Arbetsinkomst överstiger 8,08 prisbasbelopp.
                            // Skattereduktion = skillnaden mellan 2,155 prisbasbelopp och grundavdraget,
                            // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,2 procentenheter för begravningsavgift och avgift till trossamfund).

                            deduction = Decimal.Multiply(baseAmount, 2.155M);
                            deduction -= baseDeduction;

                            #endregion
                        }
                    }
                }

                // Multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,2 procentenheter för begravningsavgift och avgift till trossamfund).
                deduction = Decimal.Multiply(deduction, Decimal.Divide((Decimal.Subtract(taxRate, GetChurchFeeRateSE(date))), 100M));
                // Avrunda till hela kronor
                deduction = Decimal.Round(deduction, 0, MidpointRounding.AwayFromZero);

                #endregion
            }
            else
            {
                #region Skattereduktion för den som vid inkomstårets ingång fyllt 65

                deduction = CalculateTaxDeductionForIncomeOver65_2014(annualSalary);

                #endregion
            }

            // Deduction can not exceed county tax reduced with national pension fee
            decimal countyTax = CalculateCountyIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount);
            decimal pensionFee = CalculateTaxDeductionForNationalPensionFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction);
            if (deduction > (countyTax - pensionFee))
                deduction = countyTax - pensionFee;

            if (deduction < 0)
                deduction = 0;

            return deduction;
        }

        private decimal CalculateTaxDeductionForIncomeOver65_2014(decimal annualSalary)
        {
            decimal deduction;

            if (annualSalary <= 100000M)
            {
                #region 0 - 100.000 kr

                // Arbetsinkomst överstiger inte 100 000 kr.
                // Skattereduktion = arbetsinkomsten multiplicerad med 20 procent.

                deduction = Decimal.Multiply(annualSalary, 0.2M);

                #endregion
            }
            else
            {
                if (annualSalary <= 300000M)
                {
                    #region 100.000 kr - 300.000 kr

                    // Arbetsinkomst överstiger 100 000 kr men inte 300 000 kr.
                    // Skattereduktion = fast belopp om 15 000 kr ökat med 5 procent av arbetsinkomsten.

                    deduction = 15000M + Decimal.Multiply(annualSalary, 0.05M);

                    #endregion
                }
                else
                {
                    #region 300.000 kr -

                    // Arbetsinkomst överstiger 300 000 kr.
                    // Skattereduktion = fast belopp om 30 000 kr.

                    deduction = 30000M;

                    #endregion
                }
            }

            return deduction;
        }

        #endregion

        #region 2016-2018

        public decimal CalculateTaxDeductionForIncomeSE_2016(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, int taxRate, decimal baseAmount = 0, decimal baseDeduction = 0, int sysCountryId = 0)
        {
            decimal deduction;
            decimal additionalDeduction = 0;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Round down to nearest 100
            annualSalary = Decimal.Multiply(Math.Floor(Decimal.Divide(annualSalary, 100M)), 100M);

            if (date.Year - birthDate.Year <= 65)
            {
                #region Skattereduktion för den som vid inkomstårets ingång inte fyllt 65 år

                // Grundavdrag
                if (baseDeduction == 0)
                    baseDeduction = CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount);

                // Get tax deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Arbetsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Skattereduktion = skillnaden mellan arbetsinkomsten och grundavdraget, multiplicerat med skattesatsen för kommunal inkomstskatt
                    // (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                    deduction = Decimal.Subtract(annualSalary, baseDeduction);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 2.94M)))
                    {
                        #region 0,91 - 2,94

                        // Arbetsinkomst överstiger 0,91 men inte 2,94 prisbasbelopp.
                        // Skattereduktion = skillnaden mellan å ena sidan av 0,91 prisbasbelopp och 33,2 procent av arbetsinkomsten mellan 0,91 och 2,94 prisbasbelopp och å andra sidan av grundavdraget,
                        // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,2 procentenheter för begravningsavgift och avgift till trossamfund).

                        deduction = Decimal.Multiply(baseAmount, 0.91M);
                        deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 0.91M)), 0.332M);
                        deduction -= baseDeduction;

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                        {
                            #region 2,94 - 8,08

                            // Arbetsinkomst överstiger 2,94 men inte 8,08 prisbasbelopp.
                            // Skattereduktion = skillnaden mellan å ena sidan av 1,584 prisbasbelopp och 11,1 procent av arbetsinkomsten mellan 2,94 och 8,08 prisbasbelopp och å andra sidan av grundavdraget,
                            // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,2 procentenheter för begravningsavgift och avgift till trossamfund).

                            deduction = Decimal.Multiply(baseAmount, 1.584M);
                            deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 2.94M)), 0.111M);
                            deduction -= baseDeduction;

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 13.54M)))
                            {
                                #region 8,08 - 13,54

                                // Arbetsinkomst överstiger 8,08 men inte 13,54 prisbasbelopp.
                                // Skattereduktion = skillnaden mellan 2,155 prisbasbelopp och grundavdraget,
                                // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,2 procentenheter för begravningsavgift och avgift till trossamfund).

                                deduction = Decimal.Multiply(baseAmount, 2.155M);
                                deduction -= baseDeduction;

                                #endregion
                            }
                            else
                            {
                                #region 13,54 -

                                // Arbetsinkomst överstiger 13,54 prisbasbelopp.
                                // Skattereduktion = skillnaden mellan 2,155 prisbasbelopp och grundavdraget,
                                // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,2 procentenheter för begravningsavgift och avgift till trossamfund),
                                // minskat med 3 procent av skillnaden mellan arbetsinkomsten och 13,54 prisbasbelopp

                                deduction = Decimal.Multiply(baseAmount, 2.155M);
                                deduction -= baseDeduction;

                                additionalDeduction = Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 13.54M)), 0.03M);

                                #endregion
                            }
                        }
                    }
                }

                // Multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,2 procentenheter för begravningsavgift och avgift till trossamfund).
                deduction = Decimal.Multiply(deduction, Decimal.Divide((Decimal.Subtract(taxRate, GetChurchFeeRateSE(date))), 100M));
                deduction -= additionalDeduction;
                // Avrunda nedåt till hela kronor
                deduction = Math.Floor(deduction);

                #endregion
            }
            else
            {
                #region Skattereduktion för den som vid inkomstårets ingång fyllt 65

                deduction = CalculateTaxDeductionForIncomeOver65_2016(annualSalary);

                #endregion
            }

            // Deduction can not exceed county tax reduced with national pension fee
            decimal countyTax = CalculateCountyIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount);
            decimal pensionFee = CalculateTaxDeductionForNationalPensionFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
            if (deduction > (countyTax - pensionFee))
                deduction = countyTax - pensionFee;

            if (deduction < 0)
                deduction = 0;

            return deduction;
        }

        private decimal CalculateTaxDeductionForIncomeOver65_2016(decimal annualSalary)
        {
            decimal deduction;

            if (annualSalary <= 100000M)
            {
                #region 0 - 100.000 kr

                // Arbetsinkomst överstiger inte 100 000 kr.
                // Skattereduktion = arbetsinkomsten multiplicerad med 20 procent.

                deduction = Decimal.Multiply(annualSalary, 0.2M);

                #endregion
            }
            else
            {
                if (annualSalary <= 300000M)
                {
                    #region 100.000 kr - 300.000 kr

                    // Arbetsinkomst överstiger 100 000 kr men inte 300 000 kr.
                    // Skattereduktion = fast belopp om 15 000 kr ökat med 5 procent av arbetsinkomsten.

                    deduction = 15000M + Decimal.Multiply(annualSalary, 0.05M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= 600000M)
                    {
                        #region 300.000 kr - 600.000 kr

                        // Arbetsinkomst överstiger 300 000 kr men inte 600 000 kr.
                        // Skattereduktion = fast belopp om 30 000 kr.

                        deduction = 30000M;

                        #endregion
                    }
                    else
                    {
                        #region 600.000 kr -

                        // Arbetsinkomst överstiger 600 000 kr.
                        // Fast belopp om 30 000 kr minskat med 3 procent av inkomsten som överstiger 600 000 kr.

                        deduction = 30000M;
                        deduction -= Decimal.Multiply(Decimal.Subtract(annualSalary, 600000M), 0.03M);

                        #endregion
                    }
                }
            }

            return deduction;
        }

        #endregion

        #region 2019-2021

        public decimal CalculateTaxDeductionForIncomeSE_2019(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, int taxRate, decimal baseAmount = 0, decimal baseDeduction = 0, int sysCountryId = 0)
        {
            decimal deduction;
            decimal additionalDeduction = 0;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Round down to nearest 100
            annualSalary = Decimal.Multiply(Math.Floor(Decimal.Divide(annualSalary, 100M)), 100M);

            if (date.Year - birthDate.Year <= 65)
            {
                #region Skattereduktion för den som vid inkomstårets ingång inte fyllt 65 år

                // Grundavdrag
                if (baseDeduction == 0)
                    baseDeduction = CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount);

                // Get tax deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Arbetsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Skattereduktion = skillnaden mellan arbetsinkomsten och grundavdraget, multiplicerat med skattesatsen för kommunal inkomstskatt
                    // (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                    deduction = Decimal.Subtract(annualSalary, baseDeduction);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.24M)))
                    {
                        #region 0,91 - 3,24

                        // Arbetsinkomst överstiger 0,91 men inte 3,24 prisbasbelopp.
                        // Skattereduktion = skillnaden mellan å ena sidan av 0,91 prisbasbelopp och 34,05 procent av arbetsinkomsten mellan 0,91 och 3,24 prisbasbelopp och å andra sidan av grundavdraget,
                        // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                        deduction = Decimal.Multiply(baseAmount, 0.91M);
                        deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 0.91M)), 0.3405M);
                        deduction -= baseDeduction;

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                        {
                            #region 3,24 - 8,08

                            // Arbetsinkomst överstiger 3,24 men inte 8,08 prisbasbelopp.
                            // Skattereduktion = skillnaden mellan å ena sidan av 1,703 prisbasbelopp och 12,8 procent av arbetsinkomsten mellan 3,24 och 8,08 prisbasbelopp och å andra sidan av grundavdraget,
                            // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                            deduction = Decimal.Multiply(baseAmount, 1.703M);
                            deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 3.24M)), 0.128M);
                            deduction -= baseDeduction;

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 13.54M)))
                            {
                                #region 8,08 - 13,54

                                // Arbetsinkomst överstiger 8,08 men inte 13,54 prisbasbelopp.
                                // Skattereduktion = skillnaden mellan 2,323 prisbasbelopp och grundavdraget,
                                // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                                deduction = Decimal.Multiply(baseAmount, 2.323M);
                                deduction -= baseDeduction;

                                #endregion
                            }
                            else
                            {
                                #region 13,54 -

                                // Arbetsinkomst överstiger 13,54 prisbasbelopp.
                                // Skattereduktion = skillnaden mellan 2,323 prisbasbelopp och grundavdraget,
                                // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund),
                                // minskat med 3 procent av skillnaden mellan arbetsinkomsten och 13,54 prisbasbelopp

                                deduction = Decimal.Multiply(baseAmount, 2.323M);
                                deduction -= baseDeduction;

                                additionalDeduction = Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 13.54M)), 0.03M);

                                #endregion
                            }
                        }
                    }
                }

                // Multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).
                deduction = Decimal.Multiply(deduction, Decimal.Divide((Decimal.Subtract(taxRate, GetChurchFeeRateSE(date))), 100M));
                deduction -= additionalDeduction;
                // Avrunda nedåt till hela kronor
                deduction = Math.Floor(deduction);

                #endregion
            }
            else
            {
                #region Skattereduktion för den som vid inkomstårets ingång fyllt 65

                deduction = CalculateTaxDeductionForIncomeOver65_2016(annualSalary);

                #endregion
            }

            // Deduction can not exceed county tax reduced with national pension fee
            decimal countyTax = CalculateCountyIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount);
            decimal pensionFee = CalculateTaxDeductionForNationalPensionFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
            if (deduction > (countyTax - pensionFee))
                deduction = countyTax - pensionFee;

            if (deduction < 0)
                deduction = 0;

            return deduction;
        }

        #endregion

        #region 2022

        public decimal CalculateTaxDeductionForIncomeSE_2022(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, int taxRate, decimal baseAmount = 0, decimal baseDeduction = 0, int sysCountryId = 0)
        {
            decimal deduction;
            decimal additionalDeduction = 0;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Round down to nearest 100
            annualSalary = Decimal.Multiply(Math.Floor(Decimal.Divide(annualSalary, 100M)), 100M);

            if (date.Year - birthDate.Year <= 65)
            {
                #region Skattereduktion för den som vid inkomstårets ingång inte fyllt 65 år

                // Grundavdrag
                if (baseDeduction == 0)
                    baseDeduction = CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount);

                // Get tax deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Arbetsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Skattereduktion = arbetsinkomsten minskat med grundavdraget,
                    // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                    deduction = Decimal.Subtract(annualSalary, baseDeduction);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.24M)))
                    {
                        #region 0,91 - 3,24

                        // Arbetsinkomst överstiger 0,91 men inte 3,24 prisbasbelopp.
                        // Skattereduktion = 0,91 PBB ökat med 38,74 procent av arbetsinkomsten mellan 0,91 och 3,24 PBB minskat med grundavdraget,
                        // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                        deduction = Decimal.Multiply(baseAmount, 0.91M);
                        deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 0.91M)), 0.3874M);
                        deduction -= baseDeduction;

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                        {
                            #region 3,24 - 8,08

                            // Arbetsinkomst överstiger 3,24 men inte 8,08 prisbasbelopp.
                            // Skattereduktion = 1,812 PBB ökat med 12,8 procent av arbetsinkomsten mellan 3,24 och 8,08 PBB minskat med grundavdraget,
                            // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                            deduction = Decimal.Multiply(baseAmount, 1.812M);
                            deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 3.24M)), 0.128M);
                            deduction -= baseDeduction;

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 13.54M)))
                            {
                                #region 8,08 - 13,54

                                // Arbetsinkomst överstiger 8,08 men inte 13,54 prisbasbelopp.
                                // Skattereduktion = 2,432 PBB minskat med grundavdraget, 
                                // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                                deduction = Decimal.Multiply(baseAmount, 2.432M);
                                deduction -= baseDeduction;

                                #endregion
                            }
                            else
                            {
                                #region 13,54 -

                                // Arbetsinkomst överstiger 13,54 prisbasbelopp.
                                // Skattereduktion = 2,432 PBB minskat med grundavdraget, 
                                // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund),
                                // minskat med 3 procent av skillnaden mellan arbetsinkomsten och 13,54 prisbasbelopp

                                deduction = Decimal.Multiply(baseAmount, 2.432M);
                                deduction -= baseDeduction;

                                additionalDeduction = Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 13.54M)), 0.03M);

                                #endregion
                            }
                        }
                    }
                }

                // Multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).
                deduction = Decimal.Multiply(deduction, Decimal.Divide((Decimal.Subtract(taxRate, GetChurchFeeRateSE(date))), 100M));
                deduction -= additionalDeduction;
                // Avrunda nedåt till hela kronor
                deduction = Math.Floor(deduction);

                #endregion
            }
            else
            {
                #region Skattereduktion för den som vid inkomstårets ingång fyllt 65

                deduction = CalculateTaxDeductionForIncomeOver65_2016(annualSalary);

                #endregion
            }

            // Deduction can not exceed county tax reduced with national pension fee
            decimal countyTax = CalculateCountyIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount);
            decimal pensionFee = CalculateTaxDeductionForNationalPensionFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
            if (deduction > (countyTax - pensionFee))
                deduction = countyTax - pensionFee;

            if (deduction < 0)
                deduction = 0;

            return deduction;
        }

        #endregion

        #region 2023

        public decimal CalculateTaxDeductionForIncomeSE_2023(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, int taxRate, decimal baseAmount = 0, decimal baseDeduction = 0, int sysCountryId = 0)
        {
            decimal deduction;
            decimal additionalDeduction = 0;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Round down to nearest 100
            annualSalary = Decimal.Multiply(Math.Floor(Decimal.Divide(annualSalary, 100M)), 100M);

            if (date.Year - birthDate.Year <= 65)
            {
                #region Skattereduktion för den som vid inkomstårets ingång inte fyllt 65 år

                // Grundavdrag
                if (baseDeduction == 0)
                    baseDeduction = CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount);

                // Get tax deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Arbetsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Skattereduktion = arbetsinkomsten minskat med grundavdraget,
                    // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                    deduction = Decimal.Subtract(annualSalary, baseDeduction);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.24M)))
                    {
                        #region 0,91 - 3,24

                        // Arbetsinkomst överstiger 0,91 men inte 3,24 prisbasbelopp.
                        // Skattereduktion = 0,91 PBB ökat med 38,74 procent av arbetsinkomsten mellan 0,91 och 3,24 PBB minskat med grundavdraget,
                        // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                        deduction = Decimal.Multiply(baseAmount, 0.91M);
                        deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 0.91M)), 0.3874M);
                        deduction -= baseDeduction;

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                        {
                            #region 3,24 - 8,08

                            // Arbetsinkomst överstiger 3,24 men inte 8,08 prisbasbelopp.
                            // Skattereduktion = 1,812 PBB ökat med 12,8 procent av arbetsinkomsten mellan 3,24 och 8,08 PBB minskat med grundavdraget,
                            // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                            deduction = Decimal.Multiply(baseAmount, 1.812M);
                            deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 3.24M)), 0.128M);
                            deduction -= baseDeduction;

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 13.54M)))
                            {
                                #region 8,08 - 13,54

                                // Arbetsinkomst överstiger 8,08 men inte 13,54 prisbasbelopp.
                                // Skattereduktion = 2,432 PBB minskat med grundavdraget, 
                                // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                                deduction = Decimal.Multiply(baseAmount, 2.432M);
                                deduction -= baseDeduction;

                                #endregion
                            }
                            else
                            {
                                #region 13,54 -

                                // Arbetsinkomst överstiger 13,54 prisbasbelopp.
                                // Skattereduktion = 2,432 PBB minskat med grundavdraget, 
                                // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund),
                                // minskat med 3 procent av skillnaden mellan arbetsinkomsten och 13,54 prisbasbelopp

                                deduction = Decimal.Multiply(baseAmount, 2.432M);
                                deduction -= baseDeduction;

                                additionalDeduction = Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 13.54M)), 0.03M);

                                #endregion
                            }
                        }
                    }
                }

                // Multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).
                deduction = Decimal.Multiply(deduction, Decimal.Divide((Decimal.Subtract(taxRate, GetChurchFeeRateSE(date))), 100M));
                deduction -= additionalDeduction;
                // Avrunda nedåt till hela kronor
                deduction = Math.Floor(deduction);

                #endregion
            }
            else
            {
                #region Skattereduktion för den som vid inkomstårets ingång fyllt 65

                deduction = CalculateTaxDeductionForIncomeOver65_2023(annualSalary);

                #endregion
            }

            // Deduction can not exceed county tax reduced with national pension fee
            decimal countyTax = CalculateCountyIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount);
            decimal pensionFee = CalculateTaxDeductionForNationalPensionFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
            if (deduction > (countyTax - pensionFee))
                deduction = countyTax - pensionFee;

            if (deduction < 0)
                deduction = 0;

            return deduction;
        }

        private decimal CalculateTaxDeductionForIncomeOver65_2023(decimal annualSalary)
        {
            decimal deduction;

            if (annualSalary <= 100000M)
            {
                #region 0 - 100.000 kr

                // Arbetsinkomst överstiger inte 100 000 kr.
                // Skattereduktion = arbetsinkomsten multiplicerad med 22 procent.

                deduction = Decimal.Multiply(annualSalary, 0.22M);

                #endregion
            }
            else
            {
                if (annualSalary <= 300000M)
                {
                    #region 100.000 kr - 300.000 kr

                    // Arbetsinkomst överstiger 100 000 kr men inte 300 000 kr.
                    // Skattereduktion = fast belopp om 15 000 kr ökat med 7 procent av arbetsinkomsten.

                    deduction = 15000M + Decimal.Multiply(annualSalary, 0.07M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= 600000M)
                    {
                        #region 300.000 kr - 600.000 kr

                        // Arbetsinkomst överstiger 300 000 kr men inte 600 000 kr.
                        // Skattereduktion = fast belopp om 36 000 kr.

                        deduction = 36000M;

                        #endregion
                    }
                    else
                    {
                        #region 600.000 kr -

                        // Arbetsinkomst överstiger 600 000 kr.
                        // Fast belopp om 36 000 kr minskat med 3 procent av inkomsten som överstiger 600 000 kr.

                        deduction = 36000M;
                        deduction -= Decimal.Multiply(Decimal.Subtract(annualSalary, 600000M), 0.03M);

                        #endregion
                    }
                }
            }

            return deduction;
        }

        #endregion

        #region 2024

        public decimal CalculateTaxDeductionForIncomeSE_2024(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, int taxRate, decimal baseAmount = 0, decimal baseDeduction = 0, int sysCountryId = 0)
        {
            decimal deduction;
            decimal additionalDeduction = 0;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Round down to nearest 100
            annualSalary = Decimal.Multiply(Math.Floor(Decimal.Divide(annualSalary, 100M)), 100M);

            if (date.Year - birthDate.Year <= 66)
            {
                #region Skattereduktion för den som vid inkomstårets ingång inte fyllt 66 år

                // Grundavdrag
                if (baseDeduction == 0)
                    baseDeduction = CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount);

                // Get tax deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Arbetsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Skattereduktion = arbetsinkomsten minskat med grundavdraget,
                    // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                    deduction = Decimal.Subtract(annualSalary, baseDeduction);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.24M)))
                    {
                        #region 0,91 - 3,24

                        // Arbetsinkomst överstiger 0,91 men inte 3,24 prisbasbelopp.
                        // Skattereduktion = 0,91 PBB ökat med 38,74 procent av arbetsinkomsten mellan 0,91 och 3,24 PBB minskat med grundavdraget,
                        // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                        deduction = Decimal.Multiply(baseAmount, 0.91M);
                        deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 0.91M)), 0.3874M);
                        deduction -= baseDeduction;

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                        {
                            #region 3,24 - 8,08

                            // Arbetsinkomst överstiger 3,24 men inte 8,08 prisbasbelopp.
                            // Skattereduktion = 1,813 PBB ökat med 16,43 procent av arbetsinkomsten mellan 3,24 och 8,08 PBB minskat med grundavdraget,
                            // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                            deduction = Decimal.Multiply(baseAmount, 1.813M);
                            deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 3.24M)), 0.1643M);
                            deduction -= baseDeduction;

                            #endregion
                        }
                        else
                        {
                            if (annualSalary <= (Decimal.Multiply(baseAmount, 13.54M)))
                            {
                                #region 8,08 - 13,54

                                // Arbetsinkomst överstiger 8,08 men inte 13,54 prisbasbelopp.
                                // Skattereduktion = 2,608 PBB minskat med grundavdraget, 
                                // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                                deduction = Decimal.Multiply(baseAmount, 2.608M);
                                deduction -= baseDeduction;

                                #endregion
                            }
                            else
                            {
                                #region 13,54 -

                                // Arbetsinkomst överstiger 13,54 prisbasbelopp.
                                // Skattereduktion = 2,608 PBB minskat med grundavdraget, 
                                // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund),
                                // minskat med 3 procent av skillnaden mellan arbetsinkomsten och 13,54 prisbasbelopp

                                deduction = Decimal.Multiply(baseAmount, 2.608M);
                                deduction -= baseDeduction;

                                additionalDeduction = Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 13.54M)), 0.03M);

                                #endregion
                            }
                        }
                    }
                }

                // Multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).
                deduction = Decimal.Multiply(deduction, Decimal.Divide((Decimal.Subtract(taxRate, GetChurchFeeRateSE(date))), 100M));
                deduction -= additionalDeduction;
                // Avrunda nedåt till hela kronor
                deduction = Math.Floor(deduction);

                #endregion
            }
            else
            {
                #region Skattereduktion för den som vid inkomstårets ingång fyllt 66

                deduction = CalculateTaxDeductionForIncomeOver66_2024(entities, actorCompanyId, date, annualSalary, baseAmount);

                #endregion
            }

            // Deduction can not exceed county tax reduced with national pension fee
            decimal countyTax = CalculateCountyIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount);
            decimal pensionFee = CalculateTaxDeductionForNationalPensionFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
            if (deduction > (countyTax - pensionFee))
                deduction = countyTax - pensionFee;

            if (deduction < 0)
                deduction = 0;

            return deduction;
        }

        private decimal CalculateTaxDeductionForIncomeOver66_2024(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, decimal baseAmount = 0)
        {
            decimal deduction;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            if (annualSalary <= (Decimal.Multiply(baseAmount, 1.75M)))
            {
                #region 0 - 1,75

                // Arbetsinkomst överstiger inte 1,75 prisbasbelopp.
                // Skattereduktion = arbetsinkomsten multiplicerad med 22 procent.

                deduction = Decimal.Multiply(annualSalary, 0.22M);

                #endregion
            }
            else
            {
                if (annualSalary <= (Decimal.Multiply(baseAmount, 5.24M)))
                {
                    #region 1,75 - 5,24

                    // Arbetsinkomst överstiger 1,75 men inte 5,24 prisbasbelopp.
                    // Skattereduktion = 0,2635 prisbasbelopp ökat med 7 procent av arbetsinkomsten.

                    deduction = Decimal.Multiply(baseAmount, 0.2635M);
                    deduction += Decimal.Multiply(annualSalary, 0.07M);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 10.48M)))
                    {
                        #region 5,24 - 10,48

                        // Arbetsinkomst överstiger 5,24 men inte 10,48 prisbasbelopp.
                        // Skattereduktion = 0,6293 prisbasbelopp.

                        deduction = Decimal.Multiply(baseAmount, 0.6293M);

                        #endregion
                    }
                    else
                    {
                        #region 10,48 -

                        // Arbetsinkomst överstiger 10,48 prisbasbelopp.
                        // Skattereduktion = 0,6293 prisbasbelopp minskat med 3 procent av inkomsten som överstiger 10,48 prisbasbelopp.

                        deduction = Decimal.Multiply(baseAmount, 0.6293M);
                        deduction -= Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 10.48M)), 0.03M);

                        #endregion
                    }
                }
            }

            return deduction;
        }

        #endregion

        #region 2025

        public decimal CalculateTaxDeductionForIncomeSE_2025(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, int taxRate, decimal baseAmount = 0, decimal baseDeduction = 0, int sysCountryId = 0)
        {
            decimal deduction;
            decimal additionalDeduction = 0;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Round down to nearest 100
            annualSalary = Decimal.Multiply(Math.Floor(Decimal.Divide(annualSalary, 100M)), 100M);

            if (date.Year - birthDate.Year <= 66)
            {
                #region Skattereduktion för den som vid inkomstårets ingång inte fyllt 66 år

                // Grundavdrag
                if (baseDeduction == 0)
                    baseDeduction = CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount);

                // Get tax deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Arbetsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Skattereduktion = arbetsinkomsten minskat med grundavdraget,
                    // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                    deduction = Decimal.Subtract(annualSalary, baseDeduction);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.24M)))
                    {
                        #region 0,91 - 3,24

                        // Arbetsinkomst överstiger 0,91 men inte 3,24 prisbasbelopp.
                        // Skattereduktion = 0,91 PBB ökat med 38,74 procent av arbetsinkomsten mellan 0,91 och 3,24 PBB minskat med grundavdraget,
                        // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                        deduction = Decimal.Multiply(baseAmount, 0.91M);
                        deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 0.91M)), 0.3874M);
                        deduction -= baseDeduction;

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                        {
                            #region 3,24 - 8,08

                            // Arbetsinkomst överstiger 3,24 men inte 8,08 prisbasbelopp.
                            // Skattereduktion = 1,813 PBB ökat med 19,90 procent av arbetsinkomsten mellan 3,24 och 8,08 PBB minskat med grundavdraget,
                            // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                            deduction = Decimal.Multiply(baseAmount, 1.813M);
                            deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 3.24M)), 0.1990M);
                            deduction -= baseDeduction;

                            #endregion
                        }
                        else
                        {
                            #region 8,08

                            // Arbetsinkomst överstiger 8,08 
                            // Skattereduktion = 2,776 PBB minskat med grundavdraget, 
                            // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                            deduction = Decimal.Multiply(baseAmount, 2.776M);
                            deduction -= baseDeduction;

                            #endregion                                                        
                        }
                    }
                }

                // Multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).
                deduction = Decimal.Multiply(deduction, Decimal.Divide((Decimal.Subtract(taxRate, GetChurchFeeRateSE(date))), 100M));
                deduction -= additionalDeduction;
                // Avrunda nedåt till hela kronor
                deduction = Math.Floor(deduction);

                #endregion
            }
            else
            {
                #region Skattereduktion för den som vid inkomstårets ingång fyllt 66

                deduction = CalculateTaxDeductionForIncomeOver66_2025(entities, actorCompanyId, date, annualSalary, baseAmount);

                #endregion
            }

            // Deduction can not exceed county tax reduced with national pension fee
            decimal countyTax = CalculateCountyIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount);
            decimal pensionFee = CalculateTaxDeductionForNationalPensionFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
            if (deduction > (countyTax - pensionFee))
                deduction = countyTax - pensionFee;

            if (deduction < 0)
                deduction = 0;

            return deduction;
        }

        private decimal CalculateTaxDeductionForIncomeOver66_2025(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, decimal baseAmount = 0)
        {
            decimal deduction;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            if (annualSalary <= (Decimal.Multiply(baseAmount, 1.75M)))
            {
                #region 0 - 1,75

                // Arbetsinkomst överstiger inte 1,75 prisbasbelopp.
                // Skattereduktion = arbetsinkomsten multiplicerad med 22 procent.

                deduction = Decimal.Multiply(annualSalary, 0.22M);

                #endregion
            }
            else
            {
                if (annualSalary <= (Decimal.Multiply(baseAmount, 5.24M)))
                {
                    #region 1,75 - 5,24

                    // Arbetsinkomst överstiger 1,75 men inte 5,24 prisbasbelopp.
                    // Skattereduktion = 0,2635 prisbasbelopp ökat med 7 procent av arbetsinkomsten.

                    deduction = Decimal.Multiply(baseAmount, 0.2635M);
                    deduction += Decimal.Multiply(annualSalary, 0.07M);

                    #endregion
                }
                else
                {
                    #region 5,24

                    // Arbetsinkomst överstiger 5,24 
                    // Skattereduktion = 0,6293 prisbasbelopp.

                    deduction = Decimal.Multiply(baseAmount, 0.6293M);

                    #endregion                                    
                }
            }

            return deduction;
        }

        #endregion

        #region 2026

        public decimal CalculateTaxDeductionForIncomeSE_2026(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, int taxRate, decimal baseAmount = 0, decimal baseDeduction = 0, int sysCountryId = 0)
        {
            decimal deduction;
            decimal additionalDeduction = 0;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Round down to nearest 100
            annualSalary = Decimal.Multiply(Math.Floor(Decimal.Divide(annualSalary, 100M)), 100M);

            if (date.Year - birthDate.Year <= 66)
            {
                #region Skattereduktion för den som vid inkomstårets ingång inte fyllt 66 år

                // Grundavdrag
                if (baseDeduction == 0)
                    baseDeduction = CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount);

                // Get tax deduction based on income relative to base amount
                if (annualSalary <= (Decimal.Multiply(baseAmount, 0.91M)))
                {
                    #region 0 - 0,91

                    // Arbetsinkomst överstiger inte 0,91 prisbasbelopp.
                    // Skattereduktion = arbetsinkomsten minskat med grundavdraget,
                    // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                    deduction = Decimal.Subtract(annualSalary, baseDeduction);

                    #endregion
                }
                else
                {
                    if (annualSalary <= (Decimal.Multiply(baseAmount, 3.24M)))
                    {
                        #region 0,91 - 3,24

                        // Arbetsinkomst överstiger 0,91 men inte 3,24 prisbasbelopp.
                        // Skattereduktion = 0,91 PBB ökat med 38,74 procent av arbetsinkomsten mellan 0,91 och 3,24 PBB minskat med grundavdraget,
                        // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                        deduction = Decimal.Multiply(baseAmount, 0.91M);
                        deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 0.91M)), 0.3874M);
                        deduction -= baseDeduction;

                        #endregion
                    }
                    else
                    {
                        if (annualSalary <= (Decimal.Multiply(baseAmount, 8.08M)))
                        {
                            #region 3,24 - 8,08

                            // Arbetsinkomst överstiger 3,24 men inte 8,08 prisbasbelopp.
                            // Skattereduktion = 1,813 PBB ökat med 25,10 procent av arbetsinkomsten mellan 3,24 och 8,08 PBB minskat med grundavdraget,
                            // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                            deduction = Decimal.Multiply(baseAmount, 1.813M);
                            deduction += Decimal.Multiply(Decimal.Subtract(annualSalary, Decimal.Multiply(baseAmount, 3.24M)), 0.2510M);
                            deduction -= baseDeduction;

                            #endregion
                        }
                        else
                        {
                            #region 8,08

                            // Arbetsinkomst överstiger 8,08 
                            // Skattereduktion = 3,027 PBB minskat med grundavdraget, 
                            // multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).

                            deduction = Decimal.Multiply(baseAmount, 3.027M);
                            deduction -= baseDeduction;

                            #endregion                                                        
                        }
                    }
                }

                // Multiplicerat med skattesatsen för kommunal inkomstskatt (exkl. 1,16 procentenheter för begravningsavgift och avgift till trossamfund).
                deduction = Decimal.Multiply(deduction, Decimal.Divide((Decimal.Subtract(taxRate, GetChurchFeeRateSE(date))), 100M));
                deduction -= additionalDeduction;
                // Avrunda nedåt till hela kronor
                deduction = Math.Floor(deduction);

                #endregion
            }
            else
            {
                #region Skattereduktion för den som vid inkomstårets ingång fyllt 66

                deduction = CalculateTaxDeductionForIncomeOver66_2026(entities, actorCompanyId, date, annualSalary, baseAmount);

                #endregion
            }

            // Deduction can not exceed county tax reduced with national pension fee
            decimal countyTax = CalculateCountyIncomeTaxSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount);
            decimal pensionFee = CalculateTaxDeductionForNationalPensionFeeSE(entities, actorCompanyId, date, annualSalary, birthDate, taxRate, baseAmount, baseDeduction, sysCountryId);
            if (deduction > (countyTax - pensionFee))
                deduction = countyTax - pensionFee;

            if (deduction < 0)
                deduction = 0;

            return deduction;
        }

        private decimal CalculateTaxDeductionForIncomeOver66_2026(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, decimal baseAmount = 0)
        {
            decimal deduction;

            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            if (annualSalary <= (Decimal.Multiply(baseAmount, 1.75M)))
            {
                #region 0 - 1,75

                // Arbetsinkomst överstiger inte 1,75 prisbasbelopp.
                // Skattereduktion = arbetsinkomsten multiplicerad med 22 procent.

                deduction = Decimal.Multiply(annualSalary, 0.22M);

                #endregion
            }
            else
            {
                if (annualSalary <= (Decimal.Multiply(baseAmount, 5.24M)))
                {
                    #region 1,75 - 5,24

                    // Arbetsinkomst överstiger 1,75 men inte 5,24 prisbasbelopp.
                    // Skattereduktion = 0,2635 prisbasbelopp ökat med 7 procent av arbetsinkomsten.

                    deduction = Decimal.Multiply(baseAmount, 0.2635M);
                    deduction += Decimal.Multiply(annualSalary, 0.07M);

                    #endregion
                }
                else
                {
                    #region 5,24

                    // Arbetsinkomst överstiger 5,24 
                    // Skattereduktion = 0,6293 prisbasbelopp.

                    deduction = Decimal.Multiply(baseAmount, 0.6293M);

                    #endregion                                    
                }
            }

            // Avrunda nedåt till hela kronor
            deduction = Math.Floor(deduction);

            return deduction;
        }

        #endregion
        #endregion

        #region Tax deduction for service income (Skattereduktion för förvärvsinkomst)

        // En ny skattereduktion införs fr.o.m. 1 januari 2021. Skattereduktionen ska medges personer som har inkomst av tjänst,
        // d.v.s. både arbetsinkomster och inkomster från socialförsäkringsförmåner t.ex. pension eller föräldrapenning.
        // Även inkomst av näringsverksamhet eller handelsbolag ska omfattas.

        // Skattereduktion ska medges med 1 500 kr per år.
        // För personer som har en beskattningsbar förvärvsinkomst mellan 40 000 kr och 240 000 kr ska i stället
        // skattereduktionen uppgå till 0,75 procent av skillnaden mellan den beskattningsbara förvärvsinkomsten och 40 000 kr.
        // Skattereduktionen påverkar samtliga kolumner i skattetabellerna.

        #region Common

        public decimal CalculateTaxDeductionForServiceIncomeSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, decimal countyIncomeTax, decimal taxDeductionForNationalPensionFee, decimal taxDeductionForIncome, decimal baseAmount = 0, decimal baseDeduction = 0)
        {
            // Get SysPayrollPrice for BaseAmount (Prisbasbelopp)
            if (baseAmount == 0)
                baseAmount = GetBaseAmountSE(entities, actorCompanyId, date);

            // Grundavdrag
            if (baseDeduction == 0)
                baseDeduction = CalculateBaseDeductionSE(entities, actorCompanyId, date, annualSalary, baseAmount);

            decimal salary = Decimal.Subtract(annualSalary, baseDeduction);

            switch (date.Year)
            {
                case 2021:
                case 2022:
                case 2023:
                case 2024:
                case 2025:
                case 2026:
                    return CalculateTaxDeductionForServiceIncomeSE_2021(salary, countyIncomeTax, taxDeductionForNationalPensionFee, taxDeductionForIncome);
                default:
                    return 0;
            }
        }

        #endregion

        #region 2021-2026

        public decimal CalculateTaxDeductionForServiceIncomeSE_2021(decimal salary, decimal countyIncomeTax, decimal taxDeductionForNationalPensionFee, decimal taxDeductionForImcome)
        {
            if (salary < 40000)
                return 0;

            decimal deduction;

            if (salary <= 240000M)
            {
                #region 40.000 - 240.000 kr

                // Beskattningsbar förvärvsinkomst mellan 40 000 och 240 000 kr
                // Skattereduktion = 0,75% av skillnaden mellan beskattningsbar förvärvsinkomst och 40 000.

                deduction = Decimal.Multiply(Decimal.Subtract(salary, 40000M), 0.0075M);

                #endregion
            }
            else
            {
                #region 240.000 kr -

                // Beskattningsbar förvärvsinkomst över 240 000 kr

                deduction = 1500;

                #endregion
            }

            //Total deduction can not exceed countyIncomeTax
            if (deduction > (countyIncomeTax - taxDeductionForNationalPensionFee - taxDeductionForImcome))
                deduction = countyIncomeTax - taxDeductionForNationalPensionFee - taxDeductionForImcome;

            // Remove decimals
            deduction = Math.Truncate(deduction);

            if (deduction < 0)
                deduction = 0;

            return deduction;
        }

        #endregion

        #endregion

        #endregion

        #region Church tax (Begravnings- och trosamfundsavgift)

        public decimal CalculateChurchFeeSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, DateTime birthDate, decimal baseAmount = 0, decimal baseDeduction = 0)
        {
            if (baseDeduction == 0)
                baseDeduction = CalculateIncreasedBaseDeductionSE(entities, actorCompanyId, date, annualSalary, birthDate, baseAmount);

            decimal fee = Decimal.Multiply((annualSalary - baseDeduction), GetChurchFeeRateSE(date));

            // Avrundas till hela krontal, vid 50 öre avrundas nedåt.
            //if (fee % 50 == 0)
            //    fee = (int)Decimal.Divide(fee, 100M);
            //else
            //    fee = Math.Round(Decimal.Divide(fee, 100M), 0, MidpointRounding.AwayFromZero);

            //Efter uträkning bortfaller öretal
            fee = Math.Truncate(Decimal.Divide(fee, 100M));

            return fee;
        }

        public decimal GetChurchFeeRateSE(DateTime date)
        {
            // Begravnings- och trosamfundsavgift dras med 1,2% av beskattningsbar förvärvsinkomst
            // Från 2018 gäller 1,16%

            switch (date.Year)
            {
                case 2014:
                case 2015:
                case 2016:
                case 2017:
                    return 1.2M;
                case 2018:
                case 2019:
                case 2020:
                case 2021:
                case 2022:
                case 2023:
                case 2024:
                case 2025:
                case 2026:
                    return 1.16M;
                default:
                    return 0;
            }
        }

        #endregion

        #region Employment tax

        #region Simple (Used for preliminary calculation)

        public decimal CalculateEmploymentTaxSimple(CompEntities entities, int actorCompanyId, DateTime date, decimal amount, Employee employee, bool applyEmploymentHasEnded = false)
        {
            #region Prereq

            // Get Payroll group
            int? payrollGroupId = employee.GetPayrollGroupId(date, uselastEmploymentDateAsFallback: applyEmploymentHasEnded);
            if (!payrollGroupId.HasValue)
                return 0;

            // Get birth date from employee
            DateTime? birthDate = EmployeeManager.GetEmployeeBirthDate(employee);
            if (!birthDate.HasValue)
                return 0;

            #endregion

            return CalculateEmploymentTaxSimple(entities, actorCompanyId, date, amount, birthDate.Value);
        }

        public decimal CalculateEmploymentTaxSimple(int actorCompanyId, DateTime date, decimal amount, DateTime? birthDate, decimal? taxRate = null, SysPayrollPriceViewDTO sysPayrollPrice = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return CalculateEmploymentTaxSimple(entities, actorCompanyId, date, amount, birthDate, taxRate, sysPayrollPrice);
        }

        public decimal CalculateEmploymentTaxSimple(CompEntities entities, int actorCompanyId, DateTime date, decimal amount, DateTime? birthDate, decimal? taxRate = null, SysPayrollPriceViewDTO sysPayrollPrice = null)
        {
            if (amount == 0)
                return 0;

            if (!taxRate.HasValue)
                taxRate = GetTaxRate(entities, actorCompanyId, date, birthDate, (int)TermGroup_Languages.Swedish, sysPayrollPrice);

            return Decimal.Multiply(amount, taxRate.Value);
        }

        public decimal GetTaxRate(DateTime date, int birthYear, List<Tuple<int, DateTime, decimal>> tuples)
        {
            var first = tuples.FirstOrDefault(w => w.Item1 == birthYear && w.Item2 == date);
            if (first != null)
                return first.Item3;

            return 0;
        }

        public List<Tuple<int, DateTime, decimal>> GetRatesFromPayrollPriceView(CompEntities entities, int actorCompanyId, DateTime dateFrom, DateTime dateTo, List<int> birthYears, List<SysPayrollPriceViewDTO> sysPayrollPriceViews, TermGroup_SysPayrollPrice type, int sysCountryId)
        {
            List<Tuple<int, DateTime, decimal>> tuples = new List<Tuple<int, DateTime, decimal>>();
            birthYears = birthYears.Distinct().OrderBy(o => o).ToList();
            var filteredSysPayrollPriceView = sysPayrollPriceViews.Where(w => w.SysTermId == (int)type && w.FromDate <= dateTo).OrderBy(o => o.FromDate).ToList();

            foreach (var birthYear in birthYears)
            {
                var forYear = filteredSysPayrollPriceView.Where(w => w.FromInterval.HasValue && w.FromInterval.Value <= birthYear && (!w.ToInterval.HasValue || w.ToInterval.HasValue && w.ToInterval.Value >= birthYear)).ToList();
                if (!forYear.Any())
                    continue;

                foreach (var date in CalendarUtility.GetDates(dateFrom, dateTo))
                {
                    var sysPayrollPrice = GetSysPayrollPriceInterval(entities, actorCompanyId, (int)type, birthYear, date, sysCountryId, forYear);
                    var taxRate = PayrollManager.GetSysPayrollPriceIntervalAmount(entities, actorCompanyId, (int)type, birthYear, date, sysCountryId, sysPayrollPrice: sysPayrollPrice);

                    tuples.Add(Tuple.Create(birthYear, date, taxRate));
                }
            }

            return tuples;
        }

        public decimal GetTaxRate(int actorCompanyId, DateTime date, DateTime? birthDate, int sysCountryId, SysPayrollPriceViewDTO sysPayrollPrice = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetTaxRate(entities, actorCompanyId, date, birthDate, sysCountryId, sysPayrollPrice);
        }

        public decimal GetTaxRate(CompEntities entities, int actorCompanyId, DateTime date, DateTime? birthDate, int sysCountryId, SysPayrollPriceViewDTO sysPayrollPrice = null)
        {
            int yearKey = birthDate.HasValue ? birthDate.Value.Year : 1900;
            string key = $"GetTaxRate#{date}#{sysCountryId}#{actorCompanyId}#{yearKey}#";
            var rate = BusinessMemoryCache<decimal?>.Get(key);
            if (rate != null)
                return rate.Value;

            if (birthDate.HasValue)
                rate = PayrollManager.GetSysPayrollPriceIntervalAmount(entities, actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_EmploymentTax, birthDate.Value.Year, date, sysCountryId, sysPayrollPrice: sysPayrollPrice);
            else
                rate = PayrollManager.GetSysPayrollPriceAmount(entities, actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_EmploymentTax, date, sysCountryId, sysPayrollPrice: sysPayrollPrice);

            if (rate != null)
                BusinessMemoryCache<decimal>.Set(key, rate.Value);

            return rate ?? 0;
        }

        #endregion

        #region Common

        #region Yearly employment tax

        public decimal CalculateYearlyEmploymentTaxSE(CompEntities entities, int actorCompanyId, DateTime date, decimal annualSalary, Employee employee, bool applyEmploymentHasEnded = false, int sysCountryId = 0, decimal accEmpTaxBasis = 0)
        {
            #region Prereq

            // Get employment tax from employee
            EmployeeTaxSEDTO empTax = EmployeeManager.GetEmployeeTaxSEDTO(entities, employee.EmployeeId, date.Year);
            if (empTax == null && !applyEmploymentHasEnded)
                return Decimal.Zero;

            // Get birth date from employee
            DateTime? birthDate = EmployeeManager.GetEmployeeBirthDate(employee);
            int age = birthDate.HasValue ? CalendarUtility.GetYearsBetweenDates(birthDate.ToValueOrToday(), CalendarUtility.GetEndOfYear(date)) : 0;

            #endregion

            #region Tax rate

            TermGroup_EmployeeTaxEmploymentTaxType taxType = applyEmploymentHasEnded ? TermGroup_EmployeeTaxEmploymentTaxType.EmploymentTax : empTax.EmploymentTaxType;
            // Get tax rate from sys payroll price
            decimal taxRate = 0;
            switch (taxType)
            {
                case TermGroup_EmployeeTaxEmploymentTaxType.EmploymentTax:
                    if (birthDate.HasValue)
                        taxRate = GetSysPayrollPriceIntervalAmount(entities, actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_EmploymentTax, birthDate.Value.Year, date, sysCountryId);
                    else
                        taxRate = GetSysPayrollPriceAmount(entities, actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_EmploymentTax, date, sysCountryId);
                    break;
                case TermGroup_EmployeeTaxEmploymentTaxType.PayrollTax:
                    if (birthDate.HasValue)
                        taxRate = GetSysPayrollPriceIntervalAmount(entities, actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_PayrollTax, birthDate.Value.Year, date, sysCountryId);
                    else
                        taxRate = GetSysPayrollPriceAmount(entities, actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_PayrollTax, date, sysCountryId);
                    break;
                case TermGroup_EmployeeTaxEmploymentTaxType.EmploymentAbroad:
                    switch (date.Year)
                    {
                        case 2014:
                            taxRate = CalculateYearlyEmploymentAbroadTaxRateSE_2014(birthDate, empTax?.EmploymentAbroadCode ?? TermGroup_EmployeeTaxEmploymentAbroadCode.None);
                            break;
                        case 2015:
                        case 2016:
                        case 2017:
                        case 2018:
                        case 2019:
                        case 2020:
                        case 2021:
                        case 2022:
                        case 2023:
                        case 2024:
                        case 2025:
                        case 2026:
                            taxRate = CalculateYearlyEmploymentAbroadTaxRateSE_2015(birthDate, empTax?.EmploymentAbroadCode ?? TermGroup_EmployeeTaxEmploymentAbroadCode.None);
                            break;
                    }
                    break;
            }

            #endregion

            decimal tax;
            //Denna ska sättas till true om lagen träder igenom
            bool switch2021SpecialRule = true;
            bool applyFirstEmployeeRule = date >= new DateTime(2020, 03, 01) && date <= new DateTime(2020, 06, 30) && empTax != null && empTax.FirstEmployee;
            bool applyFirstEmployeeRuleExtended = date >= new DateTime(2025, 01, 01) && date < new DateTime(2026, 01, 01) && empTax != null && (empTax.FirstEmployee || empTax.SecondEmployee);
            //bool apply15to18Rule = date >= new DateTime(2019, 08, 01) && employeeBirthYear >= 2003 && employeeBirthYear <= 2005; //denna borde ändras?
            bool apply15to18Rule = date >= new DateTime(2019, 08, 01) && age >= 15 && age <= 18;
            bool apply19to23Rule = Apply19to23Rule(date, age);
            bool apply2021SpecialRuleFor19to23 = apply19to23Rule && switch2021SpecialRule && date >= new DateTime(2021, 06, 01) && date <= new DateTime(2021, 08, 31);
            if (age != 0 && (applyFirstEmployeeRule || applyFirstEmployeeRuleExtended || apply15to18Rule || apply19to23Rule))
            {
                decimal limit = 25000;
                decimal taxRateUnderLimit = taxRate;
                decimal taxRateAboveLimit = taxRate;
                if (applyFirstEmployeeRule)
                {
                    taxRateUnderLimit = Decimal.Divide(10.21M, 100);
                    taxRateAboveLimit = taxRate;
                }
                else if (applyFirstEmployeeRuleExtended)
                {
                    limit = 35000;
                    taxRateUnderLimit = Decimal.Divide(10.21M, 100);
                    taxRateAboveLimit = taxRate;
                }
                else if (apply15to18Rule || apply19to23Rule)
                {
                    if (apply2021SpecialRuleFor19to23)
                    {
                        taxRateUnderLimit = Decimal.Divide(10.21M, 100);
                    }
                    else
                        taxRateUnderLimit = taxRate;

                    taxRateAboveLimit = Decimal.Divide(31.42M, 100);
                }

                decimal currentEmpTaxBasis = Decimal.Divide(annualSalary, 12m);

                if (accEmpTaxBasis > limit)
                {
                    if ((currentEmpTaxBasis + accEmpTaxBasis) < limit)
                    {
                        //current calculation made us go under the limit
                        decimal empTaxBasisAboveLimit = accEmpTaxBasis - limit;
                        decimal empTaxBasisUnderLimit = limit - (accEmpTaxBasis + currentEmpTaxBasis);

                        tax = Decimal.Multiply(Decimal.Multiply(empTaxBasisUnderLimit * -1, 12m), taxRateUnderLimit);
                        tax += Decimal.Multiply(Decimal.Multiply(empTaxBasisAboveLimit * -1, 12m), taxRateAboveLimit);
                    }
                    else
                    {
                        //limit already reached
                        tax = Decimal.Multiply(annualSalary, taxRateAboveLimit);
                    }
                }
                else if (currentEmpTaxBasis + accEmpTaxBasis > limit)
                {
                    //limit reached in current calculation
                    decimal empTaxBasisAboveLimit = currentEmpTaxBasis + accEmpTaxBasis - limit;
                    decimal empTaxBasisUnderLimit = limit - accEmpTaxBasis;

                    tax = Decimal.Multiply(Decimal.Multiply(empTaxBasisUnderLimit, 12m), taxRateUnderLimit);
                    tax += Decimal.Multiply(Decimal.Multiply(empTaxBasisAboveLimit, 12m), taxRateAboveLimit);
                }
                else
                {
                    //still under limit
                    tax = Decimal.Multiply(annualSalary, taxRateUnderLimit);
                }
            }
            else
            {
                tax = Decimal.Multiply(annualSalary, taxRate);
            }

            #region Regional support

            if (empTax != null && empTax.RegionalSupport)
            {
                decimal regionalSupport = 0;
                switch (date.Year)
                {
                    case 2014:
                        regionalSupport = CalculateYearlyRegionalSupportSE_2014(birthDate, tax);
                        break;
                    case 2015:
                    case 2016:
                    case 2017:
                    case 2018:
                    case 2019:
                    case 2020:
                    case 2021:
                    case 2022:
                    case 2023:
                    case 2024:
                        regionalSupport = CalculateYearlyRegionalSupportSE_2015(birthDate, tax);
                        break;
                    case 2025:
                    case 2026:
                        break;
                }
                tax -= regionalSupport;
            }

            #endregion

            return tax;
        }

        public bool Apply19to23Rule(DateTime date, int age)
        {
            return date >= new DateTime(2021, 01, 01) && age >= 19 && age <= 23;
        }

        #endregion

        #region Monthly employment tax

        public decimal CalculateEmploymentTaxSE(int actorCompanyId, DateTime date, decimal amount, Employee employee, bool applyEmploymentHasEnded = false)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return CalculateEmploymentTaxSE(entities, actorCompanyId, date, amount, employee, applyEmploymentHasEnded);
        }

        public decimal CalculateEmploymentTaxSE(CompEntities entities, int actorCompanyId, DateTime date, decimal amount, Employee employee, bool applyEmploymentHasEnded = false, int sysCountryId = 0, decimal accEmpTaxBasis = 0)
        {
            return Decimal.Divide(CalculateYearlyEmploymentTaxSE(entities, actorCompanyId, date, Decimal.Multiply(amount, 12M), employee, applyEmploymentHasEnded, sysCountryId, accEmpTaxBasis), 12M);
        }

        #endregion

        #endregion

        #region 2014

        public decimal CalculateYearlyEmploymentAbroadTaxRateSE_2014(DateTime? birthDate, TermGroup_EmployeeTaxEmploymentAbroadCode code)
        {
            decimal taxRate = 0;

            if (birthDate.HasValue)
            {
                int birthYear = birthDate.Value.Year;
                switch (code)
                {
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.SweToCan:
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.SweToUsa:
                        // Kod 1
                        // Arbetsgivare i Sverige för utsänd personal till Kanada och USA
                        if (birthYear >= 1949 && birthYear <= 1987)
                            taxRate = 0.1348M;
                        else if (birthYear >= 1988)
                            taxRate = 0.1102M;
                        break;
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.SweToQue:
                        // Kod 1
                        // Arbetsgivare i Sverige för utsänd personal till Québec
                        if (birthYear >= 1949 && birthYear <= 1987)
                            taxRate = 0.1378M;
                        else if (birthYear >= 1988)
                            taxRate = 0.1109M;
                        break;
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.CanToSweGroup:
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.UsaToSweGroup:
                        // Kod 1
                        // Utsänd personal till Sverige från koncernbolag i Kanada och USA
                        if (birthYear >= 1949 && birthYear <= 1987)
                            taxRate = 0.1794M;
                        else if (birthYear >= 1988)
                            taxRate = 0.0447M;
                        break;
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.QueToSweGroup:
                        // Kod 1
                        // Utsänd personal till Sverige från koncernbolag i Québec
                        if (birthYear >= 1949 && birthYear <= 1987)
                            taxRate = 0.1764M;
                        else if (birthYear >= 1988)
                            taxRate = 0.044M;
                        break;
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.CanToSwe:
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.UsaToSwe:
                        // Kod 2 resp. 4
                        // Arbetsgivare i Kanada (Kod 2) och USA (Kod 4) för utsänd personal till Sverige
                        if (birthYear >= 1949 && birthYear <= 1987)
                            taxRate = 0.0806M;
                        else if (birthYear >= 1988)
                            taxRate = 0.02M;
                        break;
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.QueToSwe:
                        // Kod 3
                        // Arbetsgivare i Québec för utsänd personal till Sverige
                        if (birthYear >= 1949 && birthYear <= 1987)
                            taxRate = 0.0776M;
                        else if (birthYear >= 1988)
                            taxRate = 0.0193M;
                        break;
                }
            }

            return taxRate;
        }

        public decimal CalculateYearlyRegionalSupportSE_2014(DateTime? birthDate, decimal tax)
        {
            // Avdrag får göras för arbete vid fast driftställe i vissa branscher inom stödområden.
            // För födda 1949–1987 är avdraget 10 % och för födda fr.o.m. 1988 är avdraget 5,28 %.
            // Avdraget får sammanlagt vara högst 7 100 kr per månad.

            decimal deductionRate = 0;
            decimal maxDeduction = Decimal.Multiply(7100M, 12M);

            if (birthDate.HasValue)
            {
                if (birthDate.Value.Year >= 1949 && birthDate.Value.Year <= 1987)
                    deductionRate = 0.10M;
                else if (birthDate.Value.Year >= 1988)
                    deductionRate = 5.28M;
            }

            decimal regionalSupport = Decimal.Multiply(tax, deductionRate);
            if (regionalSupport > maxDeduction)
                regionalSupport = maxDeduction;

            return regionalSupport;
        }

        #endregion

        #region 2015-2026

        public decimal CalculateYearlyEmploymentAbroadTaxRateSE_2015(DateTime? birthDate, TermGroup_EmployeeTaxEmploymentAbroadCode code)
        {
            decimal taxRate = 0;

            if (birthDate.HasValue)
            {
                int birthYear = birthDate.Value.Year;
                switch (code)
                {
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.SweToCan:
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.SweToUsa:
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.SweToInd:
                        // Kod 1
                        // Arbetsgivare i Sverige för utsänd personal till Kanada, USA och Indien
                        if (birthYear >= 1950 && birthYear <= 1988)
                            taxRate = 0.2352M;
                        else if (birthYear >= 1989)
                            taxRate = 0.1352M;
                        break;
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.SweToQue:
                        // Kod 1
                        // Arbetsgivare i Sverige för utsänd personal till Québec
                        if (birthYear >= 1950 && birthYear <= 1988)
                            taxRate = 0.2382M;
                        else if (birthYear >= 1989)
                            taxRate = 0.1359M;
                        break;
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.CanToSweGroup:
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.UsaToSweGroup:
                        // Kod 1
                        // Utsänd personal till Sverige från koncernbolag i Kanada och USA
                        if (birthYear >= 1950 && birthYear <= 1988)
                            taxRate = 0.1805M;
                        else if (birthYear >= 1989)
                            taxRate = 0.0450M;
                        break;
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.QueToSweGroup:
                        // Kod 1
                        // Utsänd personal till Sverige från koncernbolag i Québec
                        if (birthYear >= 1950 && birthYear <= 1988)
                            taxRate = 0.1775M;
                        else if (birthYear >= 1989)
                            taxRate = 0.0443M;
                        break;
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.CanToSwe:
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.UsaToSwe:
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.IndToSwe:
                        // Kod 2
                        // Arbetsgivare i Kanada, USA och Indien för utsänd personal till Sverige
                        if (birthYear >= 1950 && birthYear <= 1988)
                            taxRate = 0.0790M;
                        else if (birthYear >= 1989)
                            taxRate = 0.0197M;
                        break;
                    case TermGroup_EmployeeTaxEmploymentAbroadCode.QueToSwe:
                        // Kod 3
                        // Arbetsgivare i Québec för utsänd personal till Sverige
                        if (birthYear >= 1950 && birthYear <= 1988)
                            taxRate = 0.0760M;
                        else if (birthYear >= 1989)
                            taxRate = 0.0190M;
                        break;
                }
            }

            return taxRate;
        }

        public decimal CalculateYearlyRegionalSupportSE_2015(DateTime? birthDate, decimal tax)
        {
            // Avdrag får göras för arbete vid fast driftställe i vissa branscher inom stödområden.
            // För födda 1950–1988 är avdraget 10 % och för födda fr.o.m. 1989 är avdraget 5,28 %.
            // Avdraget får sammanlagt vara högst 7 100 kr per månad.

            decimal deductionRate = 0;
            decimal maxDeduction = Decimal.Multiply(7100M, 12M);

            if (birthDate.HasValue)
            {
                if (birthDate.Value.Year >= 1950 && birthDate.Value.Year <= 1988)
                    deductionRate = 0.10M;
                else if (birthDate.Value.Year >= 1989)
                    deductionRate = 5.28M;
            }

            decimal regionalSupport = Decimal.Multiply(tax, deductionRate);
            if (regionalSupport > maxDeduction)
                regionalSupport = maxDeduction;

            return regionalSupport;
        }

        #endregion

        #endregion

        #region One time tax

        // Preliminärt skatteavdrag i procent av engångsbeloppet

        public decimal CalculateOneTimeTaxSE(CompEntities entities, int actorCompanyId, DateTime transactionDate, DateTime calculationDate, decimal amount, Employee employee, bool applyEmploymentHasEnded = false, EvaluatePayrollPriceFormulaInputDTO iDTO = null, decimal tableTaxTransactionsAmount = 0)
        {
            if (employee == null || amount == 0)
                return 0;

            // Get birth date from employee
            DateTime? birthDate = EmployeeManager.GetEmployeeBirthDate(employee);
            if (!birthDate.HasValue)
                return 0;

            // Get employment tax from employee
            EmployeeTaxSEDTO empTax = EmployeeManager.GetEmployeeTaxSEDTO(entities, employee.EmployeeId, calculationDate.Year);
            if (empTax != null && ((empTax.Type == TermGroup_EmployeeTaxType.NoTax) || (empTax.Type == TermGroup_EmployeeTaxType.NotSelected)))
                return 0;

            if (empTax != null)
            {
                switch (empTax.Type)
                {
                    case TermGroup_EmployeeTaxType.SchoolYouth:

                        decimal remaining = GetSchoolYouthRemainingAmount(entities, actorCompanyId, calculationDate, employee, empTax);
                        if (remaining <= 0 || ((remaining - (amount + tableTaxTransactionsAmount)) < 0))
                        {
                            // Limit has already been reached in previous periods or in current period, use onetime tax on current months salary
                            // Calculate tax on the whole amount
                        }
                        else
                        {
                            // Limit is not reached, no tax
                            return 0;
                        }

                        break;
                }
            }

            decimal taxRate = 0;

            if (empTax != null && empTax.OneTimeTaxPercent.HasValue && empTax.OneTimeTaxPercent.Value > 0)
            {
                //If onetime tax  is set on employee tax, use it
                taxRate = decimal.Divide(empTax.OneTimeTaxPercent.Value, 100);
            }
            else
            {
                if (iDTO == null)
                    iDTO = new EvaluatePayrollPriceFormulaInputDTO();

                decimal annualSalary = 0;

                // Check if one time tax formula exists on payroll group
                // In that case, use it to estimate annual salary
                employee.LoadEmploymentsAndEmploymentChangeBatch();

                Employment employment = employee.GetEmployment(transactionDate, transactionDate);
                if (employment == null && applyEmploymentHasEnded)
                    employment = employee.GetLastEmployment();

                if (employment != null)
                {
                    PayrollGroup payrollGroup = employment.GetPayrollGroup(transactionDate, iDTO.PayrollGroups);
                    if (payrollGroup == null && applyEmploymentHasEnded)
                        payrollGroup = employee.GetLastPayrollGroup();

                    if (payrollGroup != null && payrollGroup.OneTimeTaxFormulaId.HasValue)
                    {
                        // Evaluate formula
                        PayrollPriceFormulaResultDTO result = EvaluatePayrollPriceFormula(entities, actorCompanyId, employee, employment, null, transactionDate, null, null, payrollGroup.OneTimeTaxFormulaId, iDTO: iDTO);
                        if (result != null)
                            annualSalary = result.Amount;
                    }
                }

                if (annualSalary == 0 && empTax != null)
                    annualSalary = empTax.EstimatedAnnualSalary ?? 0;

                taxRate = GetOneTimeTaxPercentSE(calculationDate, annualSalary, birthDate.Value);
            }

            decimal tax = Decimal.Multiply(amount, taxRate);
            return tax;
        }

        #region One time tax percent

        #region Common

        public decimal GetOneTimeTaxPercentSE(DateTime date, decimal annualSalary, DateTime birthDate)
        {
            switch (date.Year)
            {
                case 2014:
                    return GetOneTimeTaxIncomePercentSE_2014(annualSalary);
                case 2015:
                    return GetOneTimeTaxIncomePercentSE_2015(annualSalary);
                case 2016:
                case 2017:
                    return GetOneTimeTaxIncomePercentSE_2016(annualSalary);
                case 2018:
                    return GetOneTimeTaxIncomePercentSE_2018(annualSalary);
                case 2019:
                    return GetOneTimeTaxIncomePercentSE_2019(annualSalary);
                case 2020:
                    return GetOneTimeTaxIncomePercentSE_2020(annualSalary);
                case 2021:
                    return GetOneTimeTaxIncomePercentSE_2021(annualSalary);
                case 2022:
                    return GetOneTimeTaxIncomePercentSE_2022(annualSalary);
                case 2023:
                    return GetOneTimeTaxIncomePercentSE_2023(annualSalary, date.Year, birthDate);
                case 2024:
                    return GetOneTimeTaxIncomePercentSE_2024(annualSalary, date.Year, birthDate);
                case 2025:
                    return GetOneTimeTaxIncomePercentSE_2025(annualSalary, date.Year, birthDate);
                case 2026:
                    return GetOneTimeTaxIncomePercentSE_2026(annualSalary, date.Year, birthDate);
                default:
                    return 0;
            }
        }

        #endregion

        #region 2014

        private decimal GetOneTimeTaxIncomePercentSE_2014(decimal annualSalary)
        {
            if (annualSalary <= 18781)
                return 0.0M;
            else if (annualSalary <= 59200)
                return 0.1M;
            else if (annualSalary <= 130600)
                return 0.22M;
            else if (annualSalary <= 358800)
                return 0.3M;
            else if (annualSalary <= 433900)
                return 0.33M;
            else if (annualSalary <= 615700)
                return 0.53M;
            else
                return 0.58M;
        }

        #endregion

        #region 2015

        private decimal GetOneTimeTaxIncomePercentSE_2015(decimal annualSalary)
        {
            if (annualSalary <= 18823)
                return 0.0M;
            else if (annualSalary <= 59400)
                return 0.1M;
            else if (annualSalary <= 130900)
                return 0.22M;
            else if (annualSalary <= 359600)
                return 0.3M;
            else if (annualSalary <= 443300)
                return 0.33M;
            else if (annualSalary <= 629200)
                return 0.53M;
            else
                return 0.58M;
        }

        #endregion

        #region 2016-2017

        private decimal GetOneTimeTaxIncomePercentSE_2016(decimal annualSalary)
        {
            if (annualSalary <= 18738)
                return 0.0M;
            else if (annualSalary <= 60100)
                return 0.1M;
            else if (annualSalary <= 130200)
                return 0.23M;
            else if (annualSalary <= 357900)
                return 0.3M;
            else if (annualSalary <= 443200)
                return 0.33M;
            else if (annualSalary <= 599800)
                return 0.53M;
            else if (annualSalary <= 638800)
                return 0.56M;
            else if (annualSalary <= 1473900)
                return 0.61M;
            else
                return 0.58M;
        }

        #endregion

        #region 2018

        private decimal GetOneTimeTaxIncomePercentSE_2018(decimal annualSalary)
        {
            if (annualSalary <= 19246)
                return 0.0M;
            else if (annualSalary <= 61600)
                return 0.1M;
            else if (annualSalary <= 133700)
                return 0.23M;
            else if (annualSalary <= 367600)
                return 0.3M;
            else if (annualSalary <= 468700)
                return 0.33M;
            else if (annualSalary <= 616000)
                return 0.53M;
            else if (annualSalary <= 675700)
                return 0.56M;
            else if (annualSalary <= 1514400)
                return 0.61M;
            else
                return 0.58M;
        }

        #endregion

        #region 2019

        private decimal GetOneTimeTaxIncomePercentSE_2019(decimal annualSalary)
        {
            if (annualSalary <= 19669)
                return 0.0M;
            else if (annualSalary <= 63200)
                return 0.1M;
            else if (annualSalary <= 150600)
                return 0.23M;
            else if (annualSalary <= 375800)
                return 0.3M;
            else if (annualSalary <= 504400)
                return 0.33M;
            else if (annualSalary <= 629600)
                return 0.53M;
            else if (annualSalary <= 703000)
                return 0.56M;
            else if (annualSalary <= 1630700)
                return 0.61M;
            else
                return 0.58M;
        }

        #endregion

        #region 2020

        private decimal GetOneTimeTaxIncomePercentSE_2020(decimal annualSalary)
        {
            if (annualSalary <= 20007)
                return 0.0M;
            else if (annualSalary <= 63600)
                return 0.1M;
            else if (annualSalary <= 152400)
                return 0.23M;
            else if (annualSalary <= 379200)
                return 0.3M;
            else if (annualSalary <= 523200)
                return 0.34M;
            else if (annualSalary <= 640800)
                return 0.54M;
            else
                return 0.57M;
        }

        #endregion

        #region 2021

        private decimal GetOneTimeTaxIncomePercentSE_2021(decimal annualSalary)
        {
            // Tabell för engångsbelopp där den huvudsakliga årsinkomsten utgörs av arbetsinkomster, kolumn 1

            if (annualSalary <= 20134)
                return 0.0M;
            else if (annualSalary <= 63400)
                return 0.1M;
            else if (annualSalary <= 154800)
                return 0.23M;
            else if (annualSalary <= 386400)
                return 0.3M;
            else if (annualSalary <= 523200)
                return 0.34M;
            else if (annualSalary <= 644500)
                return 0.54M;
            else
                return 0.57M;
        }

        #endregion

        #region 2022

        private decimal GetOneTimeTaxIncomePercentSE_2022(decimal annualSalary)
        {
            // Tabell för engångsbelopp där den huvudsakliga årsinkomsten utgörs av arbetsinkomster, kolumn 1

            if (annualSalary <= 20134)
                return 0.0M;
            else if (annualSalary <= 63400)
                return 0.1M;
            else if (annualSalary <= 154800)
                return 0.23M;
            else if (annualSalary <= 386400)
                return 0.3M;
            else if (annualSalary <= 523200)
                return 0.34M;
            else if (annualSalary <= 644500)
                return 0.54M;
            else
                return 0.57M;
        }

        #endregion

        #region 2023

        private decimal GetOneTimeTaxIncomePercentSE_2023(decimal annualSalary, int year, DateTime birthDate)
        {
            // Tabell för engångsbelopp där den huvudsakliga årsinkomsten utgörs av arbetsinkomster, kolumn 1
            int age = year - birthDate.Year - 1;

            if (age == 65)
            {
                // Kolumn 7
                if (annualSalary <= 22207)
                    return 0.0M;
                else if (annualSalary <= 52800)
                    return 0.35M;
                else if (annualSalary <= 142800)
                    return 0.28M;
                else if (annualSalary <= 275500)
                    return 0.35M;
                else if (annualSalary <= 413700)
                    return 0.40M;
                else if (annualSalary <= 598500)
                    return 0.34M;
                else
                    return 0.54M;

            }
            else if (age > 65)
            {
                // Kolumn 3
                if (annualSalary <= 22207)
                    return 0.0M;
                else if (annualSalary <= 275600)
                    return 0.1M;
                else if (annualSalary <= 306000)
                    return 0.22M;
                else if (annualSalary <= 424200)
                    return 0.3M;
                else if (annualSalary <= 598500)
                    return 0.34M;
                else if (annualSalary <= 734000)
                    return 0.54M;
                else
                    return 0.59M;

            }
            else
            {
                // Kolumn 1
                if (annualSalary <= 22207)
                    return 0.0M;
                else if (annualSalary <= 67400)
                    return 0.1M;
                else if (annualSalary <= 170100)
                    return 0.22M;
                else if (annualSalary <= 424200)
                    return 0.3M;
                else if (annualSalary <= 598500)
                    return 0.34M;
                else if (annualSalary <= 710850)
                    return 0.54M;
                else
                    return 0.57M;

            }
        }

        #endregion

        #region 2024

        private decimal GetOneTimeTaxIncomePercentSE_2024(decimal annualSalary, int year, DateTime birthDate)
        {
            // Tabell för engångsbelopp där den huvudsakliga årsinkomsten utgörs av löner, arvoden och liknande ersättningar
            int age = year - birthDate.Year - 1;

            if (age < 66)
            {
                // Till den som vid årets ingång inte fyllt 66 år, kolumn 1
                if (annualSalary <= 24237)
                    return 0.0M;
                else if (annualSalary <= 80900)
                    return 0.1M;
                else if (annualSalary <= 185700)
                    return 0.21M;
                else if (annualSalary <= 463000)
                    return 0.28M;
                else if (annualSalary <= 598500)
                    return 0.34M;
                else if (annualSalary <= 775900)
                    return 0.54M;
                else
                    return 0.57M;
            }
            else
            {
                // Till den som vid årets ingång fyllt 66 år, kolumn 3
                if (annualSalary <= 24237)
                    return 0.0M;
                else if (annualSalary <= 310800)
                    return 0.1M;
                else if (annualSalary <= 463000)
                    return 0.28M;
                else if (annualSalary <= 598500)
                    return 0.34M;
                else if (annualSalary <= 775900)
                    return 0.57M;
                else
                    return 0.60M;
            }
        }

        #endregion

        #region 2025

        private decimal GetOneTimeTaxIncomePercentSE_2025(decimal annualSalary, int year, DateTime birthDate)
        {
            // Tabell för engångsbelopp där den huvudsakliga årsinkomsten utgörs av löner, arvoden och liknande ersättningar
            int age = year - birthDate.Year - 1;

            if (age < 66)
            {
                // Till den som vid årets ingång inte fyllt 66 år, kolumn 1
                if (annualSalary <= 24872)
                    return 0.0M;
                else if (annualSalary <= 83100)
                    return 0.1M;
                else if (annualSalary <= 190600)
                    return 0.21M;
                else if (annualSalary <= 475200)
                    return 0.28M;
                else if (annualSalary <= 643100)
                    return 0.34M;
                else
                    return 0.54M;
            }
            else
            {
                // Till den som vid årets ingång fyllt 66 år, kolumn 3
                if (annualSalary <= 24872)
                    return 0.0M;
                else if (annualSalary <= 313600)
                    return 0.1M;
                else if (annualSalary <= 475200)
                    return 0.27M;
                else if (annualSalary <= 643100)
                    return 0.34M;
                else
                    return 0.54M;
            }
        }

        #endregion

        #region 2026

        private decimal GetOneTimeTaxIncomePercentSE_2026(decimal annualSalary, int year, DateTime birthDate)
        {
            // Tabell för engångsbelopp där den huvudsakliga årsinkomsten utgörs av löner, arvoden och liknande ersättningar
            int age = year - birthDate.Year - 1;

            if (age < 66)
            {
                // Sektion 10.1 : Till den som vid årets ingång inte fyllt 66 år, kolumn 1 
                if (annualSalary <= 25041)
                    return 0.0M;
                else if (annualSalary <= 82800)
                    return 0.1M;
                else if (annualSalary <= 192000)
                    return 0.21M;
                else if (annualSalary <= 477600)
                    return 0.26M;
                else if (annualSalary <= 660000)
                    return 0.34M;
                else
                    return 0.54M;
            }
            else
            {
                // Sektion 10.3 : Till den som vid årets ingång fyllt 66 år, kolumn 3
                if (annualSalary <= 25041)
                    return 0.0M;
                else if (annualSalary <= 331200)
                    return 0.1M;
                else if (annualSalary <= 477600)
                    return 0.26M;
                else if (annualSalary <= 660000)
                    return 0.34M;
                else
                    return 0.55M;
            }
        }

        #endregion

        #endregion

        #endregion

        #endregion

        #region TimePeriod

        public Dictionary<int, List<int>> GetValidEmployeesForTimePeriod(int actorCompanyId, List<int> timePeriodIds, List<Employee> employees, List<PayrollGroup> payrollGroups = null, bool checkEmployeeTimePeriod = true, List<EmployeeTimePeriod> employeeTimePeriods = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetValidEmployeesForTimePeriod(entities, actorCompanyId, timePeriodIds, employees, payrollGroups, checkEmployeeTimePeriod, employeeTimePeriods);
        }

        public Dictionary<int, List<int>> GetValidEmployeesForTimePeriod(CompEntities entities, int actorCompanyId, List<int> timePeriodIds, List<Employee> employees, List<PayrollGroup> payrollGroups = null, bool checkEmployeeTimePeriod = true, List<EmployeeTimePeriod> employeeTimePeriods = null)
        {
            Dictionary<int, List<int>> dict = new Dictionary<int, List<int>>();
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();

            List<TimePeriod> timePeriods = TimePeriodManager.GetTimePeriods(entities, timePeriodIds, actorCompanyId);
            if (payrollGroups == null)
                payrollGroups = GetPayrollGroupsFromCache(entitiesReadOnly, CacheConfig.Company(actorCompanyId));

            foreach (var timePeriod in timePeriods)
            {
                if (timePeriod == null || timePeriod.TimePeriodHead == null || !timePeriod.PaymentDate.HasValue || !timePeriod.PayrollStartDate.HasValue || !timePeriod.PayrollStopDate.HasValue)
                    continue;

                DateTime startDate;
                DateTime stopDate;

                if (timePeriod.ExtraPeriod)
                {
                    DateTime paymentDate = timePeriod.PaymentDate.Value;
                    startDate = paymentDate.AddYears(-1);
                    stopDate = paymentDate;
                }
                else
                {
                    startDate = timePeriod.StartDate;
                    stopDate = timePeriod.StopDate;
                }

                List<int> validEmployeeIds = new List<int>();

                foreach (var employee in employees)
                {
                    EmployeeTimePeriod employeeTimePeriod;
                    if (employeeTimePeriods.IsNullOrEmpty())
                        employeeTimePeriod = TimePeriodManager.GetEmployeeTimePeriod(entities, employee.EmployeeId, timePeriod.TimePeriodId, actorCompanyId);
                    else
                        employeeTimePeriod = TimePeriodManager.GetEmployeeTimePeriod(employeeTimePeriods, employee.EmployeeId, timePeriod.TimePeriodId, actorCompanyId);
                    if (employeeTimePeriod != null && employeeTimePeriod.IsLockOrHigher())
                    {
                        validEmployeeIds.Add(employee.EmployeeId);
                        continue;
                    }

                    DateTime employmentStartDate = startDate;
                    DateTime employmentStopDate = stopDate;

                    List<Employment> employments = employee.GetEmployments(employmentStartDate, employmentStopDate);
                    Employment employment = null;
                    List<DateTime> employmentDates = employments.GetEmploymentDates(employmentStartDate, employmentStopDate);
                    if (employmentDates.IsNullOrEmpty())
                    {
                        employmentStartDate = timePeriod.PayrollStartDate.Value;
                        employmentStopDate = timePeriod.PayrollStopDate.Value;
                        employments = employee.GetEmployments(employmentStartDate, employmentStopDate);
                        employmentDates = employments.GetEmploymentDates(employmentStartDate, employmentStopDate);
                    }
                    if (employmentDates.Count > 0)
                        employment = employments.GetEmployment(employmentDates.Last());

                    if (employment != null)
                    {
                        PayrollGroup payrollGroup = employment.GetPayrollGroup(employmentStartDate, employmentStopDate, payrollGroups, forward: false);
                        if (payrollGroup == null || payrollGroup.TimePeriodHeadId != timePeriod.TimePeriodHead.TimePeriodHeadId)
                            continue;

                        if (checkEmployeeTimePeriod)
                        {
                            if (employeeTimePeriods.IsNullOrEmpty())
                                employeeTimePeriod = TimePeriodManager.GetEmployeeTimePeriod(entities, employee.EmployeeId, timePeriod.TimePeriodId, actorCompanyId);
                            else
                                employeeTimePeriod = TimePeriodManager.GetEmployeeTimePeriod(employeeTimePeriods, employee.EmployeeId, timePeriod.TimePeriodId, actorCompanyId);

                            if (employeeTimePeriod == null)
                                continue;
                        }
                        validEmployeeIds.Add(employee.EmployeeId);
                    }
                    else
                    {
                        //this else covers when an employee has no employment (doesn't work here anymore) but will recieve an payment in this period anyway
                        if (!employeeTimePeriods.IsNullOrEmpty())
                            employeeTimePeriod = TimePeriodManager.GetEmployeeTimePeriod(employeeTimePeriods, employee.EmployeeId, timePeriod.TimePeriodId, actorCompanyId);

                        if (employeeTimePeriod == null)
                            employeeTimePeriod = TimePeriodManager.GetEmployeeTimePeriod(entities, employee.EmployeeId, timePeriod.TimePeriodId, actorCompanyId);

                        if (employeeTimePeriod != null)// consider the employee as valid
                            validEmployeeIds.Add(employee.EmployeeId);
                    }
                }

                dict.Add(timePeriod.TimePeriodId, validEmployeeIds);
            }

            return dict;
        }

        #endregion

        #region UnionFee

        public Dictionary<int, string> GetUnionFeesDict(int employeeId, bool addEmptyRow)
        {
            Dictionary<int, string> dict = new Dictionary<int, string>();
            if (addEmptyRow)
                dict.Add(0, " ");

            var fees = GetUnionFees(employeeId);
            foreach (var fee in fees)
            {
                if (!dict.ContainsKey(fee.UnionFeeId))
                    dict.Add(fee.UnionFeeId, fee.Name);
            }

            return dict;
        }

        public UnionFee GetUnionFee(int unionFeeId, int actorCompanyId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.UnionFee.NoTracking();
            return GetUnionFee(entities, unionFeeId, actorCompanyId);
        }

        private UnionFee GetUnionFee(CompEntities entities, int unionFeeId, int actorCompanyId)
        {
            return (from u in entities.UnionFee
                    where u.ActorCompanyId == actorCompanyId &&
                    u.UnionFeeId == unionFeeId &&
                    u.State == (int)SoeEntityState.Active
                    select u).FirstOrDefault();
        }

        public List<UnionFee> GetUnionFees(int actorCompanyId, bool onlyActive = true, bool showDeleted = false, bool loadPriceTypes = false, bool loadPayrollProducts = false, int? unionFeeId = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.UnionFee.NoTracking();
            return GetUnionFees(entities, actorCompanyId, onlyActive, showDeleted, loadPriceTypes, loadPayrollProducts, unionFeeId);
        }

        private List<UnionFee> GetUnionFees(CompEntities entities, int actorCompanyId, bool onlyActive = true, bool showDeleted = false, bool loadPriceTypes = false, bool loadPayrollProducts = false, int? unionFeeId = null)
        {
            IQueryable<UnionFee> query = entities.UnionFee;
            List<UnionFee> ret = new List<UnionFee>();

            if (unionFeeId.HasValue)
                query = query.Where(u => u.UnionFeeId == unionFeeId);

            if (loadPriceTypes)
                query = query.Include("PayrollPriceTypePercent").Include("PayrollPriceTypePercentCeiling").Include("PayrollPriceTypeFixedAmount");
            if (loadPayrollProducts)
                query = query.Include("PayrollProduct");

            List<UnionFee> rows = (from u in query
                                   where u.ActorCompanyId == actorCompanyId
                                   select u).ToList();
            if (onlyActive)
                ret.AddRange(rows.Where(w => w.State == (int)SoeEntityState.Active).ToList());
            else
                ret.AddRange(rows.Where(w => w.State == (int)SoeEntityState.Active || w.State == (int)SoeEntityState.Inactive).ToList());

            if (showDeleted)
                ret.AddRange(rows.Where(w => w.State == (int)SoeEntityState.Deleted).ToList());

            return ret;
        }

        public ActionResult SaveUnionFee(UnionFeeDTO unionFeeInput, int actorCompanyId)
        {
            if (unionFeeInput == null)
                return new ActionResult((int)ActionResultSave.EntityIsNull, "UnionFee");

            // Default result is successful
            ActionResult result = null;

            int unionFeeId = unionFeeInput.UnionFeeId;

            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    entities.Connection.Open();

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_DEFAULT))
                    {
                        #region UnionFee

                        // Get existing
                        UnionFee unionFee = GetUnionFee(entities, unionFeeId, actorCompanyId);
                        if (unionFee == null)
                        {
                            #region Add

                            unionFee = new UnionFee()
                            {
                                ActorCompanyId = actorCompanyId,
                            };
                            SetCreatedProperties(unionFee);
                            entities.UnionFee.AddObject(unionFee);

                            #endregion
                        }
                        else
                        {
                            #region Update

                            SetModifiedProperties(unionFee);

                            #endregion
                        }

                        unionFee.Name = unionFeeInput.Name;
                        unionFee.PayrollPriceTypeIdPercent = (unionFeeInput.PayrollPriceTypeIdPercent.HasValue && unionFeeInput.PayrollPriceTypeIdPercent.Value != 0) ? unionFeeInput.PayrollPriceTypeIdPercent.Value : (int?)null;
                        unionFee.PayrollPriceTypeIdPercentCeiling = (unionFeeInput.PayrollPriceTypeIdPercentCeiling.HasValue && unionFeeInput.PayrollPriceTypeIdPercentCeiling.Value != 0) ? unionFeeInput.PayrollPriceTypeIdPercentCeiling.Value : (int?)null;
                        unionFee.PayrollPriceTypeIdFixedAmount = (unionFeeInput.PayrollPriceTypeIdFixedAmount.HasValue && unionFeeInput.PayrollPriceTypeIdFixedAmount.Value != 0) ? unionFeeInput.PayrollPriceTypeIdFixedAmount.Value : (int?)null;
                        unionFee.PayrollProductId = (unionFeeInput.PayrollProductId.HasValue && unionFeeInput.PayrollProductId.Value != 0) ? unionFeeInput.PayrollProductId.Value : (int?)null;
                        unionFee.State = (int)unionFeeInput.State;
                        unionFee.Association = unionFeeInput.Association;


                        #endregion

                        result = SaveChanges(entities, transaction);
                        if (result.Success)
                        {
                            //Commit transaction
                            transaction.Complete();

                            unionFeeId = unionFee.UnionFeeId;
                        }
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result = new ActionResult(ex);
                }
                finally
                {
                    if (result != null && result.Success)
                    {
                        //Set success properties
                        result.IntegerValue = unionFeeId;
                    }
                    else
                    {
                        if (result != null)
                            result = new ActionResult(false);

                        base.LogTransactionFailed(this.ToString(), this.log);
                    }

                    entities.Connection.Close();
                }
            }

            return result;
        }

        public ActionResult DeleteUnionFee(int unionFeeId, int actorCompanyId)
        {
            using (CompEntities entities = new CompEntities())
            {
                UnionFee unionFee = GetUnionFee(entities, unionFeeId, actorCompanyId);
                if (unionFee == null)
                    return new ActionResult((int)ActionResultDelete.EntityNotFound, "UnionFee");

                return ChangeEntityState(entities, unionFee, SoeEntityState.Deleted, true);
            }
        }

        #endregion

        #region Vacation (SE)

        public EmployeeVacationPeriodDTO GetEmployeeVacationPeriod(int actorCompanyId, int employeeId, int timePeriodId)
        {
            //TimePeriod cannot be null
            TimePeriod timePeriod = TimePeriodManager.GetTimePeriod(timePeriodId, actorCompanyId);
            if (timePeriod == null)
                return new EmployeeVacationPeriodDTO();

            return GetEmployeeVacationPeriod(actorCompanyId, employeeId, timePeriod.StartDate, timePeriod.StopDate, timePeriod);
        }

        public EmployeeVacationPeriodDTO GetEmployeeVacationPeriod(int actorCompanyId, int employeeId, DateTime startDate, DateTime stopDate, TimePeriod timePeriod = null)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetEmployeeVacationPeriod(entities, actorCompanyId, employeeId, startDate, stopDate, timePeriod);
        }

        public EmployeeVacationPeriodDTO GetEmployeeVacationPeriod(CompEntities entities, int actorCompanyId, int employeeId, DateTime startDate, DateTime stopDate, TimePeriod timePeriod = null, List<TimePayrollTransaction> periodTransactions = null)
        {
            if (timePeriod == null)
            {
                TimePeriodHead timePeriodHead = TimePeriodManager.GetDefaultTimePeriodHead(entities, actorCompanyId, false);
                if (timePeriodHead != null)
                    timePeriod = TimePeriodManager.GetTimePeriod(entities, startDate, timePeriodHead.TimePeriodHeadId, actorCompanyId);
            }

            #region Get prel vacation days

            Dictionary<CompanySettingType, int> companySettingAttestStateIds = AttestManager.GetPayrollLockedAttestStateSettings(entities, actorCompanyId, excludeExportPayrollResulting: true);
            List<int> attestStateIds = companySettingAttestStateIds.Select(i => i.Value).ToList();
            List<TimePayrollTransaction> allTimePayrollTransactions = periodTransactions != null ? periodTransactions : TimeTransactionManager.GetTimePayrollTransactionsForEmployee(entities, employeeId, startDate, stopDate, loadExtended: true);
            allTimePayrollTransactions = allTimePayrollTransactions.Where(x => !attestStateIds.Contains(x.AttestStateId)).ToList();

            #endregion

            #region Hour Vacaction

            bool calculateHours = false;
            decimal calculateHoursDayFactor = 0;

            if (timePeriod != null && timePeriod.PayrollStopDate.HasValue)
            {
                Employee employee = EmployeeManager.GetEmployee(entities, employeeId, actorCompanyId, loadEmployment: true);
                if (employee != null)
                {
                    Employment employment = employee.GetEmployment(timePeriod.PayrollStopDate);
                    if (employment != null)
                    {
                        List<VacationGroup> vacationGroups = PayrollManager.GetVacationGroups(entities, actorCompanyId);
                        if (vacationGroups.Any())
                        {
                            VacationGroup VacationGroup = employment.GetVacationGroup(timePeriod.PayrollStopDate, vacationGroups);
                            if (VacationGroup != null && VacationGroup.VacationGroupSE.Any())
                                calculateHours = VacationGroup.VacationGroupSE.First().VacationHandleRule == (int)TermGroup_VacationGroupVacationHandleRule.Hours;

                            if (calculateHours)
                            {
                                var workTimeWeek = employment.GetWorkTimeWeek();
                                if (workTimeWeek > 0)
                                {
                                    List<EmployeeFactor> vacationFactorsNet = EmployeeManager.GetEmployeeFactors(entities, employment.EmployeeId, TermGroup_EmployeeFactorType.Net);
                                    EmployeeFactor vacationFactorNet = EmployeeManager.GetEmployeeFactor(vacationFactorsNet, timePeriod.PayrollStopDate.Value);
                                    decimal netFactor = vacationFactorNet == null ? 5 : vacationFactorNet.Factor;
                                    calculateHoursDayFactor = decimal.Divide(decimal.Divide(workTimeWeek, new decimal(60)), netFactor);
                                }
                            }
                        }
                    }
                }
            }

            #endregion

            #region Get vacation days

            EmployeeVacationSE employeeVacationSE = EmployeeManager.GetLatestEmployeeVacationSE(entities, employeeId);

            EmployeeVacationPeriodDTO dto = new EmployeeVacationPeriodDTO()
            {
                CalculateHours = calculateHours,
                CalculateHoursDayFactor = calculateHoursDayFactor,
                EmployeeId = employeeId,
                TimePeriodId = timePeriod?.TimePeriodId ?? 0,
                RemainingDaysPaid = employeeVacationSE != null && employeeVacationSE.RemainingDaysPaid.HasValue ? employeeVacationSE.RemainingDaysPaid.Value : 0,
                RemainingDaysUnpaid = employeeVacationSE != null && employeeVacationSE.RemainingDaysUnpaid.HasValue ? employeeVacationSE.RemainingDaysUnpaid.Value : 0,
                RemainingDaysAdvance = employeeVacationSE != null && employeeVacationSE.RemainingDaysAdvance.HasValue ? employeeVacationSE.RemainingDaysAdvance.Value : 0,
                RemainingDaysOverdue = employeeVacationSE != null && employeeVacationSE.RemainingDaysOverdue.HasValue ? employeeVacationSE.RemainingDaysOverdue.Value : 0,
                RemainingDaysYear1 = employeeVacationSE != null && employeeVacationSE.RemainingDaysYear1.HasValue ? employeeVacationSE.RemainingDaysYear1.Value : 0,
                RemainingDaysYear2 = employeeVacationSE != null && employeeVacationSE.RemainingDaysYear2.HasValue ? employeeVacationSE.RemainingDaysYear2.Value : 0,
                RemainingDaysYear3 = employeeVacationSE != null && employeeVacationSE.RemainingDaysYear3.HasValue ? employeeVacationSE.RemainingDaysYear3.Value : 0,
                RemainingDaysYear4 = employeeVacationSE != null && employeeVacationSE.RemainingDaysYear4.HasValue ? employeeVacationSE.RemainingDaysYear4.Value : 0,
                RemainingDaysYear5 = employeeVacationSE != null && employeeVacationSE.RemainingDaysYear5.HasValue ? employeeVacationSE.RemainingDaysYear5.Value : 0,
                EarnedDaysRemainingHoursPaid = employeeVacationSE != null && employeeVacationSE.EarnedDaysRemainingHoursPaid.HasValue ? employeeVacationSE.EarnedDaysRemainingHoursPaid.Value : 0,
                EarnedDaysRemainingHoursUnpaid = employeeVacationSE != null && employeeVacationSE.EarnedDaysRemainingHoursUnpaid.HasValue ? employeeVacationSE.EarnedDaysRemainingHoursUnpaid.Value : 0,
                EarnedDaysRemainingHoursAdvance = employeeVacationSE != null && employeeVacationSE.EarnedDaysRemainingHoursAdvance.HasValue ? employeeVacationSE.EarnedDaysRemainingHoursAdvance.Value : 0,
                EarnedDaysRemainingHoursOverdue = employeeVacationSE != null && employeeVacationSE.EarnedDaysRemainingHoursOverdue.HasValue ? employeeVacationSE.EarnedDaysRemainingHoursOverdue.Value : 0,
                EarnedDaysRemainingHoursYear1 = employeeVacationSE != null && employeeVacationSE.EarnedDaysRemainingHoursYear1.HasValue ? employeeVacationSE.EarnedDaysRemainingHoursYear1.Value : 0,
                EarnedDaysRemainingHoursYear2 = employeeVacationSE != null && employeeVacationSE.EarnedDaysRemainingHoursYear2.HasValue ? employeeVacationSE.EarnedDaysRemainingHoursYear2.Value : 0,
                EarnedDaysRemainingHoursYear3 = employeeVacationSE != null && employeeVacationSE.EarnedDaysRemainingHoursYear3.HasValue ? employeeVacationSE.EarnedDaysRemainingHoursYear3.Value : 0,
                EarnedDaysRemainingHoursYear4 = employeeVacationSE != null && employeeVacationSE.EarnedDaysRemainingHoursYear4.HasValue ? employeeVacationSE.EarnedDaysRemainingHoursYear4.Value : 0,
                EarnedDaysRemainingHoursYear5 = employeeVacationSE != null && employeeVacationSE.EarnedDaysRemainingHoursYear5.HasValue ? employeeVacationSE.EarnedDaysRemainingHoursYear5.Value : 0,
            };

            VacationDaysCalculationDTO vacationDaysCalculationDTO = allTimePayrollTransactions.ToVacationDaysCalculationDTO(calculateHours);
            dto.PeriodDaysPaid = vacationDaysCalculationDTO.PeriodUsedDaysPaidCount;
            dto.PeriodDaysUnpaid = vacationDaysCalculationDTO.PeriodUsedDaysUnpaidCount;
            dto.PeriodDaysAdvance = vacationDaysCalculationDTO.PeriodUsedDaysAdvanceCount;
            dto.PeriodDaysSavedYear1 = vacationDaysCalculationDTO.PeriodUsedDaysYear1Count;
            dto.PeriodDaysSavedYear2 = vacationDaysCalculationDTO.PeriodUsedDaysYear2Count;
            dto.PeriodDaysSavedYear3 = vacationDaysCalculationDTO.PeriodUsedDaysYear3Count;
            dto.PeriodDaysSavedYear4 = vacationDaysCalculationDTO.PeriodUsedDaysYear4Count;
            dto.PeriodDaysSavedYear5 = vacationDaysCalculationDTO.PeriodUsedDaysYear5Count;
            dto.PeriodDaysOverdue = vacationDaysCalculationDTO.PeriodUsedDaysOverdueCount;
            dto.PeriodVacationCompensationPaidCount = vacationDaysCalculationDTO.PeriodVacationCompensationPaidCount;
            dto.PeriodVacationCompensationSavedCount = vacationDaysCalculationDTO.PeriodVacationCompensationSavedYear1Count;
            dto.PeriodVacationCompensationSavedCount += vacationDaysCalculationDTO.PeriodVacationCompensationSavedYear2Count;
            dto.PeriodVacationCompensationSavedCount += vacationDaysCalculationDTO.PeriodVacationCompensationSavedYear3Count;
            dto.PeriodVacationCompensationSavedCount += vacationDaysCalculationDTO.PeriodVacationCompensationSavedYear4Count;
            dto.PeriodVacationCompensationSavedCount += vacationDaysCalculationDTO.PeriodVacationCompensationSavedYear5Count;
            dto.PeriodVacationCompensationSavedCount += vacationDaysCalculationDTO.PeriodVacationCompensationSavedOverdueCount;

            #endregion

            return dto;
        }

        public EmployeeVacationPrelUsedDaysDTO GetEmployeeVacationPrelUsedDays(int actorCompanyId, int employeeId, DateTime date, bool isHours = false, Employee employee = null, List<EmployeeTimePeriod> employeeTimePeriods = null, EmployeeVacationSE lastEmployeeVacation = null)
        {
            EmployeeVacationPrelUsedDaysDTO result = new EmployeeVacationPrelUsedDaysDTO
            {
                EmployeeId = employeeId,
                IsHours = isHours,
            };

            employee = employee ?? EmployeeManager.GetEmployee(employeeId, actorCompanyId, loadEmployment: true);
            if (employee == null)
                return result;

            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();

            // Get end of vacation year
            DateTime? vacationGroupToDate = GetVacationGroupToDate(employee, date);
            if (!vacationGroupToDate.HasValue)
            {
                Employment lastEmployment = employee.GetLastEmployment();
                if (lastEmployment != null && lastEmployment.DateTo.HasValue && lastEmployment.DateTo < date)
                    vacationGroupToDate = GetVacationGroupToDate(employee, lastEmployment.DateTo);
            }

            DateTime? lastExportedDate = null;
            if (vacationGroupToDate.HasValue)
            {
                // Get last exported salary period
                List<TimePeriod> lockedTimePeriods = !employeeTimePeriods.IsNullOrEmpty()
                                                        ?
                                                            (from etp in employeeTimePeriods
                                                             where etp.EmployeeId == employeeId &&
                                                            (etp.Status == (int)SoeEmployeeTimePeriodStatus.Locked || etp.Status == (int)SoeEmployeeTimePeriodStatus.Paid) &&
                                                            etp.State == (int)SoeEntityState.Active &&
                                                            !etp.TimePeriod.ExtraPeriod &&
                                                            etp.TimePeriod.TimePeriodHead.State == (int)SoeEntityState.Active
                                                             select etp.TimePeriod).ToList()
                                                        :
                                                              (from etp in entitiesReadOnly.EmployeeTimePeriod
                                                               where etp.EmployeeId == employeeId &&
                                                               (etp.Status == (int)SoeEmployeeTimePeriodStatus.Locked || etp.Status == (int)SoeEmployeeTimePeriodStatus.Paid) &&
                                                               etp.State == (int)SoeEntityState.Active &&
                                                               !etp.TimePeriod.ExtraPeriod &&
                                                               etp.TimePeriod.TimePeriodHead.State == (int)SoeEntityState.Active
                                                               select etp.TimePeriod).ToList();

                if (!lockedTimePeriods.IsNullOrEmpty())
                    lastExportedDate = (lockedTimePeriods.Select(p => p.StopDate).Max()).AddDays(1);
            }

            if (!lastExportedDate.HasValue)
            {
                lastEmployeeVacation = lastEmployeeVacation ?? EmployeeManager.GetLatestEmployeeVacationSE(employeeId);
                if (lastEmployeeVacation != null)
                {
                    lastExportedDate = lastEmployeeVacation.AdjustmentDateOrCreated;
                    if (!vacationGroupToDate.HasValue)
                        vacationGroupToDate = date.AddDays(1);

                    if (lastExportedDate < DateTime.Now.AddYears(-1))
                        lastExportedDate = DateTime.Now.AddYears(-1);
                }
            }

            if (lastExportedDate.HasValue)
            {
                List<TimePayrollTransaction> vacationTransactions = TimeTransactionManager.GetTimePayrollTransactionsForEmployee(entitiesReadOnly, employeeId, fromDate: lastExportedDate, toDate: vacationGroupToDate, sysPayrollTypeLevel3: TermGroup_SysPayrollType.SE_GrossSalary_Absence_Vacation).ToList();
                vacationTransactions = vacationTransactions.Where(i => (i.Quantity != 0 || i.IsVacationFiveDaysPerWeek) && !i.IsAbsenceVacationNoVacationDaysDeducted()).ToList();
                if (!isHours)
                {
                    result.Sum = vacationTransactions.Select(t => t.TimeBlockDateId).Distinct().Count();
                    if (result.Sum > 0)
                        result.Details = vacationTransactions.Select(t => t.TimeBlockDate.Date).GetCoherentDateRangeText(appendLinebreak: true);
                }
                else
                    result.Sum = decimal.Round(decimal.Divide(vacationTransactions.Sum(s => s.Quantity), 60), 2);
            }

            return result;
        }

        public decimal GetEarningYearIsVacationYearVacationDays(int vacationGroupId, int employeeId, int actorCompanyId, DateTime date, DateTime? dateFrom, DateTime? dateTo)
        {
            decimal days = 0;

            if (dateFrom.HasValue)
            {
                VacationGroup vacationGroup = GetVacationGroup(vacationGroupId);
                if (vacationGroup != null && vacationGroup.Type == (int)TermGroup_VacationGroupType.EarningYearIsVacationYear)
                {
                    #region Antal dagar som anställningen omfattar under intjänandeåret / dagar på året) * semesterrätten

                    DateTime vacationGroupDateFrom = vacationGroup.ActualFromDate(date);
                    DateTime vacationGroupDateTo = vacationGroup.ActualStopDate(date);
                    DateTime employmentDateFrom = CalendarUtility.GetLatestDate(vacationGroupDateFrom, dateFrom.Value);
                    DateTime employmentDateTo = CalendarUtility.GetEarliestDate(vacationGroupDateTo, dateTo ?? DateTime.MaxValue);

                    int employmentDaysInVacationYear = (int)employmentDateTo.Subtract(employmentDateFrom).TotalDays + 1;
                    int daysInVacationYear = (int)vacationGroup.ActualStopDate(date).Subtract(vacationGroup.ActualFromDate(date)).TotalDays + 1;
                    int SR = (int)EmployeeManager.GetEmployeeFactor(employeeId, TermGroup_EmployeeFactorType.VacationDaysPaidByLaw, date);
                    if (SR == 0 && vacationGroup.VacationDaysPaidByLaw.HasValue)
                        SR = vacationGroup.VacationDaysPaidByLaw.Value;

                    int additionalDays = 0;
                    VacationGroupSE vacationGroupSE = GetVacationGroupSE(vacationGroup);
                    if (vacationGroupSE != null && vacationGroupSE.UseAdditionalVacationDays && vacationGroupSE.NbrOfAdditionalVacationDays > 0)
                    {
                        Employee employee = EmployeeManager.GetEmployee(employeeId, actorCompanyId, loadContactPerson: true);
                        int age = EmployeeManager.GetEmployeeAge(employee, employmentDateTo);
                        if (age != 0 && age >= vacationGroupSE.AdditionalVacationDaysFromAge1)
                        {
                            additionalDays = vacationGroupSE.AdditionalVacationDays1 ?? 0;
                            if (age >= vacationGroupSE.AdditionalVacationDaysFromAge2)
                                additionalDays = vacationGroupSE.AdditionalVacationDays2 ?? 0;

                            if (age >= vacationGroupSE.AdditionalVacationDaysFromAge3)
                                additionalDays = vacationGroupSE.AdditionalVacationDays3 ?? 0;
                        }
                    }

                    days = Decimal.Ceiling(Decimal.Divide(employmentDaysInVacationYear, daysInVacationYear) * (SR + additionalDays));

                    #endregion
                }
            }

            return days;
        }

        #endregion

        #region VacationGroup

        public List<VacationGroup> GetVacationGroupsWithVacationGroupSE(int actorCompanyId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.VacationGroup.NoTracking();
            return GetVacationGroupsWithVacationGroupSE(entities, actorCompanyId);
        }

        public List<VacationGroup> GetVacationGroupsWithVacationGroupSE(CompEntities entities, int actorCompanyId)
        {
            List<VacationGroup> groups = (from vg in entities.VacationGroup
                                          .Include("VacationGroupSE")
                                          where vg.ActorCompanyId == actorCompanyId &&
                                          vg.State == (int)SoeEntityState.Active
                                          select vg).ToList();

            return groups;
        }

        public List<VacationGroup> GetVacationGroups(int actorCompanyId, bool setTypeName = false, bool onlyActive = true, bool loadExternalCode = false)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.VacationGroup.NoTracking();
            return GetVacationGroups(entities, actorCompanyId, setTypeName, onlyActive, loadExternalCode);
        }

        public List<VacationGroup> GetVacationGroups(CompEntities entities, int actorCompanyId, bool setTypeName = false, bool onlyActive = true, bool loadExternalCode = false)
        {
            List<VacationGroup> vacationGroups = (from vg in entities.VacationGroup
                                                    .Include("VacationGroupSE")
                                                  where vg.ActorCompanyId == actorCompanyId &&
                                                  (onlyActive ? vg.State == (int)SoeEntityState.Active : vg.State != (int)SoeEntityState.Deleted)
                                                  orderby vg.FromDate descending, vg.Name
                                                  select vg).ToList();

            if (vacationGroups.IsNullOrEmpty())
                return new List<VacationGroup>();

            if (setTypeName)
                SetVacationGroupsTypeNames(vacationGroups);
            if (loadExternalCode)
                LoadVacationGroupExternalCodes(entities, vacationGroups, actorCompanyId);

            return vacationGroups;
        }

        public List<VacationGroup> GetVacationGroups(CompEntities entities, List<int> vacationGroupIds, bool setLatestVacationYearEnd = false)
        {
            if (vacationGroupIds.IsNullOrEmpty())
                return new List<VacationGroup>();

            return (from vg in entities.VacationGroup.Include("VacationGroupSE")
                    where vacationGroupIds.Contains(vg.VacationGroupId) &&
                    vg.State == (int)SoeEntityState.Active
                    select vg).ToList();
        }

        public Dictionary<int, string> GetVacationGroupsDictV2(int actorCompanyId, bool addEmptyRow = false)
        {
            Dictionary<int, string> dict = new Dictionary<int, string>();
            if (addEmptyRow)
                dict.Add(0, " ");

            var vGroups = GetVacationGroups(actorCompanyId);
            foreach (var vGroup in vGroups)
                dict.Add(vGroup.VacationGroupId, vGroup.Name);

            return dict;
        }

        public Dictionary<int, string> GetVacationGroupsDict(int actorCompanyId, bool addEmptyRow = false)
        {
            Dictionary<int, string> dict = GetVacationGroups(actorCompanyId).ToDictionary(k => k.VacationGroupId, v => v.Name);
            if (addEmptyRow)
                dict.Add(0, " ");
            return dict.Sort();
        }

        public VacationGroup GetVacationGroup(int vacationGroupId, bool setLatestVacationYearEnd = false, bool loadExternalCode = false)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.VacationGroup.NoTracking();
            return GetVacationGroup(entities, vacationGroupId, setLatestVacationYearEnd, loadExternalCode);
        }

        public VacationGroup GetVacationGroup(CompEntities entities, int vacationGroupId, bool setLatestVacationYearEnd = false, bool loadExternalCode = false)
        {
            int actorCompanyId = base.ActorCompanyId;
            VacationGroup vacationGroup = (from vg in entities.VacationGroup.Include("VacationGroupSE").Include("VacationGroupSE.VacationGroupSEDayType")
                                           where vg.VacationGroupId == vacationGroupId &&
                                           vg.ActorCompanyId == actorCompanyId &&
                                           vg.State == (int)SoeEntityState.Active
                                           select vg).FirstOrDefault();

            if (vacationGroup != null && setLatestVacationYearEnd)
            {
                vacationGroup.LatestVacationYearEnd = (from y in entities.VacationYearEndHead
                                                       where y.VacationGroup.Any(v => v.VacationGroupId == vacationGroup.VacationGroupId && v.Type == (int)SoeVacationYearEndType.VacationYearEnd)
                                                       orderby y.Date descending
                                                       select y.Date).FirstOrDefault();

                // SQL Server will return 0001-01-01 since VacationYearEndHead.Date is not nullable
                if (vacationGroup.LatestVacationYearEnd == DateTime.MinValue)
                    vacationGroup.LatestVacationYearEnd = null;
            }

            #region ExternalCode 

            if (vacationGroup != null && loadExternalCode)
            {
                vacationGroup.ExternalCodes = new List<string>();

                var externalCodes = ActorManager.GetCompanyExternalCodes(entities, TermGroup_CompanyExternalCodeEntity.VacationGroup, vacationGroup.VacationGroupId, vacationGroup.ActorCompanyId);
                if (!externalCodes.IsNullOrEmpty())
                {
                    vacationGroup.ExternalCodes.AddRange(externalCodes.Select(s => s.ExternalCode));
                    vacationGroup.ExternalCodesString = StringUtility.GetSeparatedString(externalCodes.Select(s => s.ExternalCode), Constants.Delimiter, true, false);
                }
            }

            #endregion

            return vacationGroup;
        }

        public VacationGroup GetVacationGroupByName(string name, int actorCompanyId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.EmployeeGroup.NoTracking();
            return GetVacationGroupByName(entities, name, actorCompanyId);
        }

        public VacationGroup GetVacationGroupByName(CompEntities entities, string name, int actorCompanyId)
        {
            return (from eg in entities.VacationGroup
                    where eg.Name == name &&
                    eg.ActorCompanyId == actorCompanyId &&
                    eg.State == (int)SoeEntityState.Active
                    select eg).FirstOrDefault();
        }

        public VacationGroup GetVacationGroupForEmployee(int actorCompanyId, int employeeId, DateTime? date)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            entitiesReadOnly.EmploymentVacationGroup.NoTracking();
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            entities.VacationGroup.NoTracking();
            return GetVacationGroupForEmployee(entities, actorCompanyId, employeeId, date);
        }

        public VacationGroup GetVacationGroupForEmployee(CompEntities entities, int actorCompanyId, int employeeId, DateTime? date)
        {
            Employee employee = EmployeeManager.GetEmployee(entities, employeeId, actorCompanyId, loadEmployment: true);
            return GetVacationGroupForEmployee(entities, employee, date);
        }

        public VacationGroup GetVacationGroupForEmployee(CompEntities entities, Employee employee, DateTime? date)
        {
            // Use today if not specified
            if (!date.HasValue)
                date = DateTime.Today;

            int? employmentId = employee?.GetEmploymentId(date.Value);
            if (!employmentId.HasValue)
                return null;

            EmploymentVacationGroup employmentVacationGroup = (from evg in entities.EmploymentVacationGroup
                                                                .Include("VacationGroup.VacationGroupSE")
                                                               where evg.EmploymentId == employmentId.Value &&
                                                               (!evg.FromDate.HasValue || evg.FromDate.Value <= date) &&
                                                               evg.State == (int)SoeEntityState.Active
                                                               orderby evg.FromDate descending
                                                               select evg).FirstOrDefault();

            return employmentVacationGroup?.VacationGroup;
        }

        public void SetVacationGroupsTypeNames(List<VacationGroup> vacationGroups)
        {
            if (vacationGroups.IsNullOrEmpty())
                return;

            List<GenericType> types = base.GetTermGroupContent(TermGroup.VacationGroupType, skipUnknown: true);
            if (types.IsNullOrEmpty())
            {
                foreach (VacationGroup vacationGroup in vacationGroups)
                {
                    vacationGroup.TypeName = types.FirstOrDefault(vc => vc.Id == vacationGroup.Type)?.Name ?? string.Empty;
                }
            }
        }

        public void LoadVacationGroupExternalCodes(CompEntities entities, List<VacationGroup> vacationGroups, int actorCompanyId)
        {
            if (vacationGroups.IsNullOrEmpty() || vacationGroups.All(eg => eg.ExternalCodesIsLoaded))
                return;

            var allExternalCodes = ActorManager.GetCompanyExternalCodes(entities, TermGroup_CompanyExternalCodeEntity.VacationGroup, actorCompanyId);

            foreach (VacationGroup vacationGroup in vacationGroups)
            {
                vacationGroup.ExternalCodes = new List<string>();

                var externalCodes = allExternalCodes.Where(eg => eg.RecordId == vacationGroup.VacationGroupId).ToList();
                if (!externalCodes.IsNullOrEmpty())
                {
                    vacationGroup.ExternalCodes.AddRange(externalCodes.Select(s => s.ExternalCode));
                    vacationGroup.ExternalCodesString = StringUtility.GetSeparatedString(externalCodes.Select(s => s.ExternalCode), Constants.Delimiter, true, false);
                }

                vacationGroup.ExternalCodesIsLoaded = true;
            }
        }

        public DateTime? GetVacationGroupToDate(Employee employee, DateTime? date)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetVacationGroupToDate(entities, employee, date);
        }

        public DateTime? GetVacationGroupToDate(CompEntities entities, Employee employee, DateTime? date)
        {
            DateTime? fromDate = GetVacationGroupForEmployee(entities, employee, date)?.ActualFromDate(date);
            if (!fromDate.HasValue)
                return null;

            return fromDate.Value.AddYears(1).AddDays(-1);
        }

        public DateTime? GetVacationGroupFromDate(int vacationGroupId)
        {
            DateTime? date = null;

            VacationGroup vacationGroup = GetVacationGroup(vacationGroupId);
            if (vacationGroup != null)
            {
                date = vacationGroup.FromDate;
            }

            return date;
        }

        public ActionResult IsOkToDeleteVacationGroup(CompEntities entities, int vacationGroupId)
        {
            ActionResult result = new ActionResult(true);

            //EmploymentVacationGroup
            if (entities.EmploymentVacationGroup.Any(i => i.VacationGroupId == vacationGroupId && i.State == (int)SoeEntityState.Active))
                result = new ActionResult((int)ActionResultDelete.EmployeeGroupHasEmployments, GetText(11910, "Anställning"));
            //EmployeeCollectiveAgreement
            else if (entities.EmployeeCollectiveAgreement.Any(i => i.VacationGroupId == vacationGroupId && i.State == (int)SoeEntityState.Active))
                result = new ActionResult((int)ActionResultDelete.EmployeeGroupHasEmploymentChanges, GetText(12156, "Avtalsgrupper"));
            //VacationYearEndHead
            else if (entities.VacationYearEndHead.Any(i => i.VacationGroup.Any(v => v.VacationGroupId == vacationGroupId)))
                result = new ActionResult((int)ActionResultDelete.EmployeeGroupHasEmployments, GetText(3207, "Semesterårsskifte"));
            //PayrollGroupVacationGroup
            else if (entities.PayrollGroupVacationGroup.Any(i => i.VacationGroupId == vacationGroupId && i.State == (int)SoeEntityState.Active))
                result = new ActionResult((int)ActionResultDelete.EmployeeGroupHasEmploymentChanges, GetText(9121, "Löneavtal"));

            if (!result.Success)
                result.ErrorMessage = $"{GetText(5664, "Kontrollera att det inte är kopplat till")} {result.ErrorMessage.ToLower()}. ({GetText(5654, "Felkod:")}{result.ErrorNumber})";

            return result;
        }

        public List<DateTime> GetVacationGroupEndDates(List<int> vacationGroupIds, DateTime date)
        {
            List<DateTime> dates = new List<DateTime>();

            foreach (int vacationGroupId in vacationGroupIds)
            {
                DateTime? fromDate = GetVacationGroupFromDate(vacationGroupId);
                if (fromDate.HasValue)
                {
                    // Get last complete vacation year that ended before specified date
                    int yearOffset = (new DateTime(date.Year, fromDate.Value.Month, fromDate.Value.Day).AddDays(-1) < date) ? 0 : 1;
                    DateTime actualDate = new DateTime(date.Year - yearOffset, fromDate.Value.Month, fromDate.Value.Day).AddDays(-1);
                    if (!dates.Contains(actualDate))
                        dates.Add(actualDate);
                }
            }

            return dates;
        }

        public ActionResult SaveVacationGroup(VacationGroupDTO vacationGroupInput, VacationGroupSEDTO vacationGroupSEInput, int actorCompanyId)
        {
            if (vacationGroupInput == null)
                return new ActionResult((int)ActionResultSave.EntityIsNull, "VacationGroup");

            ActionResult result = new ActionResult(true);

            #region Prereq

            int vacationGroupId = vacationGroupInput.VacationGroupId;

            #endregion

            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    entities.Connection.Open();

                    using (TransactionScope transaction = new TransactionScope(ConfigSettings.TRANSACTIONSCOPEOPTION_DEFAULT, ConfigSettings.TRANSACTIONOPTION_DEFAULT))
                    {
                        #region VacationGroup

                        // Get existing record
                        VacationGroup vacationGroup = GetVacationGroup(entities, vacationGroupId);
                        if (vacationGroup == null)
                        {
                            #region Add

                            vacationGroup = new VacationGroup()
                            {
                                ActorCompanyId = actorCompanyId
                            };
                            entities.VacationGroup.AddObject(vacationGroup);
                            SetCreatedProperties(vacationGroup);

                            #endregion
                        }
                        else
                        {
                            #region Update

                            SetModifiedProperties(vacationGroup);

                            #endregion
                        }

                        // Set fields
                        vacationGroup.Type = (int)vacationGroupInput.Type;
                        vacationGroup.Name = vacationGroupInput.Name;
                        vacationGroup.FromDate = vacationGroupInput.FromDate;
                        vacationGroup.VacationDaysPaidByLaw = vacationGroupInput.VacationDaysPaidByLaw;

                        #endregion

                        #region VacationGroupSE

                        // Get existing record
                        VacationGroupSE vacationGroupSE = this.GetVacationGroupSE(vacationGroup);
                        if (vacationGroupSE == null)
                        {
                            #region Add

                            vacationGroupSE = new VacationGroupSE()
                            {
                                VacationGroup = vacationGroup
                            };
                            SetCreatedProperties(vacationGroupSE);

                            #endregion
                        }
                        else
                        {
                            #region Update

                            SetModifiedProperties(vacationGroupSE);

                            #endregion
                        }

                        // Set fields
                        vacationGroupSE.CalculationType = (int)vacationGroupSEInput.CalculationType;
                        vacationGroupSE.ReplacementTimeDeviationCauseId = vacationGroupSEInput.ReplacementTimeDeviationCauseId.ToNullable();
                        vacationGroupSE.UseAdditionalVacationDays = vacationGroupSEInput.UseAdditionalVacationDays;
                        vacationGroupSE.NbrOfAdditionalVacationDays = vacationGroupSEInput.NbrOfAdditionalVacationDays;
                        vacationGroupSE.AdditionalVacationDaysFromAge1 = vacationGroupSEInput.AdditionalVacationDaysFromAge1;
                        vacationGroupSE.AdditionalVacationDays1 = vacationGroupSEInput.AdditionalVacationDays1;
                        vacationGroupSE.AdditionalVacationDaysFromAge2 = vacationGroupSEInput.AdditionalVacationDaysFromAge2;
                        vacationGroupSE.AdditionalVacationDays2 = vacationGroupSEInput.AdditionalVacationDays2;
                        vacationGroupSE.AdditionalVacationDaysFromAge3 = vacationGroupSEInput.AdditionalVacationDaysFromAge3;
                        vacationGroupSE.AdditionalVacationDays3 = vacationGroupSEInput.AdditionalVacationDays3;
                        vacationGroupSE.VacationHandleRule = (int)vacationGroupSEInput.VacationHandleRule;
                        vacationGroupSE.VacationDaysHandleRule = (int)vacationGroupSEInput.VacationDaysHandleRule;
                        vacationGroupSE.VacationDaysGrossUseFiveDaysPerWeek = vacationGroupSEInput.VacationDaysGrossUseFiveDaysPerWeek;
                        vacationGroupSE.RemainingDaysRule = (int)vacationGroupSEInput.RemainingDaysRule;
                        vacationGroupSE.UseMaxRemainingDays = vacationGroupSEInput.UseMaxRemainingDays;
                        vacationGroupSE.MaxRemainingDays = vacationGroupSEInput.MaxRemainingDays;
                        vacationGroupSE.RemainingDaysPayoutMonth = vacationGroupSEInput.RemainingDaysPayoutMonth;
                        vacationGroupSE.EarningYearAmountFromDate = vacationGroupSEInput.EarningYearAmountFromDate;
                        vacationGroupSE.EarningYearVariableAmountFromDate = vacationGroupSEInput.EarningYearVariableAmountFromDate;
                        vacationGroupSE.MonthlySalaryFormulaId = vacationGroupSEInput.MonthlySalaryFormulaId;
                        vacationGroupSE.HourlySalaryFormulaId = vacationGroupSEInput.HourlySalaryFormulaId;
                        vacationGroupSE.VacationDayPercent = vacationGroupSEInput.VacationDayPercent;
                        vacationGroupSE.VacationDayAdditionPercent = vacationGroupSEInput.VacationDayAdditionPercent;
                        vacationGroupSE.VacationVariablePercent = vacationGroupSEInput.VacationVariablePercent;
                        vacationGroupSE.VacationDayPercentPriceTypeId = vacationGroupSEInput.VacationDayPercentPriceTypeId;
                        vacationGroupSE.VacationDayAdditionPercentPriceTypeId = vacationGroupSEInput.VacationDayAdditionPercentPriceTypeId;
                        vacationGroupSE.VacationVariablePercentPriceTypeId = vacationGroupSEInput.VacationVariablePercentPriceTypeId;
                        vacationGroupSE.UseGuaranteeAmount = vacationGroupSEInput.UseGuaranteeAmount;
                        vacationGroupSE.GuaranteeAmountAccordingToHandels = vacationGroupSEInput.GuaranteeAmountAccordingToHandels;
                        vacationGroupSE.GuaranteeAmountMaxNbrOfDaysRule = (int)vacationGroupSEInput.GuaranteeAmountMaxNbrOfDaysRule;
                        vacationGroupSE.GuaranteeAmountEmployedNbrOfYears = vacationGroupSEInput.GuaranteeAmountEmployedNbrOfYears;
                        vacationGroupSE.GuaranteeAmountPerDayPriceTypeId = vacationGroupSEInput.GuaranteeAmountPerDayPriceTypeId;
                        vacationGroupSE.GuaranteeAmountJuvenile = vacationGroupSEInput.GuaranteeAmountJuvenile;
                        vacationGroupSE.GuaranteeAmountJuvenileAgeLimit = vacationGroupSEInput.GuaranteeAmountJuvenileAgeLimit;
                        vacationGroupSE.GuaranteeAmountJuvenilePerDayPriceTypeId = vacationGroupSEInput.GuaranteeAmountJuvenilePerDayPriceTypeId;
                        vacationGroupSE.UseOwnGuaranteeAmount = vacationGroupSEInput.UseOwnGuaranteeAmount;
                        vacationGroupSE.OwnGuaranteeAmount = vacationGroupSEInput.OwnGuaranteeAmount;
                        vacationGroupSE.VacationAbsenceCalculationRule = (int)vacationGroupSEInput.VacationAbsenceCalculationRule;
                        vacationGroupSE.VacationSalaryPayoutRule = (int)vacationGroupSEInput.VacationSalaryPayoutRule;
                        vacationGroupSE.VacationSalaryPayoutDays = vacationGroupSEInput.VacationSalaryPayoutDays;
                        vacationGroupSE.VacationSalaryPayoutMonth = vacationGroupSEInput.VacationSalaryPayoutMonth;
                        vacationGroupSE.VacationVariablePayoutRule = (int)vacationGroupSEInput.VacationVariablePayoutRule;
                        vacationGroupSE.VacationVariablePayoutDays = vacationGroupSEInput.VacationVariablePayoutDays;
                        vacationGroupSE.VacationVariablePayoutMonth = vacationGroupSEInput.VacationVariablePayoutMonth;
                        vacationGroupSE.YearEndRemainingDaysRule = (int)vacationGroupSEInput.YearEndRemainingDaysRule;
                        vacationGroupSE.YearEndOverdueDaysRule = (int)vacationGroupSEInput.YearEndOverdueDaysRule;
                        vacationGroupSE.YearEndVacationVariableRule = (int)vacationGroupSEInput.YearEndVacationVariableRule;
                        vacationGroupSE.ValueDaysDebitAccountId = vacationGroupSEInput.ValueDaysDebitAccountId;
                        vacationGroupSE.ValueDaysCreditAccountId = vacationGroupSEInput.ValueDaysCreditAccountId;
                        vacationGroupSE.ValueDaysAccountInternalOnDebit = vacationGroupSEInput.ValueDaysAccountInternalOnDebit;
                        vacationGroupSE.ValueDaysAccountInternalOnCredit = vacationGroupSEInput.ValueDaysAccountInternalOnCredit;
                        vacationGroupSE.UseEmploymentTaxAcccount = vacationGroupSEInput.UseEmploymentTaxAcccount;
                        vacationGroupSE.EmploymentTaxDebitAccountId = vacationGroupSEInput.EmploymentTaxDebitAccountId;
                        vacationGroupSE.EmploymentTaxCredidAccountId = vacationGroupSEInput.EmploymentTaxCredidAccountId;
                        vacationGroupSE.EmploymentTaxAccountInternalOnDebit = vacationGroupSEInput.EmploymentTaxAccountInternalOnDebit;
                        vacationGroupSE.EmploymentTaxAccountInternalOnCredit = vacationGroupSEInput.EmploymentTaxAccountInternalOnCredit;
                        vacationGroupSE.UseSupplementChargeAccount = vacationGroupSEInput.UseSupplementChargeAccount;
                        vacationGroupSE.SupplementChargeDebitAccountId = vacationGroupSEInput.SupplementChargeDebitAccountId;
                        vacationGroupSE.SupplementChargeCreditAccountId = vacationGroupSEInput.SupplementChargeCreditAccountId;
                        vacationGroupSE.SupplementChargeAccountInternalOnDebit = vacationGroupSEInput.SupplementChargeAccountInternalOnDebit;
                        vacationGroupSE.SupplementChargeAccountInternalOnCredit = vacationGroupSEInput.SupplementChargeAccountInternalOnCredit;
                        vacationGroupSE.UseFillUpToVacationDaysPaidByLawRule = vacationGroupSEInput.UseFillUpToVacationDaysPaidByLawRule;

                        #endregion

                        #region VacationGroupSEDayType

                        if (!vacationGroupSE.VacationGroupSEDayType.Any())
                        {
                            #region new

                            if (vacationGroupSEInput.VacationGroupSEDayTypes != null && vacationGroupSEInput.VacationGroupSEDayTypes.Any(w => w.VacationGroupSEDayTypeId == 0))
                            {
                                foreach (VacationGroupSEDayTypeDTO vacationGroupSEDayType in vacationGroupSEInput.VacationGroupSEDayTypes.Where(w => w.VacationGroupSEDayTypeId == 0))
                                {
                                    VacationGroupSEDayType newVacationGroupSEDayType = new VacationGroupSEDayType()
                                    {
                                        DayTypeId = vacationGroupSEDayType.DayTypeId,
                                        VacationGroupSEId = vacationGroupSEDayType.VacationGroupSEId,
                                        Type = (int)vacationGroupSEDayType.Type,
                                    };
                                    SetCreatedProperties(newVacationGroupSEDayType);
                                    vacationGroupSE.VacationGroupSEDayType.Add(newVacationGroupSEDayType);
                                }
                            }

                            #endregion
                        }
                        else
                        {
                            foreach (VacationGroupSEDayType vacationGroupSEDayType in vacationGroupSE.VacationGroupSEDayType)
                            {
                                if (vacationGroupSEInput.VacationGroupSEDayTypes.Any(f => f.VacationGroupSEDayTypeId == vacationGroupSEDayType.VacationGroupSEDayTypeId))
                                {
                                    #region Update

                                    VacationGroupSEDayTypeDTO newVacationGroupSEDayType = vacationGroupSEInput.VacationGroupSEDayTypes.FirstOrDefault(f => f.VacationGroupSEDayTypeId == vacationGroupSEDayType.VacationGroupSEDayTypeId);
                                    vacationGroupSEDayType.DayTypeId = newVacationGroupSEDayType.DayTypeId;
                                    vacationGroupSEDayType.VacationGroupSEId = newVacationGroupSEDayType.VacationGroupSEId;
                                    vacationGroupSEDayType.Type = (int)newVacationGroupSEDayType.Type;

                                    SetModifiedProperties(vacationGroupSEDayType);

                                    #endregion
                                }
                                else
                                {
                                    #region Delete

                                    ChangeEntityState(vacationGroupSEDayType, SoeEntityState.Deleted);

                                    #endregion
                                }
                            }
                        }

                        #endregion

                        result = SaveChanges(entities, transaction);

                        ActorManager.UpsertExternalNbrs(entities, TermGroup_CompanyExternalCodeEntity.VacationGroup, vacationGroup.VacationGroupId, vacationGroupInput.ExternalCodesString, actorCompanyId);

                        if (result.Success)
                        {
                            // Commit transaction
                            transaction.Complete();

                            vacationGroupId = vacationGroup.VacationGroupId;
                        }
                    }
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result.Exception = ex;
                    result.IntegerValue = 0;
                }
                finally
                {
                    if (result.Success)
                    {
                        // Set success properties
                        result.IntegerValue = vacationGroupId;
                    }
                    else
                        base.LogTransactionFailed(this.ToString(), this.log);

                    entities.Connection.Close();
                }
            }

            return result;
        }

        public ActionResult DeleteVacationGroup(int vacationGroupId)
        {
            ActionResult result;

            using (CompEntities entities = new CompEntities())
            {
                result = IsOkToDeleteVacationGroup(entities, vacationGroupId);
                if (!result.Success)
                    return result;

                VacationGroup vacationGroup = GetVacationGroup(entities, vacationGroupId);
                if (vacationGroup == null)
                    return new ActionResult((int)ActionResultSave.EntityNotFound, GetText(10033, "Semesteravtal hittades inte"));

                ActorManager.UpsertExternalNbrs(entities, TermGroup_CompanyExternalCodeEntity.VacationGroup, vacationGroup.VacationGroupId, "", vacationGroup.ActorCompanyId);

                return ChangeEntityState(entities, vacationGroup, SoeEntityState.Deleted, true);
            }
        }

        #endregion

        #region VacationGroupSE

        public VacationGroupSE GetVacationGroupSE(VacationGroup vacationGroup)
        {
            return vacationGroup?.VacationGroupSE?.FirstOrDefault();
        }

        #endregion

        #region VacationYearEnd

        public List<VacationYearEndHead> GetVacationYearEndsForGrid()
        {
            List<VacationYearEndHead> heads = GetVacationYearEndHeds(base.ActorCompanyId);
            if (heads.IsNullOrEmpty())
                return new List<VacationYearEndHead>();

            List<DataStorageRecord> dataStorageRecords = GeneralManager.GetDataStorageRecords(base.ActorCompanyId, SoeDataStorageRecordType.VacationYearEndHead);

            foreach (VacationYearEndHead head in heads)
            {
                head.ContentTypeName = GetText(head.ContentType, (int)TermGroup.VacationYearEndHeadContentType);
                head.DataStorageId = dataStorageRecords?.FirstOrDefault(i => i.RecordId == head.VacationYearEndHeadId)?.DataStorageId;
                head.EmployeesFailed = GetEmployeeNames(head.GetFailedRows());
                head.Content = head.ContentType == (int)TermGroup_VacationYearEndHeadContentType.Employee ? GetEmployeeNames(head.GetSucceededRows()) : head.VacationGroups;
            }

            string GetEmployeeNames(List<VacationYearEndRow> rows) => EmployeeManager.GetAllEmployeesByIds(base.ActorCompanyId, rows.Select(i => i.EmployeeId)).Select(e => e.EmployeeNrAndName).ToCommaSeparated();

            return heads;
        }

        public List<VacationYearEndHead> GetVacationYearEndHeds(int actorCompanyId)
        {
            using var entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            return (from v in entitiesReadOnly.VacationYearEndHead
                        .Include("VacationYearEndRow")
                    where v.ActorCompanyId == actorCompanyId &&
                    v.Type == (int)SoeVacationYearEndType.VacationYearEnd &&
                    v.State == (int)SoeEntityState.Active
                    orderby v.Created descending
                    select v).ToList();
        }

        public VacationYearEndHead GetVacationYearEnd(CompEntities entities, int vacationYearEndHeadId, bool loadRows = false)
        {
            IQueryable<VacationYearEndHead> query = entities.VacationYearEndHead;
            if (loadRows)
                query = query.Include("VacationYearEndRow");

            return query.FirstOrDefault(r => r.VacationYearEndHeadId == vacationYearEndHeadId);
        }

        public VacationYearEndResultDTO GetVacationYearEndResult(int vacationYearEndHeadId)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            VacationYearEndHead head = GetVacationYearEnd(entitiesReadOnly, vacationYearEndHeadId, loadRows: true);
            string[] vacationGroupNames = head.VacationGroups.Split(',');
            string vacationGroupName = vacationGroupNames.Length == 1 ? vacationGroupNames[0] : null;

            return new VacationYearEndResultDTO()
            {
                Result = new ActionResult(true),
                EmployeeResults = head.VacationYearEndRow
                    .Where(row => row.State == (int)SoeEntityState.Active)
                    .Select(row => new VacationYearEndEmployeeResultDTO()
                    {
                        EmployeeId = row.EmployeeId,
                        EmployeeNrAndName = EmployeeManager.GetEmployee(row.EmployeeId, base.ActorCompanyId, loadContactPerson: true)?.EmployeeNrAndName,
                        Message = row.Message,
                        Status = (TermGroup_VacationYearEndStatus)row.Status,
                        StatusName = GetText(row.Status, (int)TermGroup.VacationYearEndResult),
                        VacationGroupName = vacationGroupName, //if more than one VacationGroups is in same VacationYearEnd there is no simple way of showing the Employees corrent VacationGroup. Then that value must be saved when the VacationYearEndRow is created
                    })
                    .Sort()
            };
        }

        #endregion

        #region VacationYearEndRow

        public List<VacationYearEndRow> GetVacationYearEndRows(CompEntities entities, int actorCompanyId, int timePeriodId, SoeVacationYearEndType type, List<int> employeeIds = null)
        {
            var query = (from v in entities.VacationYearEndRow
                         where timePeriodId == v.TimePeriodId &&
                         v.State == (int)SoeEntityState.Active &&
                         v.VacationYearEndHead.ActorCompanyId == actorCompanyId &&
                         v.VacationYearEndHead.Type == (int)type
                         select v);

            if (!employeeIds.IsNullOrEmpty())
                query = query.Where(v => employeeIds.Contains(v.EmployeeId));

            return query.ToList();
        }

        public VacationYearEndRow GetVacationYearEndRow(CompEntities entities, int employeeId, int timePeriodId, SoeVacationYearEndType type)
        {
            return (from v in entities.VacationYearEndRow
                    where v.EmployeeId == employeeId &&
                    timePeriodId == v.TimePeriodId &&
                    v.State == (int)SoeEntityState.Active &&
                    v.VacationYearEndHead.Type == (int)type
                    select v).FirstOrDefault();
        }

        public SoeEmploymentFinalSalaryStatus? GetFinalSalaryStatus(Employee employee, TimePeriodDTO timePeriod, List<VacationYearEndRow> finalSalaries)
        {
            if (HasAppliedFinalSalaryInPeriod(employee, timePeriod, finalSalaries))
                return SoeEmploymentFinalSalaryStatus.AppliedFinalSalary;
            else if (DoApplyFinalSalaryInPeriod(employee, timePeriod))
                return SoeEmploymentFinalSalaryStatus.ApplyFinalSalary;
            return null;
        }

        public bool HasAppliedFinalSalaryInPeriod(Employee employee, TimePeriodDTO timePeriod, List<VacationYearEndRow> finalSalaries)
        {
            if (employee == null || timePeriod == null)
                return false;

            return finalSalaries?.Any(v => v.TimePeriodId.HasValue && v.TimePeriodId.Value == timePeriod.TimePeriodId && v.EmployeeId == employee.EmployeeId) ?? false;
        }

        public bool DoApplyFinalSalaryInPeriod(Employee employee, TimePeriodDTO timePeriod)
        {
            if (employee == null || timePeriod == null)
                return false;

            DateTime? applyFinalSalaryEndDate = employee.GetApplyFinalSalaryEndDate();
            return applyFinalSalaryEndDate.HasValue && applyFinalSalaryEndDate.Value <= timePeriod.PayrollStopDate;
        }

        #endregion

        #region Vacation Calculation

        public List<EmployeeCalculateVacationResultHead> GetEmployeeCalculateVacationResultHeads(CompEntities entities, int actorCompanyId, DateTime date)
        {
            return entities.EmployeeCalculateVacationResultHead
                .Include("EmployeeCalculateVacationResult")
                .Where(w => w.ActorCompanyId == actorCompanyId && w.State == (int)SoeEntityState.Active && w.Date == date)
                .ToList();
        }

        public List<EmployeeCalculateVacationResultHead> GetEmployeeCalculateVacationResultHeads(CompEntities entities, int actorCompanyId)
        {
            return entities.EmployeeCalculateVacationResultHead
                .Include("EmployeeCalculateVacationResult")
                .Where(w => w.ActorCompanyId == actorCompanyId && w.State == (int)SoeEntityState.Active)
                .ToList();
        }

        public List<EmployeeCalculateVacationResult> GetEmployeeCalculateVacationResults(int employeeCalculateVacationResultHeadId, int employeeId, bool onlyActive = true)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetEmployeeCalculateVacationResults(entities, employeeCalculateVacationResultHeadId, employeeId, onlyActive);
        }

        public List<EmployeeCalculateVacationResult> GetEmployeeCalculateVacationResults(CompEntities entities, int employeeCalculateVacationResultHeadId, int employeeId, bool onlyActive = true)
        {
            int actorCompanyId = base.ActorCompanyId;

            var query = entities.EmployeeCalculateVacationResult
                .Include("EmployeeCalculateVacationResultHead")
                .Where(e =>
                    e.EmployeeCalculateVacationResultHeadId == employeeCalculateVacationResultHeadId &&
                    e.EmployeeId == employeeId && e.Employee.ActorCompanyId == actorCompanyId
                    );
            if (onlyActive)
                query = query.Where(x => x.State == (int)SoeEntityState.Active);

            return query.ToList();
        }

        public List<EmployeeCalculateVacationResult> GetEmployeeCalculateVacationResults(CompEntities entities, int employeeId, List<EmployeeCalculateVacationResultHead> employeeCalculateVacationResultHeads)
        {
            if (entities.EmployeeCalculateVacationResult.Any(a => a.EmployeeId == employeeId && a.State == (int)SoeEntityState.Active))
            {
                foreach (var vacationResultHead in employeeCalculateVacationResultHeads)
                {
                    var results = entities.EmployeeCalculateVacationResult
                        .Where(r =>
                            r.EmployeeId == employeeId &&
                            r.EmployeeCalculateVacationResultHeadId == vacationResultHead.EmployeeCalculateVacationResultHeadId &&
                            r.State == (int)SoeEntityState.Active)
                        .ToList();

                    if (!results.IsNullOrEmpty())
                        return results;
                }
            }

            return new List<EmployeeCalculateVacationResult>();
        }

        public CalculateVacationResultContainerDTO CreateVacationCalculationContainer(EmployeeCalculateVacationResultHead employeeCalculateVacationResultHead, List<int> employeeIds)
        {
            CalculateVacationResultContainerDTO calculateVacationResultContainerDTO = new CalculateVacationResultContainerDTO();

            foreach (var result in employeeCalculateVacationResultHead.EmployeeCalculateVacationResult)
            {
                if (!employeeIds.Contains(result.EmployeeId))
                    continue;

                calculateVacationResultContainerDTO.FormulaResult.Add(new CalculateVacationResultDTO()
                {
                    FormulaPlain = result.FormulaPlain,
                    Success = result.Success,
                    EmployeeId = result.EmployeeId,
                    Error = result.Error,
                    FormulaExtracted = result.FormulaExtracted,
                    FormulaNames = string.IsNullOrEmpty(result.FormulaNames) ? "" : result.FormulaNames.Trim(),
                    FormulaOrigin = string.IsNullOrEmpty(result.FormulaOrigin) ? "" : result.FormulaOrigin.Trim(),
                    Name = string.IsNullOrEmpty(result.Name) ? "" : result.Name.Trim(),
                    Value = result.Value ?? 0,
                });
            }

            return calculateVacationResultContainerDTO;
        }

        public List<EmployeeCalculateVacationResultFlattenedDTO> GetEmployeeCalculateVacationHeadsForGrid(int actorCompanyId)
        {
            var dtos = new List<EmployeeCalculateVacationResultFlattenedDTO>();

            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            var vacationCalculations = entitiesReadOnly.EmployeeCalculateVacationResultHead
                .Include("EmployeeCalculateVacationResult")
                .Where(e =>
                    e.ActorCompanyId == actorCompanyId &&
                    e.State == (int)SoeEntityState.Active
                    )
                .ToList();

            if (!vacationCalculations.IsNullOrEmpty())
            {
                var employees = EmployeeManager.GetAllEmployees(actorCompanyId);

                foreach (var vacationCalculation in vacationCalculations)
                {
                    foreach (var employeeResults in vacationCalculation.EmployeeCalculateVacationResult.Where(x => x.State == (int)SoeEntityState.Active).GroupBy(x => x.EmployeeId))
                    {
                        Employee employee = employees.FirstOrDefault(x => x.EmployeeId == employeeResults.Key);

                        var dto = new EmployeeCalculateVacationResultFlattenedDTO()
                        {
                            EmployeeCalculateVacationResultHeadId = vacationCalculation.EmployeeCalculateVacationResultHeadId,
                            ActorCompanyId = vacationCalculation.ActorCompanyId,
                            Date = vacationCalculation.Date,
                            DateStr = vacationCalculation.Date.ToShortDateString(),
                            Created = vacationCalculation.Created,

                            EmployeeId = employee?.EmployeeId ?? 0,
                            EmployeeNr = employee?.EmployeeNr,
                            EmployeeName = employee?.Name,
                            EmployeeNrAndName = employee?.EmployeeNrAndName,

                            VBDValue = employeeResults.FirstOrDefault(x => x.Name.Trim().Equals("VBD"))?.Value ?? 0,
                            VIDValue = employeeResults.FirstOrDefault(x => x.Name.Trim().Equals("VID"))?.Value ?? 0,
                            VSDValue = employeeResults.FirstOrDefault(x => x.Name.Trim().Equals("VSD"))?.Value ?? 0,
                            VBSTRValue = employeeResults.FirstOrDefault(x => x.Name.Trim().Equals("VBSTR"))?.Value ?? 0,
                            BSTRAValue = employeeResults.FirstOrDefault(x => x.Name.Trim().Equals("VSTRA"))?.Value ?? 0,
                            VSSTRValue = employeeResults.FirstOrDefault(x => x.Name.Trim().Equals("VSSTR"))?.Value ?? 0,
                            SSTRAValue = employeeResults.FirstOrDefault(x => x.Name.Trim().Equals("SSTRA"))?.Value ?? 0,
                            VISTRValue = employeeResults.FirstOrDefault(x => x.Name.Trim().Equals("VISTR"))?.Value ?? 0,
                            VFDValue = employeeResults.FirstOrDefault(x => x.Name.Trim().Equals("VFD"))?.Value ?? 0,
                        };
                        dto.TotVSTRValue = dto.VBSTRValue + dto.VISTRValue + dto.VSSTRValue;
                        dto.TotValue = dto.VBDValue + dto.VIDValue + dto.VSDValue + dto.VFDValue;
                        dtos.Add(dto);
                    }
                }
            }

            return dtos;
        }

        public PayrollVoucherHeadDTO GetEmployeeCalculateVacationResultHeadVoucher(CompEntities entities, int actorCompanyId, DateTime date, List<Employee> employees, bool skipQuantity, bool merge = true)
        {
            if (employees.IsNullOrEmpty())
                return new PayrollVoucherHeadDTO();

            PayrollVoucherHeadDTO voucherHeadDTO = new PayrollVoucherHeadDTO()
            {
                Date = date
            };

            var heads = GetEmployeeCalculateVacationResultHeads(entities, actorCompanyId, date);
            var accounts = entities.Account.Where(w => w.ActorCompanyId == actorCompanyId).ToList();
            var accountDTOs = AccountManager.GetAccountsByCompany(actorCompanyId, loadAccount: true).ToDTOs();
            var accountInternalsOnCompany = AccountManager.GetAccountInternals(actorCompanyId, null, false).ToDTOs();
            var accountDims = base.GetAccountDimsFromCache(entities, CacheConfig.Company(actorCompanyId));
            var validNames = new List<string> { "VID", "VBD", "VSD", "VFD" };
            var vacationGroups = GetVacationGroups(entities, actorCompanyId);
            var payrollGroupsAccountStds = base.GetPayrollGroupAccountStdFromCache(entities, actorCompanyId);
            int valueDaysDebitAccountId = SettingManager.GetIntSetting(SettingMainType.Company, (int)CompanySettingType.VacationValueDaysDebitAccountId, 0, actorCompanyId, 0);
            int valueDaysCreditAccountId = SettingManager.GetIntSetting(SettingMainType.Company, (int)CompanySettingType.VacationValueDaysCreditAccountId, 0, actorCompanyId, 0);

            if (heads != null)
            {
                List<int> currentHeadIds = heads.Select(w => w.EmployeeCalculateVacationResultHeadId).ToList();
                var allHeads = GetEmployeeCalculateVacationResultHeads(entities, actorCompanyId);
                allHeads = allHeads.Where(w => !currentHeadIds.Contains(w.EmployeeCalculateVacationResultHeadId)).ToList();
                List<PayrollVoucherRowDTO> dtos = new List<PayrollVoucherRowDTO>();
                var employeeIds = heads.SelectMany(a => a.EmployeeCalculateVacationResult.Select(s => s.EmployeeId).Distinct()).Distinct().ToList();

                List<AccountDim> accountDimInternals = AccountManager.GetAccountDimsByCompany(entities, actorCompanyId, false, true, true).OrderBy(a => a.AccountDimNr).ToList();

                foreach (var employeeId in employeeIds)
                {
                    Employee employee = employees.FirstOrDefault(f => f.EmployeeId == employeeId);

                    if (employee == null)
                        continue;

                    DateTime selectDate = date;

                    var employment = employee.GetEmployment(date);

                    if (employment == null)
                    {
                        employment = employee.GetPrevEmployment(date);

                        if (employment == null || !employment.DateTo.HasValue)
                            continue;

                        selectDate = employment.DateTo.Value;
                    }

                    var vacationGroupSEInput = employee.GetVacationGroup(selectDate, vacationGroups);

                    if (vacationGroupSEInput == null)
                        continue;

                    var group = vacationGroupSEInput.VacationGroupSE.FirstOrDefault();

                    if (group == null)
                        continue;

                    int employeeValueDaysDebitAccountId = group.ValueDaysDebitAccountId ?? valueDaysDebitAccountId;
                    int employeeValueDaysCreditAccountId = group.ValueDaysCreditAccountId ?? valueDaysCreditAccountId;
                    bool employeeValueDaysAccountInternalOnDebit = group.ValueDaysAccountInternalOnDebit;
                    bool employeeValueDaysAccountInternalOnCredit = group.ValueDaysAccountInternalOnCredit;
                    bool employeeUseEmploymentTaxAcccount = group.UseEmploymentTaxAcccount;
                    int employeeEmploymentTaxDebitAccountId = group.EmploymentTaxDebitAccountId ?? 0;
                    int employeeEmploymentTaxCreditAccountId = group.EmploymentTaxCredidAccountId ?? 0;
                    bool employeeEmploymentTaxAccountInternalOnDebit = group.EmploymentTaxAccountInternalOnDebit;
                    bool employeeEmploymentTaxAccountInternalOnCredit = group.EmploymentTaxAccountInternalOnCredit;
                    bool employeeUseSupplementChargeAccount = group.UseSupplementChargeAccount;
                    int employeeSupplementChargeDebitAccountId = group.SupplementChargeDebitAccountId ?? 0;
                    int employeeSupplementChargeCreditAccountId = group.SupplementChargeCreditAccountId ?? 0;
                    bool employeeSupplementChargeAccountInternalOnDebit = group.SupplementChargeAccountInternalOnDebit;
                    bool employeeSupplementChargeAccountInternalOnCredit = group.SupplementChargeAccountInternalOnCredit;

                    var employeeHeads = heads.Where(w => w.EmployeeCalculateVacationResult.Any(a => a.EmployeeId == employeeId && a.State == (int)SoeEntityState.Active)).ToList();
                    var head = employeeHeads.OrderByDescending(o => o.Created).FirstOrDefault();

                    if (head == null)
                        continue;

                    decimal supplementCharge = 0;
                    if (employeeUseSupplementChargeAccount)
                        supplementCharge = decimal.Divide(CalculateSupplementChargeSE(entities, actorCompanyId, date, 10000, employee), 10000);

                    decimal employmentTax = 0;
                    if (employeeUseEmploymentTaxAcccount)
                        employmentTax = decimal.Divide(CalculateEmploymentTaxSimple(entities, actorCompanyId, date, 10000, employee), 10000);

                    var employeeResults = head.EmployeeCalculateVacationResult.Where(w => w.EmployeeId == employeeId).ToList();
                    var previousHeadOnEmployee = allHeads.Where(w => w.EmployeeCalculateVacationResultHeadId != head.EmployeeCalculateVacationResultHeadId && w.EmployeeCalculateVacationResult.Any(a => a.State == (int)SoeEntityState.Active && a.EmployeeId == employeeId)).OrderByDescending(o => o.Date).FirstOrDefault();
                    List<AccountInternalDTO> accountInternals = new List<AccountInternalDTO>();

                    if (employeeValueDaysAccountInternalOnDebit || employeeValueDaysAccountInternalOnCredit || employeeEmploymentTaxAccountInternalOnDebit || employeeEmploymentTaxAccountInternalOnCredit || employeeSupplementChargeAccountInternalOnDebit || employeeSupplementChargeAccountInternalOnCredit)
                    {
                        var prioDTO = AccountManager.GetPayrollProductAccount(ProductAccountType.Purchase, actorCompanyId, employee, 0, 0, 0, true, head.Date);
                        if (prioDTO != null && prioDTO.AccountInternals != null)
                            accountInternals = prioDTO.AccountInternals;
                    }

                    foreach (var item in employeeResults.Where(w => w.Value.HasValue))
                    {
                        item.Name = item.Name.Trim();
                        if (!validNames.Contains(item.Name))
                            continue;

                        PayrollVoucherRowDTO rowDebitDTO = new PayrollVoucherRowDTO();
                        string name = item.Name;
                        decimal amount = item.Value.Value;
                        string desc = $"{name} ";

                        if (previousHeadOnEmployee != null)
                        {
                            var prevItem = previousHeadOnEmployee.EmployeeCalculateVacationResult.FirstOrDefault(f => f.State == (int)SoeEntityState.Active && f.EmployeeId == employeeId && f.Name.Trim() == name);

                            if (prevItem != null)
                            {
                                decimal value = prevItem.Value ?? 0;
                                desc = desc + $"{amount} - {value} ";
                                amount = amount - value;
                                desc = desc + $"= {amount}";
                            }
                            else
                            {
                                desc = desc + $"{amount}";
                            }
                        }
                        else
                        {
                            desc = desc + $"{amount}";
                        }

                        if (amount == 0)
                            continue;

                        rowDebitDTO.EmployeeCalculateVacationResultHeadId = head.EmployeeCalculateVacationResultHeadId;
                        rowDebitDTO.EmployeeCalculateVacationResultId = 0;
                        rowDebitDTO.PreviousEmployeeCalculateVacationResultHeadId = previousHeadOnEmployee?.EmployeeCalculateVacationResult != null && previousHeadOnEmployee.EmployeeCalculateVacationResult.Any(f => f.State == (int)SoeEntityState.Active && f.EmployeeId == employeeId && f.Name.Trim() == name) ? previousHeadOnEmployee.EmployeeCalculateVacationResultHeadId : 0;
                        rowDebitDTO.PreviousEmployeeCalculateVacationResultId = 0;
                        rowDebitDTO.TimePayrollScheduleTransactionId = 0;
                        rowDebitDTO.Amount = amount;
                        rowDebitDTO.AmountEntCurrency = amount;
                        rowDebitDTO.Quantity = 0;
                        rowDebitDTO.Text = desc;
                        rowDebitDTO.SkipQuantity = skipQuantity;

                        Account account = accounts.FirstOrDefault(w => w.AccountId == employeeValueDaysDebitAccountId);
                        Account creditAccount = accounts.FirstOrDefault(w => w.AccountId == employeeValueDaysCreditAccountId);

                        if (account == null || creditAccount == null)
                            return new PayrollVoucherHeadDTO();

                        rowDebitDTO.Dim1Id = account.AccountId;
                        rowDebitDTO.Dim1Name = account.Name;
                        rowDebitDTO.Dim1Nr = account.AccountNr;

                        rowDebitDTO.PayrollVoucherRowOriginDTOs.Add(new PayrollVoucherRowOriginDTO()
                        {
                            EmployeeCalculateVacationResultHeadId = head.EmployeeCalculateVacationResultHeadId,
                            PreviousEmployeeCalculateVacationResultHeadId = rowDebitDTO.PreviousEmployeeCalculateVacationResultHeadId,
                            Amount = rowDebitDTO.Amount,
                            Code = item.Name,
                            DateTime = head.Date,
                            Quantity = rowDebitDTO.Quantity.GetValueOrDefault(),
                        });

                        if (employeeValueDaysAccountInternalOnDebit)
                            ApplyAccountInternalOnPayrollVoucherRowDTO(rowDebitDTO, accountInternals, accountDimInternals);
                        dtos.Add(rowDebitDTO);
                        dtos.Add(ClonePayrollVoucherRow(rowDebitDTO, creditAccount, head.Date, decimal.Multiply(-1, rowDebitDTO.Amount), employeeValueDaysAccountInternalOnCredit, employee.EmployeeNr, item.Name, accountInternals, accountDimInternals));

                        #region EmploymentTax

                        if (employeeUseEmploymentTaxAcccount && employmentTax > 0)
                        {
                            Account employmentTaxDebitAccount = accounts.FirstOrDefault(w => w.AccountId == employeeEmploymentTaxDebitAccountId);
                            Account employmentTaxCreditAccount = accounts.FirstOrDefault(w => w.AccountId == employeeEmploymentTaxCreditAccountId);

                            if (employmentTaxDebitAccount != null && employmentTaxCreditAccount != null)
                            {
                                var employmentTaxDebit = ClonePayrollVoucherRow(rowDebitDTO, employmentTaxDebitAccount, head.Date, decimal.Multiply(employmentTax, rowDebitDTO.Amount), employeeEmploymentTaxAccountInternalOnDebit, employee.EmployeeNr, "Arbetstgivaravgift " + item.Name, accountInternals, accountDimInternals);
                                dtos.Add(employmentTaxDebit);
                                dtos.Add(ClonePayrollVoucherRow(employmentTaxDebit, employmentTaxCreditAccount, head.Date, decimal.Multiply(-1, employmentTaxDebit.Amount), employeeValueDaysAccountInternalOnCredit, employee.EmployeeNr, "Arbetstgivaravgift " + item.Name, accountInternals, accountDimInternals));
                            }
                        }

                        #endregion

                        #region SupplementCharge

                        if (employeeUseSupplementChargeAccount && supplementCharge > 0)
                        {
                            Account supplementChargeDebitAccount = accounts.FirstOrDefault(w => w.AccountId == employeeSupplementChargeDebitAccountId);
                            Account supplementChargeCreditAccount = accounts.FirstOrDefault(w => w.AccountId == employeeSupplementChargeCreditAccountId);

                            if (supplementChargeDebitAccount != null && supplementChargeCreditAccount != null)
                            {
                                var supplementChargeDebit = ClonePayrollVoucherRow(rowDebitDTO, supplementChargeDebitAccount, head.Date, decimal.Multiply(supplementCharge, rowDebitDTO.Amount), employeeSupplementChargeAccountInternalOnDebit, employee.EmployeeNr, "Påslag " + item.Name, accountInternals, accountDimInternals);
                                dtos.Add(supplementChargeDebit);
                                dtos.Add(ClonePayrollVoucherRow(supplementChargeDebit, supplementChargeCreditAccount, head.Date, decimal.Multiply(-1, supplementChargeDebit.Amount), employeeValueDaysAccountInternalOnCredit, employee.EmployeeNr, "Påslag " + item.Name, accountInternals, accountDimInternals));
                            }
                        }

                        #endregion
                    }

                }

                voucherHeadDTO.Rows = dtos;
                VoucherManager.ApplyAutomaticAccountDistributionOnPayrollVoucherHead(entities, actorCompanyId, voucherHeadDTO, accountDTOs, accountDims, accountInternalsOnCompany);

                foreach (var rowDTO in voucherHeadDTO.Rows)
                {
                    int dimCounter = 2;

                    if (rowDTO.AccountInternals.Any())
                    {
                        foreach (var accountDim in accountDimInternals)
                        {
                            var accountInternal = rowDTO.AccountInternals.FirstOrDefault(i => i.AccountDimId == accountDim.AccountDimId);
                            if (accountInternal != null)
                            {
                                #region Dim 2

                                if (dimCounter == 2)
                                {
                                    rowDTO.Dim2Id = accountInternal.AccountId;
                                    rowDTO.Dim2Name = accountInternal.Name;
                                    rowDTO.Dim2Nr = accountInternal.AccountNr;
                                    rowDTO.Dim2SIENr = accountDim.SysSieDimNr != null ? (int)accountDim.SysSieDimNr : 0;
                                }

                                #endregion

                                #region Dim 3

                                if (dimCounter == 3)
                                {
                                    rowDTO.Dim3Id = accountInternal.AccountId;
                                    rowDTO.Dim3Name = accountInternal.Name;
                                    rowDTO.Dim3Nr = accountInternal.AccountNr;
                                    rowDTO.Dim3SIENr = accountDim.SysSieDimNr != null ? (int)accountDim.SysSieDimNr : 0;
                                }

                                #endregion

                                #region Dim 4

                                if (dimCounter == 4)
                                {
                                    rowDTO.Dim4Id = accountInternal.AccountId;
                                    rowDTO.Dim4Name = accountInternal.Name;
                                    rowDTO.Dim4Nr = accountInternal.AccountNr;
                                    rowDTO.Dim4SIENr = accountDim.SysSieDimNr != null ? (int)accountDim.SysSieDimNr : 0;
                                }

                                #endregion

                                #region Dim 5

                                if (dimCounter == 5)
                                {
                                    rowDTO.Dim5Id = accountInternal.AccountId;
                                    rowDTO.Dim5Name = accountInternal.Name;
                                    rowDTO.Dim5Nr = accountInternal.AccountNr;
                                    rowDTO.Dim5SIENr = accountDim.SysSieDimNr != null ? (int)accountDim.SysSieDimNr : 0;
                                }

                                #endregion

                                #region Dim 6

                                if (dimCounter == 6)
                                {
                                    rowDTO.Dim6Id = accountInternal.AccountId;
                                    rowDTO.Dim6Name = accountInternal.Name;
                                    rowDTO.Dim6Nr = accountInternal.AccountNr;
                                    rowDTO.Dim6SIENr = accountDim.SysSieDimNr != null ? (int)accountDim.SysSieDimNr : 0;
                                }

                                #endregion
                            }

                            dimCounter++;
                        }
                    }
                }

                if (merge && dtos.Any())
                {
                    List<PayrollVoucherRowDTO> mergedDtos = new List<PayrollVoucherRowDTO>();
                    foreach (var group in voucherHeadDTO.Rows.GroupBy(r => r.accountString))
                    {
                        PayrollVoucherRowDTO first = group.FirstOrDefault();
                        if (first == null)
                            continue;

                        mergedDtos.Add(new PayrollVoucherRowDTO
                        {
                            TimePayrollTransactionId = 0,
                            Amount = group.Sum(r => r.Amount),
                            AmountEntCurrency = group.Sum(r => r.AmountEntCurrency),
                            Quantity = skipQuantity ? 0 : group.Sum(r => r.Quantity),
                            accountString = group.FirstOrDefault()?.accountString,
                            PayrollVoucherRowOriginDTOs = group.SelectMany(s => s.PayrollVoucherRowOriginDTOs).ToList(),
                            SkipQuantity = skipQuantity,
                            AccountDistributionName = group.Any(a => !string.IsNullOrEmpty(a.AccountDistributionName)) ? string.Join(",", group.Where(w => !string.IsNullOrEmpty(w.AccountDistributionName)).Select(s => s.AccountDistributionName).Distinct().ToList()) : "",
                            Dim1Id = first.Dim1Id,
                            Dim1Name = first.Dim1Name,
                            Dim1Nr = first.Dim1Nr,
                            Dim2Id = first.Dim2Id,
                            Dim2Name = first.Dim2Name,
                            Dim2Nr = first.Dim2Nr,
                            Dim2SIENr = first.Dim2SIENr,
                            Dim3Id = first.Dim3Id,
                            Dim3Name = first.Dim3Name,
                            Dim3Nr = first.Dim3Nr,
                            Dim3SIENr = first.Dim3SIENr,
                            Dim4Id = first.Dim4Id,
                            Dim4Name = first.Dim4Name,
                            Dim4Nr = first.Dim4Nr,
                            Dim4SIENr = first.Dim4SIENr,
                            Dim5Id = first.Dim5Id,
                            Dim5Name = first.Dim5Name,
                            Dim5Nr = first.Dim5Nr,
                            Dim5SIENr = first.Dim5SIENr,
                            Dim6Id = first.Dim6Id,
                            Dim6Name = first.Dim6Name,
                            Dim6Nr = first.Dim6Nr,
                            Dim6SIENr = first.Dim6SIENr,
                        });
                    }

                    mergedDtos = mergedDtos.Where(i => i != null).OrderBy(m => m.accountString).ToList();

                    voucherHeadDTO.Text = GetText(11880, "Verifikat skapat från Lön. Totalt antal transaktioner i underlaget: ") + mergedDtos.Count;
                    voucherHeadDTO.VoucherNr = 1;
                    voucherHeadDTO.Rows = new List<PayrollVoucherRowDTO>();
                    voucherHeadDTO.Rows.AddRange(mergedDtos);
                }
                else
                {
                    dtos = dtos.Where(m => m != null).OrderBy(m => m.accountString).ToList();

                    voucherHeadDTO.Text = GetText(11880, "Verifikat skapat från Lön. Totalt antal transaktioner i underlaget: ") + dtos.ToString();
                    voucherHeadDTO.VoucherNr = 1;
                    voucherHeadDTO.Rows = new List<PayrollVoucherRowDTO>();
                    voucherHeadDTO.Rows.AddRange(dtos);
                }
            }

            voucherHeadDTO.Rows.ForEach(f => f.Amount = decimal.Round(f.Amount, 2));
            return voucherHeadDTO;
        }

        private PayrollVoucherRowDTO ClonePayrollVoucherRow(PayrollVoucherRowDTO payrollVoucherRowDTO, Account account, DateTime date, decimal amount, bool applyInternalAccounting, string employeeNr, string code, List<AccountInternalDTO> accountInternals, List<AccountDim> accountDimInternals)
        {
            var newRow = payrollVoucherRowDTO.CloneDTO();
            newRow.Dim1Id = account.AccountId;
            newRow.Dim1Name = account.Name;
            newRow.Dim1Nr = account.AccountNr;
            newRow.Dim2Id = 0;
            newRow.Dim3Id = 0;
            newRow.Dim4Id = 0;
            newRow.Dim5Id = 0;
            newRow.Dim6Id = 0;
            newRow.Dim2Nr = "";
            newRow.Dim3Nr = "";
            newRow.Dim4Nr = "";
            newRow.Dim5Nr = "";
            newRow.Dim6Nr = "";
            newRow.Dim2Name = "";
            newRow.Dim3Name = "";
            newRow.Dim4Name = "";
            newRow.Dim5Name = "";
            newRow.Dim6Name = "";
            newRow.Amount = amount;
            newRow.AmountEntCurrency = amount;
            newRow.PayrollVoucherRowOriginDTOs = new List<PayrollVoucherRowOriginDTO>();

            newRow.accountString = newRow.Dim1Nr + ";" + newRow.Dim2Nr + ";" + newRow.Dim3Nr + ";" + newRow.Dim4Nr + ";" + newRow.Dim5Nr + ";" + newRow.Dim6Nr;
            newRow.PayrollVoucherRowOriginDTOs.Add(new PayrollVoucherRowOriginDTO()
            {
                EmployeeCalculateVacationResultHeadId = newRow.EmployeeCalculateVacationResultHeadId,
                PreviousEmployeeCalculateVacationResultHeadId = newRow.PreviousEmployeeCalculateVacationResultHeadId,
                EmployeeNr = employeeNr,
                Amount = newRow.Amount,
                Code = code,
                DateTime = newRow.Date ?? CalendarUtility.DATETIME_DEFAULT,
                Quantity = newRow.Quantity.GetValueOrDefault(),
            });

            if (applyInternalAccounting)
                ApplyAccountInternalOnPayrollVoucherRowDTO(newRow, accountInternals, accountDimInternals);

            return newRow;

        }

        private void ApplyAccountInternalOnPayrollVoucherRowDTO(PayrollVoucherRowDTO row, List<AccountInternalDTO> accountInternals, List<AccountDim> accountDimInternals)
        {
            int dimCounter = 2;
            if (accountInternals.Any())
            {
                row.AccountInternals = accountInternals;

                foreach (var accountDim in accountDimInternals)
                {
                    var accountInternal = accountInternals.FirstOrDefault(i => i.AccountDimId == accountDim.AccountDimId);
                    if (accountInternal != null)
                    {
                        #region Dim 2

                        if (dimCounter == 2)
                        {
                            row.Dim2Id = accountInternal.AccountId;
                            row.Dim2Name = accountInternal.Name;
                            row.Dim2Nr = accountInternal.AccountNr;
                            row.Dim2SIENr = accountDim.SysSieDimNr != null ? (int)accountDim.SysSieDimNr : 0;
                        }

                        #endregion

                        #region Dim 3

                        if (dimCounter == 3)
                        {
                            row.Dim3Id = accountInternal.AccountId;
                            row.Dim3Name = accountInternal.Name;
                            row.Dim3Nr = accountInternal.AccountNr;
                            row.Dim3SIENr = accountDim.SysSieDimNr != null ? (int)accountDim.SysSieDimNr : 0;
                        }

                        #endregion

                        #region Dim 4

                        if (dimCounter == 4)
                        {
                            row.Dim4Id = accountInternal.AccountId;
                            row.Dim4Name = accountInternal.Name;
                            row.Dim4Nr = accountInternal.AccountNr;
                            row.Dim4SIENr = accountDim.SysSieDimNr != null ? (int)accountDim.SysSieDimNr : 0;
                        }

                        #endregion

                        #region Dim 5

                        if (dimCounter == 5)
                        {
                            row.Dim5Id = accountInternal.AccountId;
                            row.Dim5Name = accountInternal.Name;
                            row.Dim5Nr = accountInternal.AccountNr;
                            row.Dim5SIENr = accountDim.SysSieDimNr != null ? (int)accountDim.SysSieDimNr : 0;
                        }

                        #endregion

                        #region Dim 6

                        if (dimCounter == 6)
                        {
                            row.Dim6Id = accountInternal.AccountId;
                            row.Dim6Name = accountInternal.Name;
                            row.Dim6Nr = accountInternal.AccountNr;
                            row.Dim6SIENr = accountDim.SysSieDimNr != null ? (int)accountDim.SysSieDimNr : 0;
                        }

                        #endregion
                    }

                    dimCounter++;
                }
            }
            row.accountString = row.Dim1Nr + ";" + row.Dim2Nr + ";" + row.Dim3Nr + ";" + row.Dim4Nr + ";" + row.Dim5Nr + ";" + row.Dim6Nr;
        }

        public ActionResult SaveEmployeeCalculationResultValues(int employeeCalculateVacationResultHeadId, int employeeId, List<EmployeeCalculateVacationResultDTO> resultsInput)
        {
            ActionResult result = null;

            using (CompEntities entities = new CompEntities())
            {
                try
                {
                    List<EmployeeCalculateVacationResult> employeeResults = GetEmployeeCalculateVacationResults(entities, employeeCalculateVacationResultHeadId, employeeId);
                    var head = employeeResults.FirstOrDefault()?.EmployeeCalculateVacationResultHead;
                    foreach (var employeeResult in employeeResults)
                    {
                        EmployeeCalculateVacationResultDTO input = resultsInput.FirstOrDefault(x => x.EmployeeCalculateVacationResultId == employeeResult.EmployeeCalculateVacationResultId);
                        if (input != null)
                        {
                            employeeResult.State = (int)SoeEntityState.Deleted;
                            SetModifiedProperties(employeeResult);

                            EmployeeCalculateVacationResult calcResult = new EmployeeCalculateVacationResult()
                            {
                                EmployeeId = input.EmployeeId,
                                Success = input.Success,
                                State = (int)SoeEntityState.Active,
                                Name = input.Name.Trim(),
                                Value = input.Value,
                                FormulaExtracted = input.FormulaExtracted,
                                FormulaNames = input.FormulaNames,
                                FormulaOrigin = input.FormulaOrigin,
                                FormulaPlain = input.FormulaPlain,
                                Error = input.Error,
                                EmployeeCalculateVacationResultHead = head
                            };
                            SetCreatedProperties(calcResult);
                        }
                    }

                    result = SaveChanges(entities);
                }
                catch (Exception ex)
                {
                    base.LogError(ex, this.log);
                    result = new ActionResult(ex);
                    log.Error(ex.Message, ex);
                }

                return result;
            }
        }

        public ActionResult SaveEmployeeCalculationResult(CompEntities entities, int actorCompanyId, List<CalculateVacationResultContainerDTO> containerDTOs, DateTime currentDate)
        {
            DateTime batchTimeStamp = DateTime.Now;

            #region Delete on existing

            var vacationResultHeads = GetEmployeeCalculateVacationResultHeads(entities, actorCompanyId, currentDate);
            foreach (var vacationResultHead in vacationResultHeads)
            {
                foreach (var result in vacationResultHead.EmployeeCalculateVacationResult)
                {
                    if (containerDTOs.Any(a => a.FormulaResult.Any(a2 => a2.EmployeeId == result.EmployeeId)))
                    {
                        result.State = (int)SoeEntityState.Deleted;
                        SetModifiedProperties(result);
                    }
                }
            }

            #endregion

            EmployeeCalculateVacationResultHead head = new EmployeeCalculateVacationResultHead()
            {
                ActorCompanyId = actorCompanyId,
                Date = currentDate
            };
            SetCreatedProperties(head, created: batchTimeStamp);
            entities.AddObject("EmployeeCalculateVacationResultHead", head);

            foreach (var containerDTO in containerDTOs)
            {
                foreach (var item in containerDTO.FormulaResult)
                {
                    EmployeeCalculateVacationResult calcResult = new EmployeeCalculateVacationResult()
                    {
                        EmployeeId = item.EmployeeId,
                        Success = item.Success,
                        State = (int)SoeEntityState.Active,
                        Name = item.Name.Trim(),
                        Value = item.Value,
                        FormulaExtracted = item.FormulaExtracted,
                        FormulaNames = item.FormulaNames,
                        FormulaOrigin = item.FormulaOrigin,
                        FormulaPlain = item.FormulaPlain,
                        Error = item.Error,
                        EmployeeCalculateVacationResultHead = head,

                    };
                    SetCreatedProperties(calcResult, created: batchTimeStamp);
                }
            }

            return SaveChanges(entities);
        }

        public CalculateVacationResultContainerDTO CalculateVacationDebt(
            CompEntities entities,
            int actorCompanyId,
            DateTime date,
            VacationGroup vacationGroup,
            VacationGroupSE vacationGroupSE,
            Employee employee,
            Employment employment,
            bool isFinalSalary = false,
            List<EmployeeFactor> employeeFactors = null,
            List<EmployeeGroup> employeeGroups = null,
            List<TimePayrollTransaction> timePayrollTransactionForEmployeeInVacationYear = null,
            List<AttestPayrollTransactionDTO> attestPayrollTransactions = null,
            List<AttestPayrollTransactionDTO> attestPayrollTransactionsVariable = null,
            List<PayrollProductSetting> payrollProductSettings = null,
            int? timePeriodId = null
            )
        {
            return new VacationCalculation(
                parameterObject,
                entities,
                actorCompanyId,
                date,
                employee,
                employment,
                vacationGroup,
                vacationGroupSE,
                isFinalSalary,
                employeeFactors,
                employeeGroups,
                timePayrollTransactionForEmployeeInVacationYear,
                attestPayrollTransactions,
                attestPayrollTransactionsVariable,
                payrollProductSettings,
                timePeriodId)
                .CalculateVacationDebt();
        }

        private CalculateVacationResultDTO CreateVacationCalculation(
            CompEntities entities,
            out VacationCalculation vacationCalculation,
            int actorCompanyId,
            int employeeId,
            DateTime date,
            string name,
            bool isFinalSalary = false,
            Employee employee = null,
            VacationGroup vacationGroup = null)
        {
            vacationCalculation = null;

            vacationGroup = vacationGroup ?? this.GetVacationGroupForEmployee(entities, actorCompanyId, employeeId, date);
            if (vacationGroup == null)
                return new CalculateVacationResultDTO("Semesteravtal saknas på anställd", name);

            VacationGroupSE vacationGroupSE = this.GetVacationGroupSE(vacationGroup);
            if (vacationGroupSE == null)
                return new CalculateVacationResultDTO("Semesteravtal saknas på anställd", name);

            employee = employee ?? EmployeeManager.GetEmployee(entities, employeeId, actorCompanyId, loadEmployment: true);
            if (employee == null)
                return new CalculateVacationResultDTO("Anställd saknas", name);

            Employment employment = employee.GetEmployment(date);
            if (employment == null)
                return new CalculateVacationResultDTO("Anställning saknas", name);

            vacationCalculation = new VacationCalculation(
                parameterObject,
                entities,
                actorCompanyId,
                date,
                employee,
                employment,
                vacationGroup,
                vacationGroupSE,
                isFinalSalary: isFinalSalary,
                employeeFactors: base.GetEmployeeFactorsFromCache(entities, CacheConfig.Company(actorCompanyId)),
                employeeGroups: base.GetEmployeeGroupsFromCache(entities, CacheConfig.Company(actorCompanyId)),
                timePayrollTransactionForEmployeeInVacationYear: new List<TimePayrollTransaction>(),
                attestPayrollTransactions: new List<AttestPayrollTransactionDTO>(),
                attestPayrollTransactionsVariable: new List<AttestPayrollTransactionDTO>()
                );

            return new CalculateVacationResultDTO(name);
        }

        public CalculateVacationResultContainerDTO CalculateVacationSR(
            CompEntities entities,
            int actorCompanyId,
            DateTime date,
            VacationGroup vacationGroup,
            VacationGroupSE vacationGroupSE,
            Employee employee,
            Employment employment)
        {
            return new VacationCalculation(
                parameterObject,
                entities,
                actorCompanyId,
                date,
                employee,
                employment,
                vacationGroup,
                vacationGroupSE)
                .CalculateVacationSR();
        }

        public ActionResult DeleteEmployeeCalculateVacationResultHead(int actorCompanyId, int employeeCalculateVacationResultHeadId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return DeleteEmployeeCalculateVacationResultHead(entities, actorCompanyId, employeeCalculateVacationResultHeadId);
        }

        public ActionResult DeleteEmployeeCalculateVacationResultHead(CompEntities entities, int actorCompanyId, int employeeCalculateVacationResultHeadId)
        {
            EmployeeCalculateVacationResultHead resultHead = entities.EmployeeCalculateVacationResultHead.Include("EmployeeCalculateVacationResult").FirstOrDefault(f => f.ActorCompanyId == actorCompanyId && f.EmployeeCalculateVacationResultHeadId == employeeCalculateVacationResultHeadId);
            if (resultHead != null)
            {
                DateTime batchTimeStamp = DateTime.Now;

                foreach (EmployeeCalculateVacationResult result in resultHead.EmployeeCalculateVacationResult.Where(x => x.State == (int)SoeEntityState.Active))
                {
                    result.State = (int)SoeEntityState.Deleted;
                    SetModifiedProperties(result, modified: batchTimeStamp);
                }

                resultHead.State = (int)SoeEntityState.Deleted;
                SetModifiedProperties(resultHead, modified: batchTimeStamp);
            }

            return SaveChanges(entities);
        }

        public ActionResult DeleteEmployeeCalculateVacationResultsForEmployee(int employeeCalculateVacationResultHeadId, int employeeId)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return DeleteEmployeeCalculateVacationResultsForEmployee(entities, employeeCalculateVacationResultHeadId, employeeId);
        }

        public ActionResult DeleteEmployeeCalculateVacationResultsForEmployee(CompEntities entities, int employeeCalculateVacationResultHeadId, int employeeId)
        {
            int actorCompanyId = base.ActorCompanyId;

            List<EmployeeCalculateVacationResult> results = (from a in entities.EmployeeCalculateVacationResult
                                                             where a.EmployeeCalculateVacationResultHeadId == employeeCalculateVacationResultHeadId &&
                                                             a.EmployeeId == employeeId &&
                                                             a.Employee.ActorCompanyId == actorCompanyId &&
                                                             a.State == (int)SoeEntityState.Active
                                                             select a).ToList();

            DateTime batchTimeStamp = DateTime.Now;

            foreach (EmployeeCalculateVacationResult result in results)
            {
                result.State = (int)SoeEntityState.Deleted;
                SetModifiedProperties(result, modified: batchTimeStamp);
            }

            return SaveChanges(entities);
        }

        #endregion

        #region Beräkning av semesterdagar (antal)

        // Semesterrätt
        public CalculateVacationResultDTO GetVacationDaysPaidByLaw(int actorCompanyId, int employeeId, DateTime date)
        {
            using CompEntities entitiesReadOnly = CompEntitiesProvider.LeaseReadOnlyContext();
            var result = CreateVacationCalculation(entitiesReadOnly, out VacationCalculation vacationCalculation, actorCompanyId, employeeId, date, "Semesterrätt");
            if (!result.Success)
                return result;
            return vacationCalculation.GetVacationDaysPaidByLaw();
        }

        public CalculateVacationResultDTO GetVacationDaysPaidByLaw(CompEntities entities, int actorCompanyId, Employee employee, VacationGroup vacationGroup, DateTime date)
        {
            if (!vacationGroup?.VacationGroupSE.IsLoaded ?? false)
                vacationGroup.VacationGroupSE.Load();

            var result = CreateVacationCalculation(entities, out VacationCalculation vacationCalculation, actorCompanyId, employee.EmployeeId, date, "Semesterrätt", vacationGroup: vacationGroup, employee: employee);
            if (!result.Success)
                return result;
            return vacationCalculation.GetVacationDaysPaidByLaw();
        }

        #endregion

        #region EmployeeHourlyPay

        public DateTime? GetPaymentDate(PayrollGroup payrollGroup, DateTime date)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetPaymentDate(entities, payrollGroup, date);
        }

        public DateTime? GetPaymentDate(CompEntities entities, PayrollGroup payrollGroup, DateTime date)
        {
            if (payrollGroup?.TimePeriodHeadId == null)
                return null;

            string key = $"GetPaymentDate{payrollGroup.TimePeriodHeadId}#{date.Year}#{date.Month}";

            DateTime? fromCache = BusinessMemoryCache<DateTime?>.Get(key);

            if (fromCache != null && fromCache.Value == DateTime.MinValue)
                return null;

            if (fromCache != null)
                return fromCache.Value;

            var paymentDate = entities.TimePeriod
                .Where(tp => tp.TimePeriodHead.TimePeriodHeadId == payrollGroup.TimePeriodHeadId.Value && !tp.ExtraPeriod && tp.State == (int)SoeEntityState.Active)
                .FirstOrDefault(t => date >= t.StartDate && date <= t.StopDate)?.PaymentDate;

            if (!paymentDate.HasValue)
            {
                paymentDate = DateTime.MinValue;
            }
            BusinessMemoryCache<DateTime?>.Set(key, paymentDate);

            if (paymentDate.HasValue && paymentDate.Value == DateTime.MinValue)
                return null;

            return paymentDate;
        }

        public Dictionary<DateTime, decimal> GetEmployeeHourlyPays(int actorCompanyId, Employee employee, DateTime dateFrom, DateTime dateTo, Dictionary<int, decimal> settingPayrollGroupMonthlyWorkTimeDict = null, List<PayrollGroup> payrollGroups = null, List<PayrollGroupSetting> payrollGroupSettings = null, List<PayrollGroupPriceTypeDTO> payrollGroupPriceTypes = null, Dictionary<int, List<EmploymentPriceTypeDTO>> employmentPriceTypesForCompanyDict = null, EmployeeDTO employeeDTO = null, decimal? devisor = null, List<FixedPayrollRowDTO> fixedPayrollRows = null, EvaluatePayrollPriceFormulaInputDTO iDTO = null, decimal deductionAmount = 0)
        {
            using var entities = CompEntitiesProvider.LeaseReadOnlyContext();
            return GetEmployeeHourlyPays(entities, actorCompanyId, employee, dateFrom, dateTo, settingPayrollGroupMonthlyWorkTimeDict, payrollGroups, payrollGroupSettings, payrollGroupPriceTypes: payrollGroupPriceTypes, employmentPriceTypesForCompanyDict: employmentPriceTypesForCompanyDict, employeeDTO: employeeDTO, devisor: devisor, fixedPayrollRows, iDTO, deductionAmount);
        }

        public Dictionary<DateTime, decimal> GetEmployeeHourlyPays(CompEntities entities, int actorCompanyId, Employee employee, DateTime dateFrom, DateTime dateTo, Dictionary<int, decimal> settingPayrollGroupMonthlyWorkTimeDict = null, List<PayrollGroup> payrollGroups = null, List<PayrollGroupSetting> payrollGroupSettings = null, List<PayrollGroupPriceTypeDTO> payrollGroupPriceTypes = null, Dictionary<int, List<EmploymentPriceTypeDTO>> employmentPriceTypesForCompanyDict = null, EmployeeDTO employeeDTO = null, decimal? devisor = null, List<FixedPayrollRowDTO> fixedPayrollRows = null, EvaluatePayrollPriceFormulaInputDTO iDTO = null, decimal deductionAmount = 0)
        {
            if (decimal.Round(devisor ?? 0, 4) == new decimal(0))
                devisor = null;

            var id = employee != null ? employee.EmployeeId.ToString() : employeeDTO != null ? employeeDTO.EmployeeId.ToString() : Guid.NewGuid().ToString();
            string key = $"GetEmployeeHourlyPays{id}#{actorCompanyId}#{dateFrom}#{dateTo}#{devisor}#{deductionAmount}";

            Dictionary<DateTime, decimal> fromCache = BusinessMemoryCache<Dictionary<DateTime, decimal>>.Get(key);

            if (fromCache != null)
                return fromCache;

            Dictionary<DateTime, decimal> dict = new Dictionary<DateTime, decimal>();
            DateTime currentDate = dateFrom;

            int employeeId = employee != null ? employee.EmployeeId : (employeeDTO != null ? employeeDTO.EmployeeId : 0);
            int? onePayrollGroup = null;
            List<EmploymentPriceTypeDTO> employmentPriceTypes = !employmentPriceTypesForCompanyDict.IsNullOrEmpty() && employmentPriceTypesForCompanyDict.TryGetValue(employeeId, out var employmentPriceTypeDTOs) ? employmentPriceTypeDTOs : base.GetEmploymentPriceTypesDTOsFromCache(entities, CacheConfig.Company(actorCompanyId)).Where(w => w.EmployeeId == employeeId).ToList();
            var companyPayrollGroupPriceTypes = base.GetPayrollGroupPriceTypesForCompanyFromCache(entities, CacheConfig.Company(actorCompanyId)).ToDTOs(true).ToList();
            payrollGroups = iDTO?.PayrollGroups ?? payrollGroups ?? base.GetPayrollGroupsFromCache(entities, CacheConfig.Company(actorCompanyId));
            fixedPayrollRows = fixedPayrollRows ?? EmployeeManager.GetEmployeeFixedPayrollRows(entities, actorCompanyId, employee?.ObjToList() ?? EmployeeManager.GetEmployee(entities, employeeId, base.ActorCompanyId, loadEmployment: true).ObjToList(), dateFrom, dateTo, iDTO);
            var fixedPayrollRowsOnEmployee = fixedPayrollRows.Where(w => w.EmployeeId == employeeId).ToList();
            var products = iDTO?.PayrollProducts ?? base.GetPayrollProductsFromCache(entities, CacheConfig.Company(actorCompanyId));

            if (employee != null && CalendarUtility.GetTotalDays(dateFrom, dateTo) > 3)
            {
                var ids = employee.GetPayrollGroupIds(dateFrom, dateTo, payrollGroups);

                if (!ids.IsNullOrEmpty())
                {
                    onePayrollGroup = ids.Count == 1 ? ids.First() : (int?)null;
                    companyPayrollGroupPriceTypes = companyPayrollGroupPriceTypes.Where(w => ids.Contains(w.PayrollGroupId)).ToList();
                }
            }

            List<TimeEmployeeScheduleDataSmallDTO> schedules = new List<TimeEmployeeScheduleDataSmallDTO>();
            bool schedulesLoaded = false;
            Dictionary<DateTime, decimal> monthDevisorDict = new Dictionary<DateTime, decimal>();

            Employment employment = null;
            EmploymentDTO employmentDTO = null;

            while (currentDate <= dateTo)
            {
                decimal calculatedCostPerHour = 0;

                if (employee != null && (employment == null || !(employment.DateFrom <= currentDate && (!employment.DateTo.HasValue || employment.DateTo.Value >= currentDate))))
                {
                    employment = employee.GetEmployment(currentDate);
                }
                if (employeeDTO != null && (employmentDTO == null || (employmentDTO.DateFrom <= currentDate && (!employmentDTO.DateTo.HasValue || employmentDTO.DateTo.Value >= currentDate))))
                {
                    employmentDTO = employeeDTO.GetEmployment(currentDate);
                }

                if (employment != null || employmentDTO != null)
                {
                    int? payrollGroupId = null;
                    int employmentId = 0;

                    if (employment != null)
                    {
                        if (onePayrollGroup.HasValue)
                            payrollGroupId = onePayrollGroup.Value;
                        else
                            payrollGroupId = employment.GetPayrollGroupId(currentDate);

                        employmentId = employment.EmploymentId;
                    }
                    else if (employmentDTO != null)
                    {
                        employmentDTO.ApplyEmploymentChanges(currentDate);
                        payrollGroupId = employmentDTO.PayrollGroupId;
                        employmentId = employmentDTO.EmploymentId;
                    }

                    if (payrollGroupId.HasValue)
                    {
                        var payrollGroup = payrollGroups.FirstOrDefault(f => f.PayrollGroupId == payrollGroupId);

                        if (!devisor.HasValue)
                        {
                            PayrollGroupSetting settingMonthlyWorkTimeCalc = null;
                            if (payrollGroups != null)
                                settingMonthlyWorkTimeCalc = payrollGroups?.FirstOrDefault(pg => pg.PayrollGroupId == payrollGroupId.Value)?.PayrollGroupSetting?.FirstOrDefault(s => s.Type == (int)PayrollGroupSettingType.MonthlyWorkTimeCalculationType);
                            else
                                settingMonthlyWorkTimeCalc = PayrollManager.GetPayrollGroupSetting(entities, payrollGroupId.Value, PayrollGroupSettingType.MonthlyWorkTimeCalculationType, payrollGroups: iDTO?.PayrollGroups);

                            if (settingMonthlyWorkTimeCalc?.IntData != null && settingMonthlyWorkTimeCalc.IntData == (int)TermGroup_MonthlyWorkTimeCalculationType.ScheduledHoursPerMonth)
                            {
                                if (employee == null && employeeId != 0)
                                    employee = EmployeeManager.GetEmployee(entities, employeeId, actorCompanyId, dateFrom, dateTo, loadEmployment: true);

                                schedules = schedulesLoaded ? schedules : TimeScheduleManager.GetTimeEmployeeScheduleSmallDTOForReport(CalendarUtility.GetBeginningOfMonth(dateFrom), CalendarUtility.GetEndOfMonth(dateTo), employee.ObjToList(), actorCompanyId, base.RoleId, addAmounts: false, removeBreaks: true, forceSkipAccount: true); // Get all independent of accountid
                                schedulesLoaded = true;
                                var currentMonthStart = CalendarUtility.GetBeginningOfMonth(currentDate);
                                var currentMonthEnd = CalendarUtility.GetEndOfMonth(currentDate);

                                if (monthDevisorDict.ContainsKey(currentMonthStart) && monthDevisorDict.TryGetValue(currentMonthStart, out decimal currentDevisor))
                                    devisor = currentDevisor;
                                else
                                {
                                    var currentMonthDevisor = schedules.Where(w => w.Date >= currentMonthStart && w.Date <= currentMonthEnd).Sum(s => s.QuantityHours);
                                    monthDevisorDict.Add(currentMonthStart, currentMonthDevisor);
                                    devisor = currentMonthDevisor;
                                }
                                if (devisor == 0)
                                    devisor = null;
                            }
                        }

                        decimal deductionAmountPerHour = 0;
                        if (devisor.HasValue && devisor != 0 && deductionAmount != 0)
                            deductionAmountPerHour = decimal.Divide(deductionAmount, devisor.Value);

                        List<EmploymentPriceTypeDTO> priceTypes = EmployeeManager.GetEmploymentPriceTypes(employmentId, payrollGroupId, currentDate, employmentPriceTypes, companyPayrollGroupPriceTypes);
                        foreach (var priceTypeItem in priceTypes)
                        {
                            decimal amount = 0;
                            decimal? priceTypeItemAmount = priceTypeItem.GetAmount(currentDate);
                            if (priceTypeItemAmount.HasValue && priceTypeItemAmount.Value != 0)
                                amount = priceTypeItemAmount.Value;
                            else if (priceTypeItem.PayrollGroupAmount.HasValue && priceTypeItem.PayrollGroupAmount.Value != 0)
                                amount = priceTypeItem.PayrollGroupAmount.Value;

                            switch (priceTypeItem.PayrollPriceType)
                            {
                                case TermGroup_SoePayrollPriceType.Hourly:
                                    break;
                                case TermGroup_SoePayrollPriceType.Fulltime:
                                case TermGroup_SoePayrollPriceType.Monthly:
                                    if (settingPayrollGroupMonthlyWorkTimeDict == null || !settingPayrollGroupMonthlyWorkTimeDict.ContainsKey(payrollGroupId.Value))
                                    {
                                        if (settingPayrollGroupMonthlyWorkTimeDict == null)
                                            settingPayrollGroupMonthlyWorkTimeDict = new Dictionary<int, decimal>();

                                        PayrollGroupSetting settingMonthlyWorkTime = null;
                                        if (payrollGroupSettings != null)
                                            settingMonthlyWorkTime = payrollGroupSettings.GetPayrollGroupSetting(payrollGroupId.Value, PayrollGroupSettingType.MonthlyWorkTime);
                                        else
                                            settingMonthlyWorkTime = PayrollManager.GetPayrollGroupSetting(entities, payrollGroupId.Value, PayrollGroupSettingType.MonthlyWorkTime, payrollGroups: iDTO?.PayrollGroups);

                                        if (settingPayrollGroupMonthlyWorkTimeDict != null && settingMonthlyWorkTime != null && settingMonthlyWorkTime.DecimalData.HasValue)
                                            settingPayrollGroupMonthlyWorkTimeDict.Add(payrollGroupId.Value, settingMonthlyWorkTime.DecimalData.Value);
                                    }
                                    if (devisor.HasValue && devisor > 0)
                                        amount /= devisor.Value;
                                    else if (settingPayrollGroupMonthlyWorkTimeDict != null && settingPayrollGroupMonthlyWorkTimeDict.ContainsKey(payrollGroupId.Value) && settingPayrollGroupMonthlyWorkTimeDict[payrollGroupId.Value] != 0)
                                        amount /= settingPayrollGroupMonthlyWorkTimeDict[payrollGroupId.Value];
                                    else
                                        amount = 0;

                                    if (priceTypeItem.PayrollPriceType == TermGroup_SoePayrollPriceType.Monthly && amount != 0)
                                    {
                                        var employmentFactor = employment?.GetPercent(currentDate) ?? employmentDTO?.Percent;
                                        if (employmentFactor.HasValue && employmentFactor.Value > 0)
                                            amount = decimal.Divide(amount, Decimal.Divide(employmentFactor.Value, 100));
                                    }

                                    if (deductionAmountPerHour != 0 && amount != 0)
                                    {
                                        amount = amount - deductionAmountPerHour;
                                        deductionAmountPerHour = 0;
                                    }

                                    break;
                                default:
                                    amount = 0;
                                    break;
                            }
                            calculatedCostPerHour += amount;
                        }

                        if (fixedPayrollRowsOnEmployee.Any())
                        {
                            foreach (var row in fixedPayrollRowsOnEmployee.Where(w => w.Amount != 0))
                            {
                                var product = products.FirstOrDefault(f => f.ProductId == row.ProductId);

                                if (product != null && !product.IsGrossSalary())
                                    continue;

                                if (devisor.HasValue && devisor > 0)
                                    calculatedCostPerHour += decimal.Divide(row.Amount, devisor.Value);
                                else if (settingPayrollGroupMonthlyWorkTimeDict != null && settingPayrollGroupMonthlyWorkTimeDict.ContainsKey(payrollGroupId.Value) && settingPayrollGroupMonthlyWorkTimeDict[payrollGroupId.Value] != 0)
                                    calculatedCostPerHour += decimal.Divide(row.Amount, settingPayrollGroupMonthlyWorkTimeDict[payrollGroupId.Value]);
                            }

                        }
                    }
                }

                if (calculatedCostPerHour == 0)
                    calculatedCostPerHour = EmployeeManager.GetEmployeeCalculatedCost(entities, employee, currentDate, null);

                dict.Add(currentDate, calculatedCostPerHour);
                currentDate = currentDate.AddDays(1);
            }
            BusinessMemoryCache<Dictionary<DateTime, decimal>>.Set(key, dict);
            return dict;
        }

        public decimal GetEmployeeHourlyPay(CompEntities entities, Employee employee, Employment employment, DateTime dateTo, out DateTime endDate, Dictionary<int, decimal> settingPayrollGroupMonthlyWorkTimeDict = null, List<EmployeeGroup> employeeGroups = null, List<PayrollGroup> payrollGroups = null, List<PayrollGroupSetting> payrollGroupSettings = null, List<EmploymentPriceTypeDTO> employmentPriceTypes = null)
        {
            decimal calculatedCostPerHour = 0;
            endDate = dateTo;

            if (employment != null)
            {
                DateTime? employmentEndDate = employment.GetEndDate();
                if (!employmentEndDate.HasValue || employmentEndDate.Value > dateTo)
                    endDate = dateTo;
                else
                    endDate = employmentEndDate.Value;

                int? payrollGroupId = employment.GetPayrollGroupId(endDate);
                if (payrollGroupId.HasValue)
                {
                    List<EmploymentPriceTypeDTO> priceTypesGroup = EmployeeManager.GetEmploymentPriceTypes(employment.EmploymentId, payrollGroupId, endDate, employmentPriceTypes: employmentPriceTypes);
                    foreach (var priceTypeItem in priceTypesGroup)
                    {

                        decimal amount = 0;
                        decimal? priceTypeItemAmount = priceTypeItem.GetAmount(endDate);
                        if (priceTypeItemAmount.HasValue && priceTypeItemAmount.Value != 0)
                            amount = priceTypeItemAmount.Value;
                        else if (priceTypeItem.PayrollGroupAmount.HasValue && priceTypeItem.PayrollGroupAmount.Value != 0)
                            amount = priceTypeItem.PayrollGroupAmount.Value;

                        switch (priceTypeItem.PayrollPriceType)
                        {
                            case TermGroup_SoePayrollPriceType.Hourly:
                                break;
                            case TermGroup_SoePayrollPriceType.Fulltime:
                            case TermGroup_SoePayrollPriceType.Monthly:
                                if (settingPayrollGroupMonthlyWorkTimeDict == null || !settingPayrollGroupMonthlyWorkTimeDict.ContainsKey(payrollGroupId.Value))
                                {
                                    if (settingPayrollGroupMonthlyWorkTimeDict == null)
                                        settingPayrollGroupMonthlyWorkTimeDict = new Dictionary<int, decimal>();

                                    PayrollGroupSetting settingMonthlyWorkTime = null;
                                    if (payrollGroupSettings != null)
                                        settingMonthlyWorkTime = payrollGroupSettings.GetPayrollGroupSetting(payrollGroupId.Value, PayrollGroupSettingType.MonthlyWorkTime);
                                    else
                                        settingMonthlyWorkTime = PayrollManager.GetPayrollGroupSetting(entities, payrollGroupId.Value, PayrollGroupSettingType.MonthlyWorkTime, payrollGroups: payrollGroups);

                                    if (settingPayrollGroupMonthlyWorkTimeDict != null && settingMonthlyWorkTime != null && settingMonthlyWorkTime.DecimalData.HasValue)
                                        settingPayrollGroupMonthlyWorkTimeDict.Add(payrollGroupId.Value, settingMonthlyWorkTime.DecimalData.Value);
                                }

                                if (settingPayrollGroupMonthlyWorkTimeDict != null && settingPayrollGroupMonthlyWorkTimeDict.ContainsKey(payrollGroupId.Value) && settingPayrollGroupMonthlyWorkTimeDict[payrollGroupId.Value] != 0)
                                    amount /= settingPayrollGroupMonthlyWorkTimeDict[payrollGroupId.Value];
                                else
                                    amount = 0;

                                if (priceTypeItem.PayrollPriceType == TermGroup_SoePayrollPriceType.Monthly && amount != 0)
                                {
                                    var employmentFactor = employment.GetPercent(endDate);
                                    if (employmentFactor > 0)
                                        amount = decimal.Divide(amount, Decimal.Divide(employmentFactor, 100));
                                }
                                break;
                            default:
                                amount = 0;
                                break;
                        }
                        calculatedCostPerHour += amount;
                    }
                }
            }

            if (calculatedCostPerHour == 0)
                calculatedCostPerHour = EmployeeManager.GetEmployeeCalculatedCost(entities, employee, DateTime.Today, null);

            return calculatedCostPerHour;
        }

        #endregion

        #region QualifyingDayCalculation

        /// <summary>
        /// Anställdes genomsmittliga veckoarbetstid enligt anställningskontraktet
        /// </summary>
        public int GetEmployeeWorkTimeWeekMinutes(Employee employee, DateTime date)
        {
            //Formula
            return employee?.GetEmployment(date)?.GetWorkTimeWeek(date) ?? 0;
        }

        /// <summary>
        /// X = (A + B)
        /// 
        /// A - Anställdes genomsmittliga veckoarbetstid enligt anställningskontraktet
        /// B - Schemapass markerat som extrapass
        /// X - Beräknad genomsnittlig veckoarbetstid
        /// 
        /// </summary>
        public static int GetEmployeeWorkTimeWeekPlusExtraShiftsMinutes(int employeeWorkTimeWeekMinutes, int employeeExtraShiftMinutes)
        {
            //Formula
            int resultMinutes = employeeWorkTimeWeekMinutes + employeeExtraShiftMinutes;
            return resultMinutes;
        }

        /// <summary>
        /// X = A + (B - E) - C
        /// 
        /// A - Anställdes genomsmittliga veckoarbetstid enligt anställningskontraktet
        /// B - Aktuell veckas schematid enligt aktivt schema
        /// C - Aktuell veckas schematid enligt grundschema
        /// E - Tjänstledighet
        /// X - Beräknad genomsnittlig veckoarbetstid
        /// 
        /// </summary>
        public static int? GetEmployeeWorkTimeWeekPlusAdditionalContractMinutes(int employeeWorkTimeWeek, int activeScheduleMinutes, int templateScheduleMinutes, int leaveOfAbsenceMinutes)
        {
            int resultMinutes = employeeWorkTimeWeek + (activeScheduleMinutes - leaveOfAbsenceMinutes) - templateScheduleMinutes;
            return resultMinutes;
        }

        /// <summary>
        /// X = (D-E)/(F/7)
        /// Max: Heltidsmått enl Tidavtal
        /// 
        ///D - Aktuell schematid enligt Aktivt schema i avvikelseperioden
        ///E - Tjänstledighet
        ///F - Anställningsdagar i avvikelseperioden
        ///G - Tjänstledighet(hel dag - antal)
        ///H - Arbetstidsmått per vecka(Heltid)
        ///X - Beräknad genomsnittlig veckoarbetstid
        ///
        /// </summary>
        public static int? GetEmployeeAverageCalculateMinutes(int employmentDaysInPeriod, int activeScheduleMinutes, int templateScheduleMinutes, int leaveOfAbsenceMinutes, decimal employmentPercent, int ruleWorkTimeWeek)
        {
            //Formula
            int validScheduleMinutes = activeScheduleMinutes - leaveOfAbsenceMinutes;
            int employmentWeeksInPeriod = employmentDaysInPeriod > 0 ? (employmentDaysInPeriod / 7) : 0;

            if (employmentWeeksInPeriod == 0)
            {
                if (employmentDaysInPeriod > 0)
                    employmentWeeksInPeriod = 1;
                else
                    return 0;
            }

            int resultMinutes = validScheduleMinutes / employmentWeeksInPeriod;
            AdjustEmployeeWeekMinutesByEmployeeGroupRule(ref resultMinutes, employmentPercent, ruleWorkTimeWeek);

            return resultMinutes;
        }


        public static void AdjustEmployeeWeekMinutesByEmployeeGroupRule(ref int minutes, decimal employmentPercent, int ruleWorkTimeWeek)
        {
            int maxMinutes = (employmentPercent > 0 && ruleWorkTimeWeek > 0) ? (int)(employmentPercent * ruleWorkTimeWeek) / 100 : 0;
            if (maxMinutes > 0 && minutes > maxMinutes)
                minutes = maxMinutes;
        }

        #endregion
    }

    public class VacationCalculation : PayrollManager
    {
        #region Variables

        //Params
        private readonly CompEntities entities;
        private readonly int actorCompanyId;
        private readonly DateTime date;
        private readonly Employee employee;
        private readonly Employment employment;
        private readonly VacationGroup vacationGroup;
        private readonly VacationGroupSE vacationGroupSE;

        //Current
        private readonly DateTime fromDate;
        private readonly DateTime toDate;
        private readonly int nbrOfDaysForVacationYear;
        private readonly bool isFinalSalary;
        private readonly List<EmployeeGroup> employeeGroups;
        private readonly List<EmployeeFactor> employeeFactors;
        private readonly List<PayrollProductSetting> payrollProductSettings = new List<PayrollProductSetting>();
        private readonly List<AttestPayrollTransactionDTO> attestPayrollTransactions = new List<AttestPayrollTransactionDTO>();
        private readonly List<AttestPayrollTransactionDTO> attestPayrollTransactionsVariable = new List<AttestPayrollTransactionDTO>();
        private readonly List<TimePayrollTransaction> timePayrollTransactionForEmployeeInVacationYear;

        private List<CalculateVacationResultDTO> calculatedCalculateVacationResultDTOs;

        #endregion

        #region Formulas

        private static readonly Dictionary<string, string> PayrollFormulasDict = new Dictionary<string, string>()
        {
            { "AD", "Anställningstid i kalenderdagar" },
            { "ARB", "Schemalagda arbetsdagar" },
            { "ARBP", "Schemalagda arbetspass" },
            { "ARBT", "Schemalagda timmar" },
            { "BARB", "Beräknad årsarbetstid" },
            { "BV", "Branschvana i månader" },
            { "ESGF", "Ej semestergrundande frånvaro i timmar vid del av dag" },
            { "ESGFKH", "Ej semestergrundande frånvaro hel kalenderdag" },
            { "GB", "Garantibelopp beräknat" },
            { "GBU", "Garantibelopp utfyllnad" },
            { "GS", "Garantibelopp semesteravtal" },
            { "ML", "Månadslön" },
            { "NF", "Nettofaktor på anställd" },
            { "SB", "Semester betalda dagar" },
            { "SB_NETTO", "Betalda semesterdagar vid intermittent arbetstid" },
            { "SBU", "Semesterdagar uttagna" },
            { "SBURT", "Rörligt semestertillägg utbetalda" },
            { "SBUT", "Semestertillägg utbetalda" },
            { "SEMOP", "Omräknad procentsats vid fler än 25 dagars semesterrätt" },
            { "SEMP", "Procentsats semesterlön. Kan ändras på aktuella avtal t ex 12%" },
            { "SEMPU", "Procentsats semesterlön utbetalda" },
            { "SEMROP", "Omräknad rörlig procentsats vid fler än 25 dagars semesterrätt" },
            { "SEMRP", "Procentsats rörlig" },
            { "SEMTP", "Procentsats för semestertillägg" },
            { "SEMTOP", "Omräknad procentsats för semestertillägg vid fler än 25 dagars semesterrätt" },
            { "SF", "Semester betalda förskottsdagar" },
            { "SGD", "Semestergrundande arbetsdagar" },
            { "SGF", "Semestergrundande frånvarotimmar" },
            { "SGFD", "Semestergrundande frånvaro hel eller del av dag" },
            { "SGFDH", "Semestergrundande frånvaro hela arbetsdagar" },
            { "SGFV", "Värde av semestergrundande frånvaro" },
            { "SGL", "Semestergrundande lön" },
            { "SGR", "Semestergrundande lön rörlig" },
            { "SGT", "Semestergrundande arbetstid i timmar" },
            { "SL", "Semesterlön" },
            { "SLB", "Beräknad semesterlön" },
            { "SLD", "Semesterlön per betald semesterdag" },
            { "SLDS", "Semesterlön per sparade semesterdag år " },
            { "SLDU", "Semesterlön per betald semesterdag utbetald" },
            { "SN", "Snittlön" },
            { "SO", "Semester obetalda dagar" },
            { "SR", "Semesterrätt" },
            { "SSG", "Sysselsättningsgrad (under intjänandeåret)" },
            { "SSGA", "Aktuell sysselsättningsgrad" },
            { "SSGB", "Beräknad sysselsättningsgrad" },
            { "ST", "Semestertillägg" },
            { "STR", "Semestertillägg rörligt" },
            { "STRD", "Semestertillägg rörligt per dag" },
            { "STRDS", "Semestertillägg rörligt per sparad dag år" },
            { "STRAD", "Semestertillägg rörligt antal dagar" },
            { "STRADS", "Semestertillägg rörligt antal sparade dagar" },
            { "STRFD", "Semestertillägg rörligt förskottsdagar" },
            { "TL", "Timlön" },
            { "SSGS", "SnittSysselsättningsgrad" },
            { "ABD", "Återstående betalda dagar" },
            { "ASD", "Återstående sparade dagar" },
            { "VBD", "Värde återstående betalda dagar" },
            { "VSD", "Värde återstående sparade dagar" },
            { "VFD", "Värde förskottsdagar" },
            { "VBSTR", "Värde betalda semestertillägg rörligt" },
            { "BSTRA", "Betalda dagar semestertillägg rörligt" },
            { "VSSTR", "Värde sparade semestertillägg rörligt" },
            { "SSTRA", "Sparade dagar semestertillägg rörligt" },
            { "VISTR", "Värde intjänade semestertillägg rörligt" },
            { "VID", "Värde intjänade dagar" },
            { "ÅTSR", "Ålderstillägg semesterrätt" },
            { "FTD", "Fulltid per dag" },
            { "UBFD", "Utbetalda förskottsdagar" },
            { "ATGB", "Antal timmar Garantibelopp" }
        };

        public static string GetParameterName(string code) => PayrollFormulasDict.ContainsKey(code) ? PayrollFormulasDict[code] : code;

        public static Dictionary<string, string> GetUsedFormulas(List<CalculateVacationResultDTO> formulaResults)
        {
            Dictionary<string, string> usedFormulasDict = new Dictionary<string, string>();
            if (formulaResults != null)
            {
                foreach (var formulaResult in formulaResults)
                {
                    List<string> codes = new List<string>()
                    {
                        formulaResult.Name
                    };
                    if (formulaResult.FormulaPlain != null)
                        codes.AddRange(Regex.Split(formulaResult.FormulaPlain.Replace(" ", "").ToUpperInvariant(), @"\W"));

                    foreach (string code in codes)
                    {
                        if (String.IsNullOrEmpty(code) || usedFormulasDict.ContainsKey(code))
                            continue;

                        string parameterName = VacationCalculation.GetParameterName(code);
                        if (!String.IsNullOrEmpty(parameterName))
                            usedFormulasDict.Add(code, parameterName);
                    }
                }
            }
            return usedFormulasDict;
        }

        #endregion

        #region Ctor

        public VacationCalculation(
            ParameterObject parameterObject,
            CompEntities entities,
            int actorCompanyId,
            DateTime date,
            Employee employee,
            Employment employment,
            VacationGroup vacationGroup,
            VacationGroupSE vacationGroupSE,

            bool isFinalSalary = false,
            List<EmployeeFactor> employeeFactors = null,
            List<EmployeeGroup> employeeGroups = null,
            List<TimePayrollTransaction> timePayrollTransactionForEmployeeInVacationYear = null,
            List<AttestPayrollTransactionDTO> attestPayrollTransactions = null,
            List<AttestPayrollTransactionDTO> attestPayrollTransactionsVariable = null,
            List<PayrollProductSetting> payrollProductSettings = null,
            int? timePeriodId = null
            )
            : base(parameterObject)
        {
            this.parameterObject = parameterObject;
            this.entities = entities;
            this.actorCompanyId = actorCompanyId;
            this.date = date;
            this.employee = employee;
            this.employment = employment;
            this.vacationGroup = vacationGroup;
            this.vacationGroup.GetActualDates(out fromDate, out toDate, out nbrOfDaysForVacationYear, out int _, date);
            this.vacationGroupSE = vacationGroupSE;

            this.isFinalSalary = isFinalSalary;
            this.employeeFactors = employeeFactors ?? EmployeeManager.GetEmployeesFactors(entities, this.employee.EmployeeId.ObjToList());
            this.employeeGroups = employeeGroups;
            this.timePayrollTransactionForEmployeeInVacationYear = timePayrollTransactionForEmployeeInVacationYear ?? TimeTransactionManager.GetTimePayrollTransactionsForEmployee(entities, employee.EmployeeId, fromDate, toDate, null, null, null, null, true);
            if (attestPayrollTransactions != null)
                this.attestPayrollTransactions = attestPayrollTransactions;
            if (attestPayrollTransactionsVariable != null)
                this.attestPayrollTransactionsVariable = attestPayrollTransactionsVariable;
            if (payrollProductSettings != null)
                this.payrollProductSettings = payrollProductSettings;
        }

        #endregion

        #region Public methods

        public CalculateVacationResultContainerDTO CalculateVacationDebt()
        {
            CalculateVacationResultContainerDTO container = new CalculateVacationResultContainerDTO();
            List<CalculateVacationResultDTO> results = new List<CalculateVacationResultDTO>();

            #region Calculate

            CalculateVacationResultDTO resultSR = GetVacationSR();
            results.Add(resultSR);
            CalculateVacationResultDTO resultSB = GetVacationSB();
            results.Add(resultSB);
            CalculateVacationResultDTO resultSL;
            CalculateVacationResultDTO resultSLD;
            CalculateVacationResultDTO resultSLDB;
            CalculateVacationResultDTO resultSLDS1;
            CalculateVacationResultDTO resultSLDS2;
            CalculateVacationResultDTO resultSLDS3;
            CalculateVacationResultDTO resultSLDS4;
            CalculateVacationResultDTO resultSLDS5;
            CalculateVacationResultDTO resultSLDSF;
            CalculateVacationResultDTO resultSLDU;

            EmployeeVacationSE evse = employee.EmployeeVacationSE.LastOrDefault(x => x.State == (int)SoeEntityState.Active);

            if (evse == null && !employee.EmployeeVacationSE.IsLoaded)
            {
                employee.EmployeeVacationSE.Load();
                evse = employee.EmployeeVacationSE.LastOrDefault(x => x.State == (int)SoeEntityState.Active);
            }

            switch (vacationGroup.Type)
            {
                case (int)TermGroup_VacationGroupType.NoCalculation:
                case (int)TermGroup_VacationGroupType.DirectPayment:
                    break;
                case (int)TermGroup_VacationGroupType.EarningYearIsBeforeVacationYear:
                case (int)TermGroup_VacationGroupType.EarningYearIsVacationYear:
                    resultSL = GetVacationSL();
                    results.Add(resultSL);
                    resultSLD = GetVacationSLD(resultSL.Value);
                    results.Add(resultSLD);
                    if (evse != null)
                    {
                        resultSLDB = GetVacationSLDB(resultSL.Value, evse.EmploymentRatePaid.HasValue && evse.EmploymentRatePaid != 0 ? evse.EmploymentRatePaid.Value : 1);
                        results.Add(resultSLDB);
                        resultSLDS1 = GetVacationSLDS1(resultSL.Value, evse.EmploymentRateYear1.HasValue && evse.EmploymentRateYear1 != 0 ? evse.EmploymentRateYear1.Value : 1);
                        results.Add(resultSLDS1);
                        resultSLDS2 = GetVacationSLDS2(resultSL.Value, evse.EmploymentRateYear2.HasValue && evse.EmploymentRateYear2 != 0 ? evse.EmploymentRateYear2.Value : 1);
                        results.Add(resultSLDS2);
                        resultSLDS3 = GetVacationSLDS3(resultSL.Value, evse.EmploymentRateYear3.HasValue && evse.EmploymentRateYear3 != 0 ? evse.EmploymentRateYear3.Value : 1);
                        results.Add(resultSLDS3);
                        resultSLDS4 = GetVacationSLDS4(resultSL.Value, evse.EmploymentRateYear4.HasValue && evse.EmploymentRateYear4 != 0 ? evse.EmploymentRateYear4.Value : 1);
                        results.Add(resultSLDS4);
                        resultSLDS5 = GetVacationSLDS5(resultSL.Value, evse.EmploymentRateYear5.HasValue && evse.EmploymentRateYear5 != 0 ? evse.EmploymentRateYear5.Value : 1);
                        results.Add(resultSLDS5);
                        resultSLDSF = GetVacationSLDSF(resultSL.Value, evse.EmploymentRateOverdue.HasValue && evse.EmploymentRateOverdue != 0 ? evse.EmploymentRateOverdue.Value : 1);
                        results.Add(resultSLDSF);

                        if (!(!evse.PaidVacationAllowance.HasValue || evse.PaidVacationAllowance.Value == 0))
                        {
                            decimal diff = evse.UsedDaysPaid.Value - evse.PaidVacationAllowance.Value;

                            if (diff != 0)
                            {
                                resultSLDU = GetVacationSLDU(evse.EmploymentRatePaid.HasValue && evse.EmploymentRatePaid != 0 ? evse.EmploymentRatePaid.Value : 1);
                                results.Add(resultSLDU);
                            }
                        }

                        results.Add(GetVacationABD(evse));
                        results.Add(GetVacationVBD(evse, resultSLDB));
                        results.Add(GetVacationASD(evse));
                        results.Add(GetVacationVSD(evse, resultSLDB.Value, resultSLDS1.Value, resultSLDS2.Value, resultSLDS3.Value, resultSLDS4.Value, resultSLDS5.Value, resultSLDSF.Value));
                        results.Add(GetVacationVID(evse));
                        if (vacationGroupSE.HasVacationVariablePercentSettings())
                        {
                            results.Add(GetVacationVBSTR(evse));
                            results.Add(GetVacationBSTRA(evse));
                            results.Add(GetVacationVSSTR(evse));
                            results.Add(GetVacationSSTRA(evse));
                            results.Add(GetVacationVISTR());
                        }
                        results.Add(GetVacationVFD(evse));
                    }

                    break;
            }

            #endregion

            #region Result

            List<CalculateVacationResultDTO> tempResults = new List<CalculateVacationResultDTO>();

            foreach (CalculateVacationResultDTO result in results)
            {
                tempResults.Add(result);
                tempResults.AddRange(result.GetAllChildren());
            }

            foreach (var result in tempResults)
            {
                result.EmployeeId = employee.EmployeeId;
                if (!container.FormulaResult.Any(r => r.Name != null && r.Name.Equals(result.Name) && r.Value == result.Value))
                    container.FormulaResult.Add(result);
            }

            container.FormulasUsed = VacationCalculation.GetUsedFormulas(container.FormulaResult);

            return container;

            #endregion
        }

        public CalculateVacationResultContainerDTO CalculateVacationSR()
        {
            CalculateVacationResultContainerDTO container = new CalculateVacationResultContainerDTO();
            List<CalculateVacationResultDTO> results = new List<CalculateVacationResultDTO>();

            #region Calculate

            CalculateVacationResultDTO resultSR = GetVacationSR();
            results.Add(resultSR);

            container.FormulaResult.AddRange(results);

            return container;

            #endregion
        }

        #region Beräkning av återstående antal betalda dagar

        /// <summary>
        /// Återstående antal betalda dagart
        /// </summary>
        private CalculateVacationResultDTO GetVacationABD(EmployeeVacationSE employeeVacationSE)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("ABD");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Get vacation days on employee
            decimal ABD = 0;
            string formula = string.Empty;
            string formulaExtracted = string.Empty;

            #endregion

            #region Calculate
            if (vacationGroup.Type == (int)TermGroup_VacationGroupType.EarningYearIsVacationYear)
            {
                var resultAD = GetVacationAD();
                result.AddChild(resultAD);

                var resultSB = GetVacationSB();
                result.AddChild(resultSB);

                if (resultAD.Value == 0 && resultSB.Value == 0)
                {
                    ABD = 0;
                    formula = "Anställningsdagar = 0";
                }
                else
                {
                    formula = "SB-Använda betalda dagar";
                    formulaExtracted = $"{resultSB.Value}-{employeeVacationSE.UsedDaysPaid ?? 0}";
                    ABD = decimal.Subtract(resultSB.Value, employeeVacationSE.UsedDaysPaid ?? 0);
                }

            }
            else if ((employeeVacationSE.RemainingDaysPaid ?? 0) > 0)
            {
                if (this.vacationGroupSE.IsPercentCalculation())
                {
                    if (employeeVacationSE.EarnedDaysPaid - employeeVacationSE.PaidVacationAllowance == 0)
                        ABD = 0;
                    else if (employeeVacationSE.UsedDaysPaid == employeeVacationSE.PaidVacationAllowance)
                        ABD = employeeVacationSE.RemainingDaysPaid.Value;
                    else
                    {
                        formula = "BD-FUD";
                        formulaExtracted = $"{employeeVacationSE.RemainingDaysPaid}-{employeeVacationSE.PaidVacationAllowance}";
                        ABD = employeeVacationSE.RemainingDaysPaid.Value - (employeeVacationSE.PaidVacationAllowance ?? 0);
                    }
                }
                else if (this.vacationGroupSE.IsVacationAdditionCalculation())
                    ABD = employeeVacationSE.RemainingDaysPaid.Value;
            }

            result.FormulaOrigin = "Anställd";

            #endregion

            #region Result

            result.Value = ABD;
            result.FormulaPlain = formula;
            result.FormulaExtracted = formulaExtracted;
            result.FormulaNames = GetParameterName("ABD");

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        /// <summary>
        /// Värde återstående betalda dagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationVBD(EmployeeVacationSE employeeVacationSE, CalculateVacationResultDTO SLDBResult)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("VBD");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            decimal SLDB = SLDBResult?.Value ?? 0;

            #region Prereq

            var resultABD = GetVacationABD(employeeVacationSE);
            decimal ABD = resultABD.Value;
            string formula;

            #endregion

            #region Calculate

            if (vacationGroup.Type == (int)TermGroup_VacationGroupType.EarningYearIsVacationYear)
            {
                var ML = GetVacationML()?.Value ?? 0;
                var SEMP = GetVacationSEMP()?.Value ?? 0;
                var SSGA = GetVacationSSGA()?.Value ?? 0;

                decimal VBD = decimal.Multiply(SLDB, ABD);
                formula = $"{SLDB}*{ABD}";
                result.FormulaOrigin = "Anställd";
                result.Value = VBD;
                result.FormulaPlain = "SLDB*ABD";
                result.FormulaExtracted = formula;
                result.FormulaNames = GetParameterName("VBD");

            }
            else
            {
                if (vacationGroupSE.IsPercentCalculation())
                {
                    decimal VBD = decimal.Multiply(SLDB, ABD);
                    formula = $"{SLDB}*{ABD}";
                    result.FormulaOrigin = "Anställd";
                    result.Value = VBD;
                    result.FormulaPlain = "SLDB*ABD";
                    result.FormulaExtracted = formula;
                    result.FormulaNames = GetParameterName("VBD");
                }
                else if (vacationGroupSE.IsVacationAdditionCalculation())
                {
                    var SLDU = GetVacationSLDU(employeeVacationSE.EmploymentRatePaid.HasValue && employeeVacationSE.EmploymentRatePaid != 0 ? employeeVacationSE.EmploymentRatePaid.Value : 1)?.Value ?? 0;

                    if (employeeVacationSE.EarnedDaysPaid == employeeVacationSE.PaidVacationAllowance)
                    {
                        decimal VBD = decimal.Multiply(SLDU, ABD);
                        formula = $"{SLDU}*{ABD}";
                        result.FormulaOrigin = "Anställd";
                        result.Value = VBD;
                        result.FormulaPlain = "SLDU*ABD";
                        result.FormulaExtracted = formula;
                        result.FormulaNames = GetParameterName("VBD");
                    }
                    else
                    {

                        decimal UTBT = (employeeVacationSE.PaidVacationAllowance ?? 0) - (employeeVacationSE.UsedDaysPaid ?? 0);
                        decimal EJUTBT = (employeeVacationSE.RemainingDaysPaid ?? 0) - UTBT;
                        CalculateVacationResultDTO vbstr = new CalculateVacationResultDTO("VBSTRX") { Value = 0, FormulaNames = "VBSTR ingår i SLDB" };
                        if (!SLDBResult.GetChildren().Any(x => x.SRTDAdded))
                        {
                            vbstr = GetVacationVBSTR(employeeVacationSE);
                        }
                        result.AddChild(vbstr);

                        decimal VBD = (EJUTBT * SLDB) + (UTBT * SLDU) + vbstr.Value;
                        formula = $"({EJUTBT}*{SLDB})+({SLDU}*{UTBT})" + (vbstr.Value != 0 ? $"+{vbstr.Value}" : "");
                        result.FormulaOrigin = "Anställd";
                        result.Value = VBD;
                        result.FormulaPlain = "(EJUTBT*SLDB)+(SLDU*UTBT)" + (vbstr.Value != 0 ? $"+VBSTR" : "");
                        result.FormulaExtracted = formula;
                        result.FormulaNames = GetParameterName("VBD");

                    }
                }
            }

            #endregion

            #region Result

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region Beräkning av återstående antal sparade dagar

        /// <summary>
        /// Återstående antal sparade dagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationASD(EmployeeVacationSE employeeVacationSE)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("ASD");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Calculate

            // Get vacation days on employee
            decimal ASD =
                employeeVacationSE.RemainingDaysYear1.ToDecimal() +
                employeeVacationSE.RemainingDaysYear2.ToDecimal() +
                employeeVacationSE.RemainingDaysYear3.ToDecimal() +
                employeeVacationSE.RemainingDaysYear4.ToDecimal() +
                employeeVacationSE.RemainingDaysYear5.ToDecimal() +
                employeeVacationSE.RemainingDaysOverdue.ToDecimal();

            string formula = $"{employeeVacationSE.RemainingDaysYear1.ToDecimal()}+{employeeVacationSE.RemainingDaysYear2.ToDecimal()}+{employeeVacationSE.RemainingDaysYear3.ToDecimal()}+{employeeVacationSE.RemainingDaysYear4.ToDecimal()}+{employeeVacationSE.RemainingDaysYear5.ToDecimal()}+{employeeVacationSE.RemainingDaysOverdue.ToDecimal()}";

            result.FormulaOrigin = "Anställd";

            #endregion

            #region Result

            result.Value = ASD;
            result.FormulaPlain = "ASD";
            result.FormulaExtracted = formula;
            result.FormulaNames = GetParameterName("ASD");

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        /// <summary>
        /// Värde återstående sparade dagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationVSD(EmployeeVacationSE employeeVacationSE, decimal SLD, decimal SLDS1, decimal SLDS2, decimal SLDS3, decimal SLDS4, decimal SLDS5, decimal SLDSF)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("VSD");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            decimal VSD;
            string formula;
            string VSDFormula = string.Empty;

            if (vacationGroup.Type == (int)TermGroup_VacationGroupType.EarningYearIsVacationYear)
            {
                var MLResult = GetVacationML();
                result.AddChild(MLResult);
                var ASDResult = GetVacationASD(employeeVacationSE);
                result.AddChild(ASDResult);
                var SSGAResult = GetVacationSSGA();
                result.AddChild(SSGAResult);

                var useAddition = true;
                if (this.vacationGroup.VacationGroupSE.FirstOrDefault().VacationSalaryPayoutRule == (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation)
                    useAddition = false;

                var resultSEMP = this.GetVacationSEMP(useAddition);
                result.AddChild(resultSEMP);

                var ASD = ASDResult.Value;
                var ML = MLResult.Value;
                var SEMP = resultSEMP.Value;
                var SSGA = SSGAResult.Value;
                VSD = ASD * ML * SEMP * SSGA;
                VSDFormula = "ASD * ML * " + resultSEMP.Name + " * SSGA";
                formula = $"{(GetParameterName("ASD"))} * {(GetParameterName("ML"))} * {(GetParameterName(resultSEMP.Name))} * {(GetParameterName("SSGA"))}";
            }
            else
            {
                //if (vacationGroupSE.IsPercentCalculation())
                //{
                VSD = decimal.Multiply(SLDS1, employeeVacationSE.RemainingDaysYear1.ToDecimal()) +
                           decimal.Multiply(SLDS2, employeeVacationSE.RemainingDaysYear2.ToDecimal()) +
                           decimal.Multiply(SLDS3, employeeVacationSE.RemainingDaysYear3.ToDecimal()) +
                           decimal.Multiply(SLDS4, employeeVacationSE.RemainingDaysYear4.ToDecimal()) +
                           decimal.Multiply(SLDS5, employeeVacationSE.RemainingDaysYear5.ToDecimal()) +
                           decimal.Multiply(SLDSF, employeeVacationSE.RemainingDaysOverdue.ToDecimal());

                formula = $"({SLDS1}*{employeeVacationSE.RemainingDaysYear1.ToDecimal()})+({SLDS2}*{employeeVacationSE.RemainingDaysYear2.ToDecimal()})+({SLDS3}*{employeeVacationSE.RemainingDaysYear3.ToDecimal()})+({SLDS4}*{employeeVacationSE.RemainingDaysYear4.ToDecimal()})+({SLDS5}*{employeeVacationSE.RemainingDaysYear5.ToDecimal()})+({SLDSF}*{employeeVacationSE.RemainingDaysOverdue.ToDecimal()})";
                result.FormulaOrigin = "Anställd";
                //}
                //else
                //{
                //    if (this.vacationGroup.VacationGroupSE.FirstOrDefault().VacationVariablePayoutRule == (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation ||
                //        this.vacationGroup.VacationGroupSE.FirstOrDefault().VacationSalaryPayoutRule == (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation)
                //    {
                //        if (this.vacationGroup.VacationGroupSE.FirstOrDefault().VacationVariablePayoutRule == (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation &&
                //        this.vacationGroup.VacationGroupSE.FirstOrDefault().VacationSalaryPayoutRule == (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation)
                //        {
                //            var SLDUResult = GetVacationSLDU(employeeVacationSE.EmploymentRatePaid.HasValue && employeeVacationSE.EmploymentRatePaid != 0 ? employeeVacationSE.EmploymentRatePaid.Value : 1);
                //            result.AddChild(SLDUResult);
                //            var ASDResult = GetVacationASD(employeeVacationSE);
                //            result.AddChild(ASDResult);
                //            var SLDU = SLDUResult?.Value ?? 0;
                //            var ASD = ASDResult.Value;
                //            VSD = decimal.Multiply(ASD, SLDU);
                //            formula = $"{ASD}*{SLDU}";
                //        }
                //        else if (this.vacationGroup.VacationGroupSE.FirstOrDefault().VacationVariablePayoutRule == (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation)
                //        {
                //            var SLDBResult = GetVacationSLDB(GetVacationSL()?.Value ?? 0, GetVacationSSGA()?.Value ?? 0);
                //            result.AddChild(SLDBResult);
                //            var ASDResult = GetVacationASD(employeeVacationSE);
                //            result.AddChild(ASDResult);
                //            var SLDB = SLDBResult?.Value ?? 0;
                //            var ASD = ASDResult.Value;
                //            VSD = decimal.Multiply(ASD, SLDB);
                //            formula = $"{ASD}*{SLDB}";
                //        }
                //        else if (this.vacationGroup.VacationGroupSE.FirstOrDefault().VacationSalaryPayoutRule == (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation)
                //        {
                //            decimal year1 = 0;
                //            decimal year2 = 0;
                //            decimal year3 = 0;
                //            decimal year4 = 0;
                //            decimal year5 = 0;
                //            decimal yearOverdue = 0;
                //            var SLDUResult = GetVacationSLDU(employeeVacationSE.EmploymentRatePaid.HasValue && employeeVacationSE.EmploymentRatePaid != 0 ? employeeVacationSE.EmploymentRatePaid.Value : 1);
                //            result.AddChild(SLDUResult);
                //            decimal SLDU = SLDUResult.Value;

                //            if (employeeVacationSE.RemainingDaysYear1.ToDecimal() > 0)
                //            {
                //                year1 = EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationVariableAmountPerDay, this.date.AddYears(-1));

                //                if (year1 != 0)
                //                {
                //                    formula += $"{employeeVacationSE.RemainingDaysYear1.ToDecimal()}*({year1}+{SLDU})";
                //                    VSDFormula += $"{employeeVacationSE.RemainingDaysYear1.ToDecimal()}*(STRD1+SLDU)";
                //                    year1 = decimal.Multiply(employeeVacationSE.RemainingDaysYear1.ToDecimal(), (year1 + SLDU));
                //                }
                //                else
                //                {
                //                    formula += $"{employeeVacationSE.RemainingDaysYear1.ToDecimal()}*{SLDU}";
                //                    VSDFormula += $"{employeeVacationSE.RemainingDaysYear1.ToDecimal()}*SLDU";
                //                    year1 = decimal.Multiply(employeeVacationSE.RemainingDaysYear1.ToDecimal(), SLDU);
                //                }
                //            }

                //            if (employeeVacationSE.RemainingDaysYear2.ToDecimal() > 0)

                //            {
                //                year2 = EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationVariableAmountPerDay, this.date.AddYears(-2));

                //                if (year2 != 0)
                //                {
                //                    formula += $"+{employeeVacationSE.RemainingDaysYear2.ToDecimal()}*({year2}+{SLDU})";
                //                    VSDFormula += $"+{employeeVacationSE.RemainingDaysYear2.ToDecimal()}*(STRD2+SLDU)";
                //                    year2 = decimal.Multiply(employeeVacationSE.RemainingDaysYear2.ToDecimal(), (year2 + SLDU));
                //                }
                //                else
                //                {
                //                    formula += $"+{employeeVacationSE.RemainingDaysYear2.ToDecimal()}*{SLDU}";
                //                    VSDFormula += $"+{employeeVacationSE.RemainingDaysYear2.ToDecimal()}*SLDU";
                //                    year2 = decimal.Multiply(employeeVacationSE.RemainingDaysYear2.ToDecimal(), SLDU);
                //                }
                //            }
                //            if (employeeVacationSE.RemainingDaysYear3.ToDecimal() > 0)
                //            {
                //                year3 = EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationVariableAmountPerDay, this.date.AddYears(-3));

                //                if (year3 != 0)
                //                {
                //                    formula += $"+{employeeVacationSE.RemainingDaysYear3.ToDecimal()}*({year3}+{SLDU})";
                //                    VSDFormula += $"+{employeeVacationSE.RemainingDaysYear3.ToDecimal()}*(STRD3+SLDU)";
                //                    year3 = decimal.Multiply(employeeVacationSE.RemainingDaysYear3.ToDecimal(), (year3 + SLDU));
                //                }
                //                else
                //                {
                //                    formula += $"+{employeeVacationSE.RemainingDaysYear3.ToDecimal()}*{SLDU}";
                //                    VSDFormula += $"+{employeeVacationSE.RemainingDaysYear3.ToDecimal()}*SLDU";
                //                    year3 = decimal.Multiply(employeeVacationSE.RemainingDaysYear3.ToDecimal(), SLDU);
                //                }
                //            }

                //            if (employeeVacationSE.RemainingDaysYear4.ToDecimal() > 0)
                //            {
                //                year4 = EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationVariableAmountPerDay, this.date.AddYears(-4));

                //                if (year4 != 0)
                //                {
                //                    formula += $"+{employeeVacationSE.RemainingDaysYear4.ToDecimal()}*({year4}+{SLDU})";
                //                    VSDFormula += $"+{employeeVacationSE.RemainingDaysYear4.ToDecimal()}*(STRD4+SLDU)";
                //                    year4 = decimal.Multiply(employeeVacationSE.RemainingDaysYear4.ToDecimal(), (year4 + SLDU));
                //                }
                //                else
                //                {
                //                    formula += $"+{employeeVacationSE.RemainingDaysYear4.ToDecimal()}*{SLDU}";
                //                    VSDFormula += $"+{employeeVacationSE.RemainingDaysYear4.ToDecimal()}*SLDU";
                //                    year4 = decimal.Multiply(employeeVacationSE.RemainingDaysYear4.ToDecimal(), SLDU);
                //                }
                //            }

                //            if (employeeVacationSE.RemainingDaysYear5.ToDecimal() > 0)
                //            {
                //                year5 = EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationVariableAmountPerDay, this.date.AddYears(-5));

                //                if (year5 != 0)
                //                {
                //                    formula += $"+{employeeVacationSE.RemainingDaysYear5.ToDecimal()}*({year5}+{SLDU})";
                //                    VSDFormula += $"+{employeeVacationSE.RemainingDaysYear5.ToDecimal()}*(STRD5+SLDU)";
                //                    year5 = decimal.Multiply(employeeVacationSE.RemainingDaysYear5.ToDecimal(), (year5 + SLDU));

                //                }
                //                else
                //                {
                //                    formula += $"+{employeeVacationSE.RemainingDaysYear5.ToDecimal()}*{SLDU}";
                //                    VSDFormula += $"+{employeeVacationSE.RemainingDaysYear5.ToDecimal()}*SLDU";
                //                    year5 = decimal.Multiply(employeeVacationSE.RemainingDaysYear5.ToDecimal(), SLDU);
                //                }
                //            }

                //            if (employeeVacationSE.RemainingDaysOverdue.ToDecimal() > 0)
                //            {
                //                yearOverdue = EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationVariableAmountPerDay, this.date.AddYears(-6));

                //                if (yearOverdue != 0)
                //                {
                //                    formula += $"+{employeeVacationSE.RemainingDaysOverdue.ToDecimal()}*({yearOverdue}+{SLDU})";
                //                    VSDFormula += $"+{employeeVacationSE.RemainingDaysOverdue.ToDecimal()}*(STRD6+SLDU)";
                //                    yearOverdue = decimal.Multiply(employeeVacationSE.RemainingDaysOverdue.ToDecimal(), (yearOverdue + SLDU));
                //                }
                //                else
                //                {
                //                    formula += $"+{employeeVacationSE.RemainingDaysOverdue.ToDecimal()}*{SLDU}";
                //                    VSDFormula += $"+{employeeVacationSE.RemainingDaysOverdue.ToDecimal()}*SLDU";
                //                    yearOverdue = decimal.Multiply(employeeVacationSE.RemainingDaysOverdue.ToDecimal(), SLDU);
                //                }
                //            }

                //            VSD = year1 + year2 + year3 + year4 + year5 + yearOverdue;
                //            result.FormulaOrigin = "Anställd";
                //        }
                //    }
                //    else
                //    {
                //        VSD = decimal.Multiply(SLDS1, employeeVacationSE.RemainingDaysYear1.ToDecimal()) +
                //               decimal.Multiply(SLDS2, employeeVacationSE.RemainingDaysYear2.ToDecimal()) +
                //               decimal.Multiply(SLDS3, employeeVacationSE.RemainingDaysYear3.ToDecimal()) +
                //               decimal.Multiply(SLDS4, employeeVacationSE.RemainingDaysYear4.ToDecimal()) +
                //               decimal.Multiply(SLDS5, employeeVacationSE.RemainingDaysYear5.ToDecimal()) +
                //               decimal.Multiply(SLDSF, employeeVacationSE.RemainingDaysOverdue.ToDecimal());

                //        formula = $"({SLDS1}*{employeeVacationSE.RemainingDaysYear1.ToDecimal()})+({SLDS2}*{ employeeVacationSE.RemainingDaysYear2.ToDecimal() })+({SLDS3}*{ employeeVacationSE.RemainingDaysYear3.ToDecimal() })+({SLDS4}*{ employeeVacationSE.RemainingDaysYear4.ToDecimal() })+({SLDS5}*{ employeeVacationSE.RemainingDaysYear5.ToDecimal() })+({SLDSF}*{ employeeVacationSE.RemainingDaysOverdue.ToDecimal()})";
                //        result.FormulaOrigin = "Anställd";
                //    }
                //}
            }

            #endregion

            #region Result

            result.Value = VSD;
            result.FormulaPlain = string.IsNullOrEmpty(VSDFormula) ? "VSD" : VSDFormula;
            result.FormulaExtracted = formula;
            result.FormulaNames = GetParameterName("VSD");

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        /// <summary>
        /// Värde återstående intjänade dagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationVID(EmployeeVacationSE employeeVacationSE)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("VID");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            decimal SLD;

            if (vacationGroupSE.IsPercentCalculation())
            {
                var resultSL = GetVacationSL();
                result.AddChild(resultSL);
                var resultSLD = GetVacationSLD(resultSL.Value);
                result.AddChild(resultSLD);
                SLD = resultSLD.Value;
            }
            else
            {
                var resultSLDB = GetVacationSLDI(GetVacationSL().Value, GetVacationSSGB()?.Value ?? GetVacationSSGA()?.Value ?? employeeVacationSE?.EmploymentRatePaid ?? 1);
                SLD = resultSLDB.Value;
            }

            #region Prereq

            #endregion

            #region Calculate

            decimal vid = 0;
            string formula = string.Empty;
            if (vacationGroup.Type != (int)TermGroup_VacationGroupType.EarningYearIsVacationYear)
            {
                var resultSB = GetVacationSB();
                result.AddChild(resultSB);
                decimal sb = resultSB.Value;
                vid = decimal.Multiply(sb, SLD);
                formula = $"{sb}*{SLD}";
            }

            #endregion

            #region Result

            result.Value = vid;
            result.FormulaPlain = "VID";
            result.FormulaExtracted = formula;
            result.FormulaNames = GetParameterName("VID");

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        /// <summary>
        /// Värde betalda semestertillägg rörligt
        /// </summary>
        private CalculateVacationResultDTO GetVacationVBSTR(EmployeeVacationSE employeeVacationSE)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("VBSTR");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            var vacationVariablePayoutMonthDate = vacationGroupSE.GetActualVacationVariablePayoutMonthDate(date);

            if (vacationVariablePayoutMonthDate > date || this.vacationGroup.VacationGroupSE.FirstOrDefault().VacationVariablePayoutRule != (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation)
            {
                var dayValue = GetVacationSTRDSavedYears(0);
                result.AddChild(dayValue);
                var abd = GetVacationABD(employeeVacationSE);
                result.AddChild(dayValue);
                result.AddChild(abd);
                result.Value = decimal.Multiply(abd.Value, dayValue.Value);
                result.FormulaExtracted = $"{abd.Value}*{dayValue.Value}";
                result.FormulaPlain = $"ABD*STRD0";
                result.FormulaNames = $"{GetParameterName("ABD")}*{GetParameterName("STRD")}0";
            }
            else
            {
                result.FormulaExtracted = "Semestertillägg rörligt utbetalt innan semesterperiod";
            }

            result.FormulaNames = GetParameterName("VSSTR");
            return result;
        }

        /// <summary>
        /// Antal dagar intjänade semestertillägg rörligt
        /// </summary>
        private CalculateVacationResultDTO GetVacationBSTRA(EmployeeVacationSE employeeVacationSE)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("BSTRA");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            var value = GetVacationSTRADS(0, employeeVacationSE);
            result.AddChild(value);
            result.Value = value.Value;
            result.FormulaNames = GetParameterName("BSTRA");
            return result;
        }

        /// <summary>
        /// Värde sparade semestertillägg rörligt
        /// </summary>
        private CalculateVacationResultDTO GetVacationVSSTR(EmployeeVacationSE employeeVacationSE)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("VSSTR");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            if (this.vacationGroup.VacationGroupSE.FirstOrDefault().VacationVariablePayoutRule != (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation)
            {
                var saved1DayValue = GetVacationSTRDSavedYears(-1);
                var saved2DayValue = GetVacationSTRDSavedYears(-2);
                var saved3DayValue = GetVacationSTRDSavedYears(-3);
                var saved4DayValue = GetVacationSTRDSavedYears(-4);
                var saved5DayValue = GetVacationSTRDSavedYears(-5);
                var savedOverdueDayValue = GetVacationSTRDSavedYears(-6);

                result.AddChild(saved1DayValue);
                result.AddChild(saved2DayValue);
                result.AddChild(saved3DayValue);
                result.AddChild(saved4DayValue);
                result.AddChild(saved5DayValue);
                result.AddChild(savedOverdueDayValue);

                var saved1Days = GetVacationSTRADS(-1, employeeVacationSE);
                var saved2Days = GetVacationSTRADS(-2, employeeVacationSE);
                var saved3Days = GetVacationSTRADS(-3, employeeVacationSE);
                var saved4Days = GetVacationSTRADS(-4, employeeVacationSE);
                var saved5Days = GetVacationSTRADS(-5, employeeVacationSE);
                var savedOverdueDays = GetVacationSTRADS(-6, employeeVacationSE);

                result.AddChild(saved1Days);
                result.AddChild(saved2Days);
                result.AddChild(saved3Days);
                result.AddChild(saved4Days);
                result.AddChild(saved5Days);
                result.AddChild(savedOverdueDays);

                result.Value =
                    decimal.Multiply(saved1DayValue.Value, saved1Days.Value) +
                    decimal.Multiply(saved2DayValue.Value, saved2Days.Value) +
                    decimal.Multiply(saved3DayValue.Value, saved3Days.Value) +
                    decimal.Multiply(saved4DayValue.Value, saved4Days.Value) +
                    decimal.Multiply(saved5DayValue.Value, saved5Days.Value) +
                    decimal.Multiply(savedOverdueDayValue.Value, savedOverdueDays.Value);

                result.FormulaExtracted =
                     $"({saved1DayValue.Value}*{saved1Days.Value})+" +
                     $"({saved2DayValue.Value}*{saved2Days.Value})+" +
                     $"({saved3DayValue.Value}*{saved3Days.Value})+" +
                     $"({saved4DayValue.Value}*{saved4Days.Value})+" +
                     $"({saved5DayValue.Value}*{saved5Days.Value})+" +
                     $"({savedOverdueDayValue.Value}*{savedOverdueDays.Value})+";

                result.FormulaPlain = "VSSTR";
            }
            else
            {
                result.FormulaExtracted = "Semestertillägg rörligt utbetalt innan semesterperiod";
            }

            result.FormulaNames = GetParameterName("VSSTR");
            return result;
        }

        /// <summary>
        /// Antal dagar sparade semestertillägg rörligt
        /// </summary>
        private CalculateVacationResultDTO GetVacationSSTRA(EmployeeVacationSE employeeVacationSE)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SSTRA");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            if (this.vacationGroup.VacationGroupSE.FirstOrDefault().VacationVariablePayoutRule != (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation)
            {
                var saved1DayValue = GetVacationSTRADS(-1, employeeVacationSE);
                var saved2DayValue = GetVacationSTRADS(-2, employeeVacationSE);
                var saved3DayValue = GetVacationSTRADS(-3, employeeVacationSE);
                var saved4DayValue = GetVacationSTRADS(-4, employeeVacationSE);
                var saved5DayValue = GetVacationSTRADS(-5, employeeVacationSE);
                var savedOverdueDayValue = GetVacationSTRADS(-6, employeeVacationSE);

                result.AddChild(saved1DayValue);
                result.AddChild(saved2DayValue);
                result.AddChild(saved3DayValue);
                result.AddChild(saved4DayValue);
                result.AddChild(saved5DayValue);
                result.AddChild(savedOverdueDayValue);

                result.Value = saved1DayValue.Value + saved2DayValue.Value + saved3DayValue.Value + saved4DayValue.Value + saved5DayValue.Value + savedOverdueDayValue.Value;
                result.FormulaExtracted = $"{saved1DayValue.Value}+{saved2DayValue.Value}+{saved3DayValue.Value}+{saved4DayValue.Value}+{saved5DayValue.Value}+{savedOverdueDayValue.Value}";
            }

            result.FormulaPlain = "SSTRA";
            result.FormulaNames = GetParameterName("SSTRA");
            return result;
        }


        /// <summary>
        /// Värde intjänade semestertillägg rörligt
        /// </summary>
        /// 
        private CalculateVacationResultDTO GetVacationVISTR()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("VISTR");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            CalculateVacationResultDTO resultSTRD = this.GetVacationSTRD();
            if (!resultSTRD.Success)
                return resultSTRD;
            result.AddChild(resultSTRD);
            var STRD = resultSTRD.Value;

            if (vacationGroup.Type != (int)TermGroup_VacationGroupType.EarningYearIsVacationYear)
            {
                var resultSB = GetVacationSB();
                result.AddChild(resultSB);
                decimal sb = resultSB.Value;
                result.Value = decimal.Multiply(sb, STRD);
                result.FormulaPlain = $"{sb}*{STRD}";
                result.FormulaNames = GetParameterName("SB") + " * " + GetParameterName("STRD");
            }
            else if (vacationGroup.Type == (int)TermGroup_VacationGroupType.EarningYearIsVacationYear)
            {
                var strResult = GetVacationSTR();
                result.AddChild(strResult);
                result.Value = strResult.Value;
            }

            result.FormulaNames = GetParameterName("VISTR");

            var STRResult = GetVacationSTR();
            result.AddChild(STRResult);
            result.Value = STRResult.Value;
            return result;
        }

        /// <summary>
        /// Värde förskottsdagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationVFD(EmployeeVacationSE employeeVacationSE)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("VFD");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            if (!employeeVacationSE.UsedDaysAdvance.HasValue || (employeeVacationSE.DebtInAdvanceDueDate.HasValue && employeeVacationSE.DebtInAdvanceDueDate.Value < date))
                return result;

            var resultSEMP = GetVacationSEMP(false);
            result.AddChild(resultSEMP);
            var resultSLDU = GetVacationSLDU(GetVacationSSGA().Value);
            result.AddChild(resultSLDU);
            result.Value = decimal.Multiply(-1, employeeVacationSE.DebtInAdvanceAmount ?? 0);
            result.FormulaPlain = "(Skuld förskott)*-1";
            result.FormulaExtracted = $"{employeeVacationSE.DebtInAdvanceAmount}*-1";
            result.FormulaNames = "Skuld förskott";
            return result;
        }

        #region Beräkning av semesterdagar (antal)

        // Semesterrätt
        public CalculateVacationResultDTO GetVacationDaysPaidByLaw()
        {
            return this.GetVacationSR();
        }

        // Semester betalda dagar
        public CalculateVacationResultDTO GetVacationDaysPaid()
        {
            return this.GetVacationSB();
        }

        // Semester obetalda dagar
        public CalculateVacationResultDTO GetVacationDaysUnpaid()
        {
            return this.GetVacationSO();
        }

        #endregion

        #region Beräkning av semesterlön (pengar)

        // Semestergrundande lön
        public CalculateVacationResultDTO GetVacationPromotedSalary()
        {
            return this.GetVacationSGL();
        }

        // Omräknad procentsats vid fler än 25 dagars semesterrätt
        public CalculateVacationResultDTO GetVacationDayPercent()
        {
            return this.GetVacationSEMOP();
        }

        // Omräknad rörlig procentsats vid fler än 25 dagars semesterrätt
        public CalculateVacationResultDTO GetVacationVariablePercent()
        {
            return this.GetVacationSEMROP();
        }

        #endregion

        #region Beräkning av intjänad semesterlön

        public CalculateVacationResultDTO GetEarnedVacationSalary()
        {
            return this.GetVacationSL();
        }

        #endregion

        #endregion

        #region Private methods

        private List<TimePayrollTransaction> GetFilteredTimePayrollTransactionForEmployeeInVacationYear(bool excludeRetro = true)
        {
            List<Employment> finalSalaryemployments = employee.GetFinalSalaryEmployments(this.fromDate, this.toDate);
            DateTime finalDate = DateTime.MaxValue;

            // If final salary is applied, only transactions until final salary date should be included. This is used only if there are an active employment after final salary date
            if (this.isFinalSalary)
            {
                var currentEmployment = employee.GetEmployment(date);

                if (currentEmployment != null && currentEmployment.FinalSalaryStatus == (int)SoeEmploymentFinalSalaryStatus.ApplyFinalSalary && currentEmployment.GetEndDate().HasValue && employee.GetNextEmployment(date.AddDays(1)) != null)
                    finalDate = currentEmployment.GetEndDate().Value;
            }

            var beginDate = DateTime.MinValue;

            // If final salary has been applied, only transactions after final salary date should be included
            if (finalSalaryemployments.Any())
            {
                var lastFinalSalaryDate = finalSalaryemployments.Where(w => w.GetEndDate().HasValue && w.GetEndDate().Value < this.toDate).Max(s => s.GetEndDate());

                if (lastFinalSalaryDate.HasValue && lastFinalSalaryDate.Value < finalDate && lastFinalSalaryDate < this.toDate)
                    beginDate = lastFinalSalaryDate.Value.AddDays(1);
            }

            return this.timePayrollTransactionForEmployeeInVacationYear.Where(w => w.Date <= finalDate && w.Date >= beginDate && (excludeRetro ? !w.RetroactivePayrollOutcomeId.HasValue : true)).ToList();
        }

        private CalculateVacationResultDTO AlreadyCalculated(CalculateVacationResultDTO result)
        {
            if (!this.calculatedCalculateVacationResultDTOs.IsNullOrEmpty())
            {
                return this.calculatedCalculateVacationResultDTOs.FirstOrDefault(c => c.Name == result.Name);
            }

            return null;
        }

        private void AddToAlreadyCalculated(CalculateVacationResultDTO result)
        {
            if (this.calculatedCalculateVacationResultDTOs == null)
                calculatedCalculateVacationResultDTOs = new List<CalculateVacationResultDTO>();

            calculatedCalculateVacationResultDTOs.Add(result);
        }

        #region AD (Anställningstid i kalenderdagar)

        /// <summary>
        /// Anställningstid i kalenderdagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationAD()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("AD");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Calculate

            int AD = 0;

            // Get no of days employed
            DateTime prevDateTo = fromDate.AddDays(-1);
            foreach (Employment emp in employee.GetEmployments(fromDate, toDate))
            {
                // If the employment record has a final salary applied or was manually adjusted, reset the employed days count and continue to the next employment record.
                if (emp.HasAppliedFinalSalaryOrManually())
                {
                    AD = 0;
                    continue;
                }

                // Get employment start date
                DateTime empDateFrom = (!emp.DateFrom.HasValue || emp.DateFrom.Value <= prevDateTo) ? prevDateTo.AddDays(1) : emp.DateFrom.Value;

                // Get employment stop date
                DateTime empDateTo = (!emp.DateTo.HasValue || emp.DateTo.Value > toDate) ? toDate : emp.DateTo.Value;


                AD += (int)(empDateTo - empDateFrom).TotalDays + 1;

                prevDateTo = empDateTo;
            }

            #endregion

            #region Result

            result.Value = AD;
            result.FormulaPlain = "AD";
            result.FormulaExtracted = AD.ToString();
            result.FormulaNames = GetParameterName("AD");
            result.FormulaOrigin = "Anställning";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        private CalculateVacationResultDTO GetVactionANSTTID()
        {
            int ANSTTID = employee.GetEmploymentDays(CalendarUtility.DATETIME_DEFAULT.AddDays(1), date);

            return new CalculateVacationResultDTO("ANSTTID")
            {
                Value = Convert.ToDecimal(ANSTTID),
                FormulaPlain = "ANSTTID",
                FormulaExtracted = "ANSTTID",
                FormulaNames = "Anställningstid",
                FormulaOrigin = "Anställningstid",
                Success = true,
            };
        }

        #endregion

        #region ARB (Schemalagda arbetsdagar)

        /// <summary>
        /// Schemalagda arbetsdagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationARB()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("ARB");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            // Antal dagar som har schema under intjänandeåret
            int ARB = 0;

            #endregion

            #region Result

            result.Value = ARB;
            result.FormulaPlain = "ARB";
            result.FormulaExtracted = ARB.ToString();
            result.FormulaNames = GetParameterName("ARB");
            result.FormulaOrigin = "Schemablock";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region FPD (Fulltid per dag)

        /// <summary>
        /// Planerad fulltid per dag
        /// </summary>
        private CalculateVacationResultDTO GetVacationFPD()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("FPD");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            decimal PFD = 0;
            var group = employee.GetEmployeeGroup(date, employeeGroups);

            result.Value = PFD;
            result.FormulaPlain = "PFD";
            result.FormulaExtracted = PFD.ToString();
            result.FormulaNames = GetParameterName("PFD");
            result.FormulaOrigin = "Tidavtal";

            if (group != null)
            {
                var employment = employee.GetEmployment(date);
                var minutesPerWeek = employment.GetFullTimeWorkTimeWeek(group, date);
                if (minutesPerWeek != 0)
                {
                    var hoursPerWeek = decimal.Divide(minutesPerWeek, 60);
                    var hoursPerDay = decimal.Divide(hoursPerWeek, 5);
                    result.Value = hoursPerDay;
                    result.FormulaPlain = $"{hoursPerWeek}/5";
                    result.FormulaExtracted = $"{hoursPerWeek}/5";
                }
            }

            #endregion

            #region Result

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region ARBP (Schemalagda arbetspass)

        /// <summary>
        /// Schemalagda arbetspass
        /// </summary>
        private CalculateVacationResultDTO GetVacationARBP()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("ARBP");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            // Hur många arbetspass som finns på ett grundschema
            int ARBP = 0;

            #endregion

            #region Result

            result.Value = ARBP;
            result.FormulaPlain = "ARBP";
            result.FormulaExtracted = ARBP.ToString();
            result.FormulaNames = GetParameterName("ARBP");
            result.FormulaOrigin = "Schemablock";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region ARBT (Schemalagda timmar)

        /// <summary>
        /// Schemalagda timmar
        /// </summary>
        private CalculateVacationResultDTO GetVacationARBT(decimal SGT, decimal SGF)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("ARBT");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            // Hur många arbetstimmar som finns på ett schema
            decimal ARBT = SGT + SGF;

            #endregion

            #region Result

            result.Value = ARBT;
            result.FormulaPlain = "ARBT";
            result.FormulaExtracted = ARBT.ToString();
            result.FormulaNames = GetParameterName("ARBT");
            result.FormulaOrigin = "Schemablock";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region BARB (Beräknad årsarbetstid)

        /// <summary>
        /// Beräknad årsarbetstid
        /// </summary>
        private CalculateVacationResultDTO GetVacationBARB()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("BARB");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            // Check if guarantee amount is used
            if (!vacationGroupSE.UseGuaranteeAmount)
            {
                result.FormulaExtracted = "Garantibelopp används ej";
                return result;
            }

            #region Formula information

            // 1796 / 365 * (AD - ESGFKH)

            // AD       Anställningstid i kalenderdagar
            // ESGFKH   Ej semestergrundande frånvaro hel kalenderdag

            #endregion

            #region Prereq

            CalculateVacationResultDTO resultAD = this.GetVacationAD();
            if (!resultAD.Success)
                return resultAD;
            result.AddChild(resultAD);
            int AD = (int)resultAD.Value;

            CalculateVacationResultDTO resultESGFKH = this.GetVacationESGFKH();
            if (!resultESGFKH.Success)
                return resultESGFKH;
            result.AddChild(resultESGFKH);
            decimal ESGFKH = (int)resultESGFKH.Value;

            CalculateVacationResultDTO resultATGB = this.GetVacationATGB();
            if (!resultATGB.Success)
                return resultATGB;
            result.AddChild(resultATGB);
            int ATGB = (int)resultATGB.Value;

            #endregion

            #region Calculate

            decimal BARB = Decimal.Multiply(Decimal.Divide(ATGB, 365), Decimal.Subtract(AD, ESGFKH));

            #endregion

            #region Result

            result.Value = BARB;
            result.FormulaPlain = $"(ATGB / 365) * (AD - ESGFKH)";
            result.FormulaExtracted = String.Format("{0} / 365 * ({1} - {2})", ATGB, AD, ESGFKH);
            result.FormulaNames = String.Format("{0} / 365 * ({1} - {2})", GetParameterName("ATGB"), GetParameterName("AD"), GetParameterName("ESGFKH"));
            result.FormulaOrigin = "Anställning, frånvaro";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region BV (Branschvana i månader)

        /// <summary>
        /// Branschvana i månader, ingående månader
        /// </summary>
        private CalculateVacationResultDTO GetVacationBV()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("BV");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Calculate

            int BV = employment.GetExperienceMonths(date);

            #endregion

            #region Result

            result.Value = BV;
            result.FormulaPlain = "BV";
            result.FormulaExtracted = BV.ToString();
            result.FormulaNames = GetParameterName("BV");
            result.FormulaOrigin = "Anställning";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region ESGF (Ej semestergrundande frånvaro i timmar vid del av dag)

        /// <summary>
        /// Ej semestergrundande frånvaro i timmar vid del av dag
        /// </summary>
        private CalculateVacationResultDTO GetVacationESGF()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("ESGF");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Get absence transactions
            List<TimePayrollTransaction> absenceTransactions = GetFilteredTimePayrollTransactionForEmployeeInVacationYear().Where(t => t.IsAbsence()).ToList();

            #endregion

            #region Calculate

            decimal ESGF = 0;

            ESGF = absenceTransactions.Where(t => t.IsAbsenceNoVacation() && t.Amount.HasValue).Sum(t => t.Amount.Value);

            #endregion

            #region Result

            result.Value = ESGF;
            result.FormulaPlain = "ESGF";
            result.FormulaExtracted = ESGF.ToString();
            result.FormulaNames = GetParameterName("ESGF");
            result.FormulaOrigin = "Bruttolön transaktioner";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region ESGFKH (Ej semestergrundande frånvaro hel kalenderdag)

        /// <summary>
        /// Ej semestergrundande frånvaro hel kalenderdag
        /// </summary>
        private CalculateVacationResultDTO GetVacationESGFKH()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("ESGFKH");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            var resultAD = GetVacationAD();
            result.AddChild(resultAD);

            // Get absence transactions
            var allTransactions = GetFilteredTimePayrollTransactionForEmployeeInVacationYear();
            var absenceTransactions = allTransactions.Where(t => t.IsAbsence() && !t.RetroactivePayrollOutcomeId.HasValue).ToList();

            #endregion

            #region Calculate

            if (resultAD.Value == 0)
            {
                result.Value = 0;
                result.FormulaExtracted = "0";
                result.FormulaNames = GetParameterName("ESGFKH");
                result.FormulaOrigin = "Anställningstid = 0";
            }
            else
            {
                var absenceDatesNoVacation = new Dictionary<DateTime, bool>(); //ej semgrundande and isZeroQuantity
                var absenceDatesVacation = new List<DateTime>();               //semgrundande

                foreach (DateTime absenceDate in absenceTransactions.Select(t => t.TimeBlockDate.Date.Date).Distinct().ToList())
                {
                    // Loop through each date and get all transactions for that date
                    List<TimePayrollTransaction> transactionsByDate = allTransactions.Where(t => t.TimeBlockDate.Date == absenceDate).ToList();

                    //Exclude all transactions that should not be counted as something that generates earned vacation days
                    transactionsByDate = transactionsByDate
                        .Where(t =>
                            !t.IsFixed &&
                            !t.IsMonthlySalary() &&
                            !t.IsCentRounding &&
                            !t.IsQuantityRounding &&
                            !t.IsEmploymentTax() &&
                            !t.IsSupplementCharge() &&
                            !t.IsTax() &&
                            !t.IsNetSalary() &&
                            !t.IsBenefit() &&
                            !t.IsVacationAddition() &&
                            !t.IsVacationAdditionVariable() &&
                            !t.IsVacationAdditionOrSalaryPrepayment() &&
                            !t.IsVacationAdditionOrSalaryVariablePrepayment() &&
                            !t.IsTimeAccumulator() &&
                            !t.IsVacationCompensation() &&
                            !t.IsGrossSalaryRetroactive() &&
                            !t.IsGrossSalaryTimeWorkReduction() &&
                            !(t.IsAdded && t.IsWork())  //Risk om kunder använder tex massregen för att skapa närvaro? denna kommer exkludera all Bruttolön -lön som skapats manuellt                           
                            )
                        .ToList();

                    // If all transactions on current date is of type AbsenceNoVacation, decrease number of working days
                    if (transactionsByDate.Count == transactionsByDate.Count(t => t.IsAbsenceNoVacation()))
                        absenceDatesNoVacation.Add(absenceDate, transactionsByDate.All(t => t.Quantity == 0));
                    else
                        absenceDatesVacation.Add(absenceDate);
                }

                int ESGFKH = absenceDatesNoVacation.Count;
                if (ESGFKH > 0)
                {
                    List<DateTime> absenceDatesNoVacationZeroQuantity = absenceDatesNoVacation.Where(kv => kv.Value).Select(kv => kv.Key).ToList();
                    if (absenceDatesNoVacationZeroQuantity.Any())
                    {
                        List<TimeBlockDate> timeBlockDatesAbsenceNoVacation = TimeBlockManager.GetTimeBlockDates(entities, this.employee.EmployeeId, absenceDatesNoVacationZeroQuantity, loadTimeBlockDateDetails: true);
                        foreach (DateTime absenceDate in absenceDatesNoVacationZeroQuantity)
                        {
                            TimeBlockDate absenceTimeBlockDate = timeBlockDatesAbsenceNoVacation.FirstOrDefault(t => t.Date == absenceDate);
                            List<TimeBlockDateDetail> absenceTimeBlockDateDetails = absenceTimeBlockDate?.TimeBlockDateDetail?.Where(t => t.Type == (int)SoeTimeBlockDateDetailType.Absence).ToList();
                            if (absenceTimeBlockDateDetails.Count == 1 && absenceTimeBlockDateDetails[0].Ratio < 100)
                                ESGFKH--;
                        }
                    }
                }

                #endregion

                #region Result                

                result.Value = ESGFKH;
                result.FormulaPlain = "ESGFKH";
                result.FormulaExtracted = ESGFKH.ToString();
                result.FormulaNames = GetParameterName("ESGFKH");
                result.FormulaOrigin = "Bruttolön transaktioner";
            }

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region ATGB (Antal timmar Garantibelopp)

        /// <summary>
        /// Antal timmar Garantibelopp enligt handels
        /// </summary>
        private CalculateVacationResultDTO GetVacationATGB()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("ATGB");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            var handelsGuaranteeAmount = this.GetSysPayrollPriceAmount(actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_Vacation_HandelsGuaranteeAmount, date);

            #endregion

            #region Calculate
            result.FormulaPlain = "ATGB";
            result.FormulaNames = GetParameterName("ATGB");

            if (vacationGroupSE.UseOwnGuaranteeAmount && vacationGroupSE.OwnGuaranteeAmount > 0)
            {
                result.FormulaExtracted = Convert.ToInt32(vacationGroupSE.OwnGuaranteeAmount).ToString();
                result.FormulaOrigin = "Semesteravtal";
                result.Value = Convert.ToInt32(vacationGroupSE.OwnGuaranteeAmount);
            }
            else if (handelsGuaranteeAmount > 0)
            {
                result.FormulaExtracted = Convert.ToInt32(handelsGuaranteeAmount).ToString();
                result.FormulaNames = GetParameterName("ATGB");
                result.FormulaOrigin = "System";
                result.Value = Convert.ToInt32(handelsGuaranteeAmount);
            }
            else
            {
                result.FormulaExtracted = "1796";
                result.FormulaNames = GetParameterName("ATGB");
                result.FormulaOrigin = "Kod";
                result.Value = 1796;
            }

            #endregion

            #region Result

            AddToAlreadyCalculated(result);
            return result;

            #endregion
        }

        #endregion

        #region GB (Garantibelopp beräknat)

        // Garantibelopp semesteravtal (GS) ska omräknas till ett garantibelopp för varje anställd

        /// <summary>
        /// Garantibelopp beräknat
        /// </summary>
        private CalculateVacationResultDTO GetVacationGB()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("GB");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Check if guarantee amount is used
            if (!vacationGroupSE.UseGuaranteeAmount)
            {
                result.FormulaExtracted = "Garantibelopp används ej";
                return result;
            }

            #endregion

            #region Calculate

            CalculateVacationResultDTO resultSGT = this.GetVacationSGT();
            if (!resultSGT.Success)
                return resultSGT;
            result.AddChild(resultSGT);
            int SGT = (int)resultSGT.Value;

            CalculateVacationResultDTO resultGS = this.GetVacationGS();
            if (!resultGS.Success)
                return resultGS;
            result.AddChild(resultGS);
            decimal GS = resultGS.Value;

            CalculateVacationResultDTO resultAD = this.GetVacationAD();
            if (!resultAD.Success)
                return resultAD;
            result.AddChild(resultAD);
            int AD = (int)resultAD.Value;

            decimal GB;
            if (vacationGroupSE.GuaranteeAmountAccordingToHandels)
            {
                CalculateVacationResultDTO resultATGB = this.GetVacationATGB();
                if (!resultATGB.Success)
                    return resultATGB;
                result.AddChild(resultATGB);
                int ATGB = (int)resultATGB.Value;

                CalculateVacationResultDTO resultSGF = this.GetVacationSGF();
                if (!resultSGF.Success)
                    return resultSGF;
                result.AddChild(resultSGF);
                int SGF = (int)resultSGF.Value;
                int SGTSGF = SGT + SGF;

                if (SGTSGF > ATGB)
                {
                    GB = GS;
                    result.FormulaPlain = "GS";
                    result.FormulaExtracted = GS.ToString();
                    result.FormulaNames = GetParameterName("GS");
                }
                else if (AD != 0 && HasMoreThanLimitDaysCoherentEmployment(90)) // Three months
                {
                    GB = Decimal.Multiply(Decimal.Divide(SGTSGF, ((Decimal.Divide(AD, nbrOfDaysForVacationYear)) * ATGB)), GS);
                    if (GB < GS)
                    {
                        if (SGT + SGF != 0)
                        {
                            result.FormulaPlain = $"(SGT +  SGF) / (AD/{nbrOfDaysForVacationYear})*{ATGB} * GS";
                            result.FormulaExtracted = String.Format("({0} + {1}) / ({2})/{3})*{4} * {5}", SGT, SGF, AD, nbrOfDaysForVacationYear, ATGB, GS);
                            result.FormulaNames = String.Format("({0} + {1}) / ({2})/{3})*{4} * {5}", GetParameterName("SGT"), GetParameterName("SGF"), GetParameterName("AD"), nbrOfDaysForVacationYear, GetParameterName("ATGB"), GetParameterName("GS"));
                        }
                        else
                        {
                            var resultSSGS = this.GetVacationSSGS();
                            if (!resultSSGS.Success)
                                return resultSSGS;
                            result.AddChild(resultSSGS);
                            decimal SSGS = resultSSGS.Value;
                            GB = decimal.Round(Decimal.Multiply(SSGS, GS), 2);
                            result.FormulaPlain = $"[SGT + SGF == 0] => SYSSG * GS";
                            result.FormulaExtracted = String.Format("{0} * {1}", SSGS, GS);
                            result.FormulaNames = String.Format("{0} * {1}", GetParameterName("SSGS"), GetParameterName("GS"));
                            result.FormulaOrigin = "[SGT + SGF == 0] => SSGS * GS";
                        }
                    }
                    else
                    {
                        GB = GS;
                        result.FormulaPlain = "GS";
                        result.FormulaExtracted = GS.ToString();
                        result.FormulaNames = GetParameterName("GS");
                    }
                }
                else
                {
                    GB = 0;
                    if (AD == 0)
                    {
                        result.FormulaPlain = "AD = 0";
                        result.FormulaExtracted = AD.ToString() + " = 0";
                        result.FormulaNames = GetParameterName("AD") + " = 0";
                    }
                    else
                    {
                        result.FormulaPlain = string.Empty;
                        result.FormulaExtracted = "Sammanhängande anställning mindre än 3 månader";
                        result.FormulaNames = "Sammanhängande anställning mindre än 3 månader";
                    }
                }
            }
            else
            {
                CalculateVacationResultDTO resultSSGB = this.GetVacationSSGB();
                if (!resultSSGB.Success)
                    return resultSSGB;
                result.AddChild(resultSSGB);
                decimal SSGB = resultSSGB.Value;

                GB = Decimal.Multiply(SSGB, GS);
                result.FormulaPlain = "SSGB * GS";
                result.FormulaExtracted = String.Format("{0} * {1}", SSGB, GS);
                result.FormulaNames = String.Format("{0} * {1}", GetParameterName("SSGB"), GetParameterName("GS"));
            }

            #endregion

            #region Result

            result.Value = GB;

            AddToAlreadyCalculated(result);
            return result;

            #endregion
        }

        #endregion

        #region GBU (Garantibelopp utfyllnad)

        /// <summary>
        /// Garantibelopp utfyllnad
        /// </summary>
        private CalculateVacationResultDTO GetVacationGBU()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("GBU");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Formula information

            // Om:
            //  (SLD + ST + STRD) >= GB använd 0
            // Annars:
            //  GB - (SLD + ST + STRD)

            #endregion

            #region Prereq

            // Check if guarantee amount is used
            if (!vacationGroupSE.UseGuaranteeAmount)
            {
                result.FormulaExtracted = "Garantibelopp används ej";
                return result;
            }

            CalculateVacationResultDTO resultGB = this.GetVacationGB();
            if (!resultGB.Success)
                return resultGB;
            result.AddChild(resultGB);
            decimal GB = resultGB.Value;

            CalculateVacationResultDTO resultSL = this.GetVacationSL();
            if (!resultSL.Success)
                return resultSL;
            result.AddChild(resultSL);
            decimal SL = resultSL.Value;

            CalculateVacationResultDTO resultSLD = this.GetVacationSLD(SL);
            if (!resultSLD.Success)
                return resultSLD;
            result.AddChild(resultSLD);
            decimal SLD = resultSLD.Value;

            CalculateVacationResultDTO resultST = this.GetVacationST();
            if (!resultST.Success)
                return resultST;
            result.AddChild(resultST);
            decimal ST = resultST.Value;

            CalculateVacationResultDTO resultSTRD = this.GetVacationSTRD();
            if (!resultSTRD.Success)
                return resultSTRD;
            result.AddChild(resultSTRD);
            decimal STRD = resultSTRD.Value;

            #endregion

            #region Calculate

            decimal sum = Decimal.Add(Decimal.Add(SLD, ST), STRD);

            decimal GBU = (sum >= GB) ? 0 : Decimal.Subtract(GB, sum);

            #endregion

            #region Result

            result.FormulaPlain = "GB - (SLD + ST + STRD)";
            result.FormulaExtracted = String.Format("{0} - ({1} + {2} + {3})", GB, SLD, ST, STRD);
            result.FormulaNames = String.Format("{0} - ({1} + {2} + {3})", GetParameterName("GB"), GetParameterName("SLD"), GetParameterName("ST"), GetParameterName("STRD"));
            result.Value = GBU;

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region GS (Garantibelopp semesteravtal)

        /// <summary>
        /// Garantibelopp semesteravtal
        /// </summary>
        private CalculateVacationResultDTO GetVacationGS()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("GS");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Check if guarantee amount is used
            if (!vacationGroupSE.UseGuaranteeAmount)
            {
                result.FormulaExtracted = "Garantibelopp används ej";
                return result;
            }

            // Need ot be one day head in order for new amount to be valid at vacationyearend
            DateTime checkDate = date.AddDays(1);

            #endregion

            #region Calculate

            string info = string.Empty;
            decimal GS = this.employeeFactors == null ? EmployeeManager.GetEmployeeFactor(entities, employee.EmployeeId, TermGroup_EmployeeFactorType.GuaranteeAmount, checkDate) : EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.GuaranteeAmount, date);

            if (GS == 0)
            {
                GS = this.employeeFactors == null ? EmployeeManager.GetEmployeeFactor(entities, employee.EmployeeId, TermGroup_EmployeeFactorType.GuaranteeAmount, vacationGroup.ActualStopDate(date).Date.AddDays(1)) : EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.GuaranteeAmount, date);
            }

            if (GS != 0)
            {
                info = " Hämtat från anställd";
            }
            else
            {
                bool olderThanLimit = true;
                decimal GSFromPriceType = 0;
                decimal GSFromPriceTypeNotJuvenile = 0;
                bool accordingToHandels = vacationGroupSE.GuaranteeAmountAccordingToHandels && !vacationGroupSE.GuaranteeAmountEmployedNbrOfYears.IsNullOrEmpty();

                if (vacationGroupSE.GuaranteeAmountPerDayPriceTypeId.HasValue)
                {
                    PayrollPriceTypePeriodDTO period = base.GetPayrollPriceTypePeriodFromCache(entities, vacationGroupSE.GuaranteeAmountPerDayPriceTypeId.Value, checkDate, employee.ActorCompanyId);

                    if (period == null)
                        period = base.GetPayrollPriceTypePeriodFromCache(entities, vacationGroupSE.GuaranteeAmountPerDayPriceTypeId.Value, vacationGroup.ActualStopDate(date).Date.AddDays(1), employee.ActorCompanyId);

                    if (period != null)
                    {
                        GSFromPriceType = period.Amount;
                        GS = period.Amount;
                        GSFromPriceTypeNotJuvenile = accordingToHandels ? GS : 0;
                    }
                }

                // Check if juvenile age limit is used
                if (!accordingToHandels && vacationGroupSE.GuaranteeAmountJuvenile && vacationGroupSE.GuaranteeAmountJuvenileAgeLimit.HasValue && vacationGroupSE.GuaranteeAmountJuvenileAgeLimit.Value > 0 && vacationGroupSE.GuaranteeAmountJuvenilePerDayPriceTypeId.HasValue)
                {
                    // Get age
                    // Check beginning of month, because if the employee pass the limit during the month it will be valid.
                    int age = EmployeeManager.GetEmployeeAge(employee, new DateTime(checkDate.Year, checkDate.Month, 1));
                    if (age >= vacationGroupSE.GuaranteeAmountJuvenileAgeLimit.Value)
                    {
                        info = " Äldre än " + vacationGroupSE.GuaranteeAmountJuvenileAgeLimit.Value.ToString();
                    }
                    else
                    {
                        // Get amount from price type
                        PayrollPriceTypePeriodDTO period = base.GetPayrollPriceTypePeriodFromCache(entities, vacationGroupSE.GuaranteeAmountJuvenilePerDayPriceTypeId.Value, checkDate, employee.ActorCompanyId);
                        if (period != null)
                            GSFromPriceType = period.Amount;

                        if (period == null)
                            period = base.GetPayrollPriceTypePeriodFromCache(entities, vacationGroupSE.GuaranteeAmountJuvenilePerDayPriceTypeId.Value, vacationGroup.ActualStopDate(date).Date.AddDays(1), employee.ActorCompanyId);

                        GS = GSFromPriceType;
                        info = " Yngre än " + vacationGroupSE.GuaranteeAmountJuvenileAgeLimit.Value.ToString();
                        olderThanLimit = false;
                    }
                }
                else if (accordingToHandels && vacationGroupSE.GuaranteeAmountJuvenile && vacationGroupSE.GuaranteeAmountJuvenileAgeLimit.HasValue && vacationGroupSE.GuaranteeAmountJuvenileAgeLimit.Value > 0 && vacationGroupSE.GuaranteeAmountJuvenilePerDayPriceTypeId.HasValue)
                {
                    // Get age
                    // Check beginning of month, because if the employee pass the limit during the month it will be valid.
                    int age = EmployeeManager.GetEmployeeAge(employee, new DateTime(checkDate.Year, checkDate.Month, 1));

                    if (age >= vacationGroupSE.GuaranteeAmountJuvenileAgeLimit.Value)
                    {
                        info = " Äldre än " + vacationGroupSE.GuaranteeAmountJuvenileAgeLimit.Value.ToString();
                        // Get amount from price type
                        PayrollPriceTypePeriodDTO period = base.GetPayrollPriceTypePeriodFromCache(entities, vacationGroupSE.GuaranteeAmountJuvenilePerDayPriceTypeId.Value, checkDate, employee.ActorCompanyId);

                        if (period == null)
                            period = base.GetPayrollPriceTypePeriodFromCache(entities, vacationGroupSE.GuaranteeAmountJuvenilePerDayPriceTypeId.Value, vacationGroup.ActualStopDate(date).Date.AddDays(1), employee.ActorCompanyId);

                        if (period != null)
                            GSFromPriceType = period.Amount;

                        GS = GSFromPriceType;
                        olderThanLimit = true;
                    }
                    else
                    {
                        olderThanLimit = false;
                        GS = 0;
                    }
                }


                // Check if employed number of years limit is used
                if (olderThanLimit && vacationGroupSE.GuaranteeAmountEmployedNbrOfYears.HasValue && vacationGroupSE.GuaranteeAmountEmployedNbrOfYears.Value > 0 && vacationGroupSE.GuaranteeAmountPerDayPriceTypeId.HasValue)
                {
                    CalculateVacationResultDTO resultAD = this.GetVacationAD();
                    if (!resultAD.Success)
                        return resultAD;
                    result.AddChild(resultAD);

                    CalculateVacationResultDTO resultANSTTID = this.GetVactionANSTTID();
                    result.AddChild(resultANSTTID);
                    int ANSTTID = (int)resultANSTTID.Value;

                    bool employedLimitReached = (Decimal.Divide(ANSTTID, 365) >= vacationGroupSE.GuaranteeAmountEmployedNbrOfYears.Value);
                    if (!employedLimitReached)
                    {
                        // If limit is not reached, check if opening balance exists and add it
                        CalculateVacationResultDTO resultBV = this.GetVacationBV();
                        if (!resultBV.Success)
                            return resultBV;
                        result.AddChild(resultBV);
                        int BV = (int)resultBV.Value;

                        ANSTTID += (int)Decimal.Multiply(BV, Convert.ToDecimal(30.42));
                        employedLimitReached = (Decimal.Divide(ANSTTID, 365) >= vacationGroupSE.GuaranteeAmountEmployedNbrOfYears.Value);
                    }

                    if (employedLimitReached)
                    {
                        if (GSFromPriceTypeNotJuvenile != 0)
                            GS = GSFromPriceTypeNotJuvenile;
                        else
                            // Get amount from price type
                            GS = GSFromPriceType;
                    }
                    else
                    {
                        if (!accordingToHandels)
                            GS = 0;
                        else
                            GS = GSFromPriceType;


                    }
                }
            }

            #endregion

            #region Result

            result.Value = GS;
            result.FormulaPlain = "GS";
            result.FormulaExtracted = GS.ToString();
            result.FormulaNames = GetParameterName("GS") + info;
            result.FormulaOrigin = "Semesteravtal";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region ML (Månadslön)

        /// <summary>
        /// Månadslön
        /// </summary>
        private CalculateVacationResultDTO GetVacationML()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("ML");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Get formula ID from vacation group
            int? payrollPriceFormulaId = vacationGroupSE.MonthlySalaryFormulaId;

            bool mlMissing = false;

            if (!payrollPriceFormulaId.HasValue)
                mlMissing = true;

            #endregion

            #region Calculate

            PayrollPriceFormulaResultDTO formulaResult = new PayrollPriceFormulaResultDTO();

            if (!mlMissing)
                formulaResult = this.EvaluatePayrollPriceFormula(entities, actorCompanyId, employee, employment, null, date, null, null, payrollPriceFormulaId.Value);

            #endregion

            #region Result

            result.Value = !mlMissing ? formulaResult.Amount : 0;
            result.FormulaPlain = !mlMissing ? formulaResult.FormulaPlain : "Formel för månadslön saknas på semesteravtal";
            result.FormulaExtracted = !mlMissing ? formulaResult.FormulaExtracted : "Formel för månadslön saknas på semesteravtal";
            result.FormulaNames = !mlMissing ? formulaResult.FormulaNames : "Formel för månadslön saknas på semesteravtal";
            result.FormulaOrigin = !mlMissing ? formulaResult.FormulaOrigin : "Formel för månadslön saknas på semesteravtal";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region NF (Nettofaktor på anställd)

        /// <summary>
        /// Nettofaktor på anställd
        /// </summary>
        private CalculateVacationResultDTO GetVacationNF()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("NF");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            // Get Net factor from employee. If no factor is set, use 5
            decimal NF = this.employeeFactors == null ? EmployeeManager.GetEmployeeFactor(entities, employee.EmployeeId, TermGroup_EmployeeFactorType.Net, date) : EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.Net, date);
            if (NF == 0)
                NF = 5;

            #endregion

            #region Result

            result.Value = NF;
            result.FormulaPlain = "NF";
            result.FormulaExtracted = NF.ToString();
            result.FormulaNames = GetParameterName("NF");
            result.FormulaOrigin = "Anställd";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SB (Semester betalda dagar)

        // Avgränsningar (Anställningsdagar (AD))
        //  1. Startdatum och slutdatum på intjänandeår
        //  2. Om startdatum och/eller slutdatum på anställningen infaller inom ovan period

        /// <summary>
        /// Semester betalda dagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationSB()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SB");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Formula information

            // SB = (AD – ESGFKH) / 365(366) dgr * SR

            // AD       Anställningstid i kalenderdagar
            // ESGFKH   Ej semestergrundande frånvaro hel kalenderdag
            // SR       Semesterrätt 

            #endregion

            #region Prereq

            CalculateVacationResultDTO resultAD = this.GetVacationAD();
            if (!resultAD.Success)
                return resultAD;
            result.AddChild(resultAD);
            int AD = (int)resultAD.Value;

            CalculateVacationResultDTO resultESGFKH = this.GetVacationESGFKH();
            if (!resultESGFKH.Success)
                return resultESGFKH;
            result.AddChild(resultESGFKH);
            int ESGFKH = (int)resultESGFKH.Value;

            CalculateVacationResultDTO resultSR = this.GetVacationSR();
            if (!resultSR.Success)
                return resultSR;
            result.AddChild(resultSR);
            int SR = (int)resultSR.Value;

            #endregion

            #region Calculate

            int SB = (int)Decimal.Ceiling(Decimal.Multiply(Decimal.Divide(Decimal.Subtract(AD, ESGFKH), nbrOfDaysForVacationYear), SR));

            #endregion

            #region Result

            result.Value = SB;
            result.FormulaPlain = String.Format("(AD – ESGFKH) / {0} * SR", nbrOfDaysForVacationYear);
            result.FormulaExtracted = String.Format("({0} – {1}) / {2} * {3}", AD, ESGFKH, nbrOfDaysForVacationYear, SR);
            result.FormulaNames = String.Format("({0} – {1}) / {2} * {3}", GetParameterName("AD"), GetParameterName("ESGFKH"), nbrOfDaysForVacationYear, GetParameterName("SR"));

            AddToAlreadyCalculated(result);
            return result;

            #endregion
        }

        #endregion

        #region SB NETTO (Betalda semesterdagar vid intermittent arbetstid)

        /// <summary>
        /// Betalda semesterdagar vid intermittent arbetstid
        /// </summary>
        private CalculateVacationResultDTO GetVacationSB_NETTO()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SB_NETTO");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Formula information

            // SB * NF / 5

            #endregion

            #region Prereq

            // Get Net factor from employee
            CalculateVacationResultDTO resultNF = this.GetVacationNF();
            if (!resultNF.Success)
                return resultNF;
            result.AddChild(resultNF);
            decimal NF = resultNF.Value;

            CalculateVacationResultDTO resultSB = this.GetVacationSB();
            if (!resultSB.Success)
                return resultSB;
            result.AddChild(resultSB);
            int SB = (int)resultSB.Value;

            #endregion

            #region Calculate

            int SB_NETTO = (int)Decimal.Multiply(SB, decimal.Divide(NF, 5));

            #endregion

            #region Result

            result.Value = SB_NETTO;
            result.FormulaPlain = "SB * NF / 5";
            result.FormulaExtracted = String.Format("{0} * {1} / 5", SB, NF);
            result.FormulaNames = String.Format("{0} * {1} / 5", GetParameterName("SB"), GetParameterName("NF"));
            result.FormulaOrigin = "";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SBU (Semesterdagar uttagna)

        /// <summary>
        /// Semesterdagar uttagna
        /// </summary>
        private CalculateVacationResultDTO GetVacationSBU()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SBU");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            int SBU = 0;

            #endregion

            #region Result

            result.Value = SBU;
            result.FormulaPlain = "SBU";
            result.FormulaExtracted = SBU.ToString();
            result.FormulaNames = GetParameterName("SBU");
            result.FormulaOrigin = "";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SBURT (Rörligt semestertillägg utbetalda)

        /// <summary>
        /// Rörligt semestertillägg utbetalda
        /// </summary>
        private CalculateVacationResultDTO GetVacationSBURT()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SBURT");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            int SBURT = 0;

            #endregion

            #region Result

            result.Value = SBURT;
            result.FormulaPlain = "SBURT";
            result.FormulaExtracted = SBURT.ToString();
            result.FormulaNames = GetParameterName("SBURT");
            result.FormulaOrigin = "";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SBUT (Semestertillägg utbetalda)

        /// <summary>
        /// Semestertillägg utbetalda
        /// </summary>
        private CalculateVacationResultDTO GetVacationSBUT()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SBUT");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            int SBUT = 0;

            #endregion

            #region Result

            result.Value = SBUT;
            result.FormulaPlain = "SBUT";
            result.FormulaExtracted = SBUT.ToString();
            result.FormulaNames = GetParameterName("SBUT");
            result.FormulaOrigin = "";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SEMOP (Omräknad procentsats vid fler än 25 dagars semesterrätt)

        // Procentsats som anges enligt systempris eller enligt kollektivavtal ska räknas upp om semesterrätt är större än 25 dagar.

        /// <summary>
        /// Omräknad procentsats vid fler än 25 dagars semesterrätt
        /// </summary>
        private CalculateVacationResultDTO GetVacationSEMOP()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SEMOP");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Formula information

            // Om SR > 25:
            //  SEMOP = (SEMP / 25) * SR
            // Annars:
            //  SEMOP = SEMP

            // SEMOP = SEMOP / (NF / 5)

            #endregion

            #region Prereq

            CalculateVacationResultDTO resultSEMP = this.GetVacationSEMP();
            if (!resultSEMP.Success)
                return resultSEMP;
            result.AddChild(resultSEMP);
            decimal SEMP = resultSEMP.Value;

            CalculateVacationResultDTO resultSR = this.GetVacationSR();
            if (!resultSR.Success)
                return resultSR;
            result.AddChild(resultSR);
            int SR = (int)resultSR.Value;

            CalculateVacationResultDTO resultNF = this.GetVacationNF();
            if (!resultNF.Success)
                return resultNF;
            result.AddChild(resultNF);
            int NF = (int)resultNF.Value;

            #endregion

            #region Calculate

            decimal SEMOP;
            if (SR > 25)
            {
                SEMOP = Decimal.Multiply(Decimal.Divide(SEMP, 25), SR);
                SEMOP = Decimal.Divide(SEMOP, Decimal.Divide(NF, 5));
                result.FormulaPlain = "(SEMP / 25 * SR) / (NF / 5)";
                result.FormulaExtracted = String.Format("({0} / 25 * {1}) / ({2} / 5)", SEMP, SR, NF);
                result.FormulaNames = String.Format("({0} / 25 * {1}) / ({2} / 5)", GetParameterName("SEMP"), GetParameterName("SR"), GetParameterName("NF"));
            }
            else
            {
                SEMOP = SEMP;
                SEMOP = Decimal.Divide(SEMOP, Decimal.Divide(NF, 5));
                result.FormulaPlain = "SEMP / (NF / 5)";
                result.FormulaExtracted = String.Format("{0} / ({1} / 5)", SEMP, NF);
                result.FormulaNames = String.Format("{0} / ({1} / 5)", GetParameterName("SEMP"), GetParameterName("NF"));
            }

            #endregion

            #region Result

            result.Value = SEMOP;

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SEMP (Procentsats semesterlön)

        /// <summary>
        /// Procentsats semesterlön
        /// </summary>
        private CalculateVacationResultDTO GetVacationSEMP(bool useAddition = true)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SEMP");

            if (!useAddition)
                result.Name = "SEMPU";

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Calculate

            decimal SEMP = 0;

            switch ((TermGroup_VacationGroupCalculationType)vacationGroupSE.CalculationType)
            {
                case TermGroup_VacationGroupCalculationType.DirectPayment_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToVacationLaw:
                    // Get value from sys payroll price
                    SEMP = this.GetSysPayrollPriceAmount(actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_Vacation_VacationDayPercent, date);
                    if (useAddition)
                        SEMP += this.GetSysPayrollPriceAmount(actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_Vacation_VacationDayAdditionPercent, date);
                    result.FormulaOrigin = "Systempris";
                    break;
                case TermGroup_VacationGroupCalculationType.DirectPayment_AccordingToCollectiveAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToCollectiveAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToCollectiveAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_ABAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_VacationDayAddition:
                    // Get value from vacation group
                    SEMP = vacationGroupSE.VacationDayPercent ?? 0;

                    if (SEMP == 0 && vacationGroupSE.VacationDayPercentPriceTypeId.HasValue && vacationGroupSE.VacationDayPercentPriceTypeId != 0)
                    {
                        var pricetype = base.GetPayrollPriceTypeFromCache(entities, vacationGroupSE.VacationDayPercentPriceTypeId.Value, CacheConfig.Company(actorCompanyId));
                        if (pricetype?.Periods != null)
                        {
                            var period = pricetype.GetPeriod(date);
                            SEMP = period?.Amount ?? 0;
                        }
                    }

                    if (SEMP != 0 && useAddition)
                    {
                        var addition = vacationGroupSE.VacationDayPercent ?? 0;
                        if (addition == 0 && vacationGroupSE.VacationDayAdditionPercentPriceTypeId.HasValue && vacationGroupSE.VacationDayAdditionPercentPriceTypeId != 0)
                        {

                            var pricetype = base.GetPayrollPriceTypeFromCache(entities, vacationGroupSE.VacationDayAdditionPercentPriceTypeId.Value, CacheConfig.Company(actorCompanyId));
                            if (pricetype?.Periods != null)
                            {
                                var period = pricetype.GetPeriod(date);
                                addition = period?.Amount ?? 0;
                                SEMP = SEMP + addition;
                            }
                        }
                    }

                    SEMP = Decimal.Divide(SEMP, 100);
                    result.FormulaOrigin = "Semesteravtal";
                    break;
            }

            #endregion

            #region Result

            result.Value = SEMP;
            result.FormulaPlain = useAddition ? "SEMP" : "SEMPU";
            result.FormulaExtracted = SEMP.ToString();
            result.FormulaNames = useAddition ? GetParameterName("SEMP") : GetParameterName("SEMPU");

            AddToAlreadyCalculated(result);
            return result;

            #endregion
        }

        #endregion

        #region SEMROP (Omräknad rörlig procentsats vid fler än 25 dagars semesterrätt)

        // Procentsats som anges enligt systempris eller enligt kollektivavtal ska räknas upp om semesterrätt är större än 25 dagar.

        /// <summary>
        /// Omräknad rörlig procentsats vid fler än 25 dagars semesterrätt
        /// </summary>
        private CalculateVacationResultDTO GetVacationSEMROP()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SEMROP");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Formula information

            // Om SR > 25:
            //  SEMROP = (SEMRP / 25) * SR
            // Annars:
            //  SEMROP = SEMRP

            #endregion

            #region Prereq

            CalculateVacationResultDTO resultSEMRP = this.GetVacationSEMRP();
            if (!resultSEMRP.Success)
                return resultSEMRP;
            result.AddChild(resultSEMRP);
            decimal SEMRP = resultSEMRP.Value;

            CalculateVacationResultDTO resultSR = this.GetVacationSR();
            if (!resultSR.Success)
                return resultSR;
            result.AddChild(resultSR);
            int SR = (int)resultSR.Value;

            #endregion

            #region Calculate

            decimal SEMROP;
            if (SR > 25)
            {
                SEMROP = Decimal.Multiply(Decimal.Divide(SEMRP, 25), SR);
                result.FormulaPlain = "SEMRP / 25 * SR";
                result.FormulaExtracted = String.Format("{0} / 25 * {1}", SEMRP, SR);
                result.FormulaNames = String.Format("{0} / 25 * {1}", GetParameterName("SEMRP"), GetParameterName("SR"));
            }
            else
            {
                SEMROP = SEMRP;
                result.FormulaPlain = "SEMRP";
                result.FormulaExtracted = SEMRP.ToString();
                result.FormulaNames = GetParameterName("SEMRP");
            }

            #endregion

            #region Result

            result.Value = SEMROP;

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SEMRP (Procentsats rörlig semesterlön)

        /// <summary>
        /// Procentsats rörlig semesterlön
        /// </summary>
        private CalculateVacationResultDTO GetVacationSEMRP()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SEMRP");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Calculate

            decimal SEMRP = 0;

            switch ((TermGroup_VacationGroupCalculationType)vacationGroupSE.CalculationType)
            {
                case TermGroup_VacationGroupCalculationType.DirectPayment_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToVacationLaw:
                    // Get value from sys payroll price
                    SEMRP = this.GetSysPayrollPriceAmount(actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_Vacation_VacationDayPercent, date);
                    result.FormulaOrigin = "Systempris";
                    break;
                case TermGroup_VacationGroupCalculationType.DirectPayment_AccordingToCollectiveAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToCollectiveAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToCollectiveAgreement:
                    // Get value from vacation group
                    SEMRP = vacationGroupSE.VacationVariablePercent ?? 0;
                    if (SEMRP == 0 && vacationGroupSE.VacationVariablePercentPriceTypeId.HasValue && vacationGroupSE.VacationVariablePercentPriceTypeId != 0)
                    {
                        var pricetype = base.GetPayrollPriceTypeFromCache(entities, vacationGroupSE.VacationVariablePercentPriceTypeId.Value, CacheConfig.Company(actorCompanyId));
                        if (pricetype?.Periods != null)
                        {
                            var period = pricetype.GetPeriod(date);
                            SEMRP = period?.Amount ?? 0;
                        }
                    }

                    SEMRP = Decimal.Divide(SEMRP, 100);
                    result.FormulaOrigin = "Semesteravtal";
                    break;
            }

            #endregion

            #region Result

            result.Value = SEMRP;
            result.FormulaPlain = "SEMRP";
            result.FormulaExtracted = SEMRP.ToString();
            result.FormulaNames = GetParameterName("SEMRP");

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SEMTP (Procentsats för semestertillägg vid fler än 25 dagars semesterrätt)

        /// <summary>
        /// Procentsats för semestertillägg vid fler än 25 dagars semesterrätt
        /// </summary>
        private CalculateVacationResultDTO GetVacationSEMTP()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SEMTP");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Calculate

            decimal SEMTP = 0;

            switch ((TermGroup_VacationGroupCalculationType)vacationGroupSE.CalculationType)
            {
                case TermGroup_VacationGroupCalculationType.DirectPayment_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToVacationLaw:
                    // Get value from sys payroll price
                    SEMTP = this.GetSysPayrollPriceAmount(actorCompanyId, (int)TermGroup_SysPayrollPrice.SE_Vacation_VacationDayAdditionPercent, date);
                    result.FormulaOrigin = "Systempris";
                    break;
                case TermGroup_VacationGroupCalculationType.DirectPayment_AccordingToCollectiveAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToCollectiveAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToCollectiveAgreement:
                    // Get value from vacation group
                    SEMTP = vacationGroupSE.VacationDayAdditionPercent ?? 0;
                    if (SEMTP == 0 && vacationGroupSE.VacationDayAdditionPercentPriceTypeId.HasValue && vacationGroupSE.VacationDayAdditionPercentPriceTypeId != 0)
                    {
                        var pricetype = base.GetPayrollPriceTypeFromCache(entities, vacationGroupSE.VacationDayAdditionPercentPriceTypeId.Value, CacheConfig.Company(actorCompanyId));
                        if (pricetype?.Periods != null)
                        {
                            var period = pricetype.GetPeriod(date);
                            SEMTP = period?.Amount ?? 0;
                        }
                    }

                    SEMTP = Decimal.Divide(SEMTP, 100);
                    result.FormulaOrigin = "Semesteravtal";
                    break;
            }

            #endregion

            #region Result

            result.Value = SEMTP;
            result.FormulaPlain = "SEMTP";
            result.FormulaExtracted = SEMTP.ToString();
            result.FormulaNames = GetParameterName("SEMTP");

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SEMTOP (Omräknad procentsats för semestertillägg vid fler än 25 dagars semesterrätt)

        /// <summary>
        /// Omräknad procentsats för semestertillägg vid fler än 25 dagars semesterrätt
        /// </summary>
        private CalculateVacationResultDTO GetVacationSEMTOP()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SEMTOP");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Formula information

            // SEMTOP = SEMTP / (NF / 5)

            #endregion

            #region Prereq

            CalculateVacationResultDTO resultSEMTP = this.GetVacationSEMTP();
            if (!resultSEMTP.Success)
                return resultSEMTP;
            result.AddChild(resultSEMTP);
            decimal SEMTP = resultSEMTP.Value;

            CalculateVacationResultDTO resultNF = this.GetVacationNF();
            if (!resultNF.Success)
                return resultNF;
            result.AddChild(resultNF);
            decimal NF = resultNF.Value;

            #endregion

            #region Calculate

            decimal SEMTOP = Decimal.Divide(SEMTP, Decimal.Divide(NF, 5));

            #endregion

            #region Result

            result.Value = SEMTOP;
            result.FormulaPlain = "SEMTP / (NF / 5)";
            result.FormulaExtracted = String.Format("{0} / ({1} / 5)", SEMTP, NF);
            result.FormulaNames = String.Format("{0} / ({1} / 5)", GetParameterName("SEMTP"), GetParameterName("NF"));
            result.FormulaOrigin = "Semesteravtal och anställd";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SF (Semester betalda förskottsdagar)

        /// <summary>
        /// Semester betalda förskottsdagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationSF()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SF");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            int SF = 0;

            #endregion

            #region Result

            result.Value = SF;
            result.FormulaPlain = "SF";
            result.FormulaExtracted = SF.ToString();
            result.FormulaNames = GetParameterName("SF");
            result.FormulaOrigin = "";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SGD (Semestergrundande arbetsdagar)

        /// <summary>
        /// Semestergrundande arbetsdagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationSGD()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SGD");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Formula information

            // SGD = ARB - SGFD - ESGFKH

            #endregion

            #region Prereq

            CalculateVacationResultDTO resultARB = this.GetVacationARB();
            if (!resultARB.Success)
                return resultARB;
            result.AddChild(resultARB);
            int ARB = (int)resultARB.Value;

            CalculateVacationResultDTO resultSGFD = this.GetVacationSGFD();
            if (!resultSGFD.Success)
                return resultSGFD;
            result.AddChild(resultSGFD);
            int SGFD = (int)resultSGFD.Value;

            CalculateVacationResultDTO resultESGFKH = this.GetVacationESGFKH();
            if (!resultESGFKH.Success)
                return resultESGFKH;
            result.AddChild(resultESGFKH);
            int ESGFKH = (int)resultESGFKH.Value;

            #endregion

            #region Calculate

            int SGD = (int)(Decimal.Subtract(Decimal.Subtract(ARB, SGFD), ESGFKH));

            #endregion

            #region Result

            result.Value = SGD;
            result.FormulaPlain = "ARB - SGFD- ESGFKH";
            result.FormulaExtracted = String.Format("{0} - {1} - {2}", ARB, SGFD, ESGFKH);
            result.FormulaNames = String.Format("{0} - {1} - {2}", GetParameterName("ARB"), GetParameterName("SGFD"), GetParameterName("ESGFKH"));
            result.FormulaOrigin = "";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SGF (Semestergrundande frånvarotimmar)

        /// <summary>
        /// Semestergrundande frånvarotimmar
        /// </summary>
        private CalculateVacationResultDTO GetVacationSGF()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SGF");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            decimal SGF = 0;
            List<string> productNumbers = new List<string>();

            // Get absence transactions
            List<TimePayrollTransaction> absenceTransactions = GetFilteredTimePayrollTransactionForEmployeeInVacationYear().Where(t => t.IsAbsence()).ToList();

            #endregion

            #region Calculate

            if (this.vacationGroup.VacationGroupSE.FirstOrDefault().VacationVariablePayoutRule == (int)TermGroup_VacationGroupVacationSalaryPayoutRule.InConjunctionWithVacation)
            {
                foreach (var transaction in absenceTransactions)
                {
                    var setting = ProductManager.GetPayrollProductSetting(entities, payrollProductSettings, transaction.ProductId, employee.GetPayrollGroupId(transaction.TimeBlockDate.Date));
                    if (setting == null)
                        continue;

                    if (!payrollProductSettings.Any(s => s.PayrollProductSettingId == setting.PayrollProductSettingId))
                        payrollProductSettings.Add(setting);

                    if (setting != null && !transaction.IsAbsenceVacation() && !setting.PayrollProduct.IsAbsenceNoVacation())
                    {
                        productNumbers.Add(transaction.PayrollProduct?.Number ?? "");
                        SGF += decimal.Divide(transaction.Quantity, 60);
                    }
                }
            }
            else
            {
                foreach (var transaction in absenceTransactions)
                {
                    var setting = ProductManager.GetPayrollProductSetting(entities, payrollProductSettings, transaction.ProductId, employee.GetPayrollGroupId(transaction.TimeBlockDate.Date));
                    if (setting == null)
                        continue;

                    if (!payrollProductSettings.Any(s => s.PayrollProductSettingId == setting.PayrollProductSettingId))
                        payrollProductSettings.Add(setting);

                    if (setting != null && !transaction.IsAbsenceVacation() && !setting.PayrollProduct.IsAbsenceNoVacation())
                    {
                        productNumbers.Add(transaction.PayrollProduct?.Number ?? "");
                        SGF += decimal.Divide(transaction.Quantity, 60);
                    }
                }
            }

            productNumbers = productNumbers.Distinct().ToList();

            #endregion

            #region Result

            result.Value = SGF;
            result.FormulaPlain = "SGF";
            result.FormulaExtracted = $"{SGF} ({string.Join(",", productNumbers)})";
            result.FormulaNames = GetParameterName("SGF");
            result.FormulaOrigin = string.Join(",", productNumbers);

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SGFD (Semestergrundande frånvaro hel eller del av dag)

        /// <summary>
        /// Semestergrundande frånvaro hel eller del av dag
        /// </summary>
        private CalculateVacationResultDTO GetVacationSGFD()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SGFD");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Get absence transactions
            List<TimePayrollTransaction> absenceTransactions = GetFilteredTimePayrollTransactionForEmployeeInVacationYear().Where(t => t.IsAbsence()).ToList();

            #endregion

            #region Calculate

            // Absence transactions, vacation salary promoted. Count distinct dates
            int SGFD = absenceTransactions.Where(t => !t.IsAbsenceNoVacation() && t.Amount.HasValue).Select(t => t.TimeBlockDateId).Distinct().Count();

            #endregion

            #region Result

            result.Value = SGFD;
            result.FormulaPlain = "SGFD";
            result.FormulaExtracted = SGFD.ToString();
            result.FormulaNames = GetParameterName("SGFD");
            result.FormulaOrigin = "";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SGFDH (Semestergrundande frånvaro hela arbetsdagar)

        /// <summary>
        /// Semestergrundande frånvaro hela arbetsdagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationSGFDH()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SGFDH");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Get absence transactions
            List<TimePayrollTransaction> absenceTransactions = GetFilteredTimePayrollTransactionForEmployeeInVacationYear().Where(t => t.IsAbsence()).ToList();
            List<int> absenceDates = absenceTransactions.Where(t => !t.IsAbsenceNoVacation() && t.Amount.HasValue).Select(t => t.TimeBlockDateId).Distinct().ToList();

            // Get presence transactions
            List<TimePayrollTransaction> presenceTransactions = GetFilteredTimePayrollTransactionForEmployeeInVacationYear().Where(t => t.IsGrossSalary() && !t.IsAbsence()).ToList();
            List<int> presenceDates = presenceTransactions.Where(t => !t.IsAbsenceNoVacation() && t.Amount.HasValue).Select(t => t.TimeBlockDateId).Distinct().ToList();

            #endregion

            #region Calculate

            // All absence dates where no presence transactions exists
            int SGFDH = absenceDates.Count(d => !presenceDates.Contains(d));

            #endregion

            #region Result

            result.Value = SGFDH;
            result.FormulaPlain = "SGFDH";
            result.FormulaExtracted = SGFDH.ToString();
            result.FormulaNames = GetParameterName("SGFDH");
            result.FormulaOrigin = "";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SGFV (Värde av semestergrundande frånvaro)

        /// <summary>
        /// Värde av semestergrundande frånvaro
        /// </summary>
        private CalculateVacationResultDTO GetVacationSGFV()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SGFV");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            TermGroup_VacationGroupVacationAbsenceCalculationRule rule = (TermGroup_VacationGroupVacationAbsenceCalculationRule)vacationGroupSE.VacationAbsenceCalculationRule;

            decimal SN = 0;

            if (rule != TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual)
            {
                CalculateVacationResultDTO resultSN = GetVacationSN();
                if (!resultSN.Success)
                    return resultSN;
                result.AddChild(resultSN);
                SN = resultSN.Value;
            }

            #endregion

            #region Calculate

            decimal SGFV = 0;

            // Check calculation rule
            switch (rule)
            {
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual:
                    #region Faktisk ersättning

                    #endregion
                    break;
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerHour:
                    #region Uppräkning per timme

                    #region Formula information

                    // SGF * SN

                    // SGF      Semestergrundande frånvarotimmar
                    // SN       Snittlön

                    #endregion

                    CalculateVacationResultDTO resultSGF = GetVacationSGF();
                    if (!resultSGF.Success)
                        return resultSGF;
                    result.AddChild(resultSGF);
                    decimal SGF = resultSGF.Value;

                    SGFV = Decimal.Multiply(SGF, SN);
                    result.FormulaPlain = "SGF * SN";
                    result.FormulaExtracted = String.Format("{0} * {1}", SGF, SN);
                    result.FormulaNames = String.Format("{0} * {1}", GetParameterName("SGF"), GetParameterName("SN"));

                    #endregion
                    break;
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerDay:
                    #region Uppräkning per dag

                    #region Formula information

                    // SGD * SN

                    // SGD      Semestergrundande arbetsdagar
                    // SN       Snittlön

                    #endregion

                    CalculateVacationResultDTO resultSGD = GetVacationSGD();
                    if (!resultSGD.Success)
                        return resultSGD;
                    result.AddChild(resultSGD);
                    decimal SGD = resultSGD.Value;

                    SGFV = Decimal.Multiply(SGD, SN);
                    result.FormulaPlain = "SGD * SN";
                    result.FormulaExtracted = String.Format("{0} * {1}", SGD, SN);
                    result.FormulaNames = String.Format("{0} * {1}", GetParameterName("SGD"), GetParameterName("SN"));

                    #endregion
                    break;
            }

            #endregion

            #region Result

            result.Value = SGFV;

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }
        #endregion

        #region SGL (Semestergrundande lön)

        // Lönearter med semestergrundande belopp summeras för intjänandeåret (PayrollProductSetting.VacationSalaryPromoted).
        // För att få med korrekt semestergrundande belopp beror detta på följande inställningar:
        // BERÄKNING AV SEMESTERGRUNDANDE FRÅNVARO (VacationGroupSE.VacationAbsenceCalculationRules)
        //  - Faktisk ersättning
        //  - Uppräkning per dag
        //  - Uppräkning per timme

        // Vid faktisk ersättning eller uppräkning per timme:
        //  Summa semestergrundande transaktioner
        // Vid uppräkning per dag:
        //  Summa semestergrundande transaktioner på dagar som inte har semestergrundande frånvaro (hel eller del av dag)

        /// <summary>
        /// Semestergrundande lön
        /// </summary>
        private CalculateVacationResultDTO GetVacationSGL()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SGL");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Get payroll group
            int? payrollGroupId = employee.GetPayrollGroupId(date);
            if (!payrollGroupId.HasValue)
                return new CalculateVacationResultDTO("Löneavtal saknas på anställd", "SGL");

            #endregion

            #region Calculate

            decimal SGL = 0;
            DateTime? firstDate = null;
            DateTime? lastDate = null;
            List<string> productNumbers = new List<string>();

            // Check calculation rule
            PayrollProductSetting setting;

            TermGroup_VacationGroupVacationAbsenceCalculationRule rule = (TermGroup_VacationGroupVacationAbsenceCalculationRule)vacationGroupSE.VacationAbsenceCalculationRule;
            switch (rule)
            {
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual:
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerHour:
                    #region Faktisk ersättning / Uppräkning per timme
                    List<Employment> finalSalaryemployments = employee.GetFinalSalaryEmployments(this.fromDate, this.toDate);
                    DateTime finalDate = DateTime.MaxValue;

                    // If final salary is applied, only transactions until final salary date should be included. This is used only if there are an active employment after final salary date
                    if (this.isFinalSalary)
                    {
                        var currentEmployment = employee.GetEmployment(date);

                        if (currentEmployment != null && currentEmployment.FinalSalaryStatus == (int)SoeEmploymentFinalSalaryStatus.ApplyFinalSalary && currentEmployment.GetEndDate().HasValue && employee.GetNextEmployment(date.AddDays(1)) != null)
                            finalDate = currentEmployment.GetEndDate().Value;
                    }

                    var beginDate = DateTime.MinValue;

                    // If final salary has been applied, only transactions after final salary date should be included
                    if (finalSalaryemployments.Any())
                    {
                        var lastFinalSalaryDate = finalSalaryemployments.Max(s => s.GetEndDate());

                        if (lastFinalSalaryDate.HasValue && lastFinalSalaryDate.Value < finalDate)
                            beginDate = lastFinalSalaryDate.Value.AddDays(1);
                    }

                    foreach (AttestPayrollTransactionDTO transaction in this.attestPayrollTransactions.Where(w => w.Date <= finalDate && w.Date >= beginDate))
                    {
                        setting = ProductManager.GetPayrollProductSetting(entities, payrollProductSettings, transaction.PayrollProductId, payrollGroupId);
                        if (setting != null && !payrollProductSettings.Any(s => s.PayrollProductSettingId == setting.PayrollProductSettingId))
                            payrollProductSettings.Add(setting);

                        if (finalSalaryemployments.Any())
                        {
                            bool continueToNextTransaction = false;
                            foreach (var finalSalaryemployment in finalSalaryemployments)
                            {
                                var employmentStartDate = finalSalaryemployment.GetEmploymentDate();
                                var employmentEndDate = finalSalaryemployment.GetEndDate();
                                if (!continueToNextTransaction && CalendarUtility.IsDateInRange(transaction.Date, employmentStartDate, employmentEndDate))
                                    continueToNextTransaction = true;
                            }

                            if (continueToNextTransaction)
                                continue;
                        }

                        if (setting != null && setting.VacationSalaryPromoted && transaction.Amount.HasValue)
                        {
                            if (firstDate == null || firstDate.Value > transaction.Date)
                                firstDate = transaction.Date;

                            if (lastDate == null || lastDate.Value < transaction.Date)
                                lastDate = transaction.Date;

                            productNumbers.Add(transaction.PayrollProductNumber);
                            SGL += transaction.Amount.Value;
                        }
                    }
                    #endregion
                    break;
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerDay:
                    #region Uppräkning per dag

                    // Group transactions per day
                    foreach (int timeBlockDateId in attestPayrollTransactions.Select(t => t.TimeBlockDateId).Distinct().ToList())
                    {
                        foreach (var transaction in attestPayrollTransactions.Where(t => t.TimeBlockDateId == timeBlockDateId).ToList())
                        {
                            // Check if current day has any vacation salary promoted absence
                            // If at least one absence transaction for current day is vacation salary promoted, the whole day is not calculated
                            bool hasSalaryPromotedAbsence = false;
                            List<AttestPayrollTransactionDTO> absenceTransactions = attestPayrollTransactions.Where(t => t.TimeBlockDateId == timeBlockDateId && t.TransactionSysPayrollTypeLevel2 == (int)TermGroup_SysPayrollType.SE_GrossSalary_Absence).ToList();
                            foreach (AttestPayrollTransactionDTO absenceTransaction in absenceTransactions)
                            {
                                // Check if payroll product is vacation salary promoted (Semesterlönegrundande)
                                setting = ProductManager.GetPayrollProductSetting(entities, payrollProductSettings, absenceTransaction.PayrollProductId, payrollGroupId);
                                if (setting != null && setting.VacationSalaryPromoted)
                                {
                                    hasSalaryPromotedAbsence = true;
                                    break;
                                }
                            }
                            if (hasSalaryPromotedAbsence)
                                break;

                            // Check if payroll product is vacation salary promoted (Semesterlönegrundande)
                            setting = ProductManager.GetPayrollProductSetting(entities, payrollProductSettings, transaction.PayrollProductId, payrollGroupId);
                            if (setting != null && setting.VacationSalaryPromoted && transaction.Amount.HasValue)
                            {
                                if (firstDate == null || firstDate.Value > transaction.Date)
                                    firstDate = transaction.Date;

                                if (lastDate == null || lastDate.Value < transaction.Date)
                                    lastDate = transaction.Date;

                                productNumbers.Add(transaction.PayrollProductNumber);
                                SGL += transaction.Amount.Value;
                            }
                        }
                    }

                    #endregion
                    break;
            }

            #endregion

            #region Result

            string products = productNumbers.OrderBy(o => o).Distinct().JoinToString(",");
            string interval = string.Empty;
            if (firstDate.HasValue && lastDate.HasValue)
                interval = $" ({firstDate.Value.ToShortDateString()}- {lastDate.Value.ToShortDateString()}) ({products})";

            result.Value = SGL;
            result.FormulaPlain = "SGL";
            result.FormulaExtracted = SGL.ToString() + interval;
            result.FormulaNames = GetParameterName("SGL");
            result.FormulaOrigin = interval;

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SGR (Semestergrundande lön rörlig)

        /// <summary>
        /// Semestergrundande lön rörlig
        /// </summary>
        private CalculateVacationResultDTO GetVacationSGR()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SGR");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Formula information

            // Very simular to SGL, but with different time interval

            #endregion

            #region Prereq

            // Get payroll group
            int? payrollGroupId = employee.GetPayrollGroupId(date);
            if (!payrollGroupId.HasValue)
                return new CalculateVacationResultDTO("Löneavtal saknas på anställd", "SGR");

            #endregion

            #region Calculate

            decimal SGR = 0;
            DateTime? firstDate = null;
            DateTime? lastDate = null;
            List<string> productNumbers = new List<string>();

            // Check calculation rule
            PayrollProductSetting setting;

            TermGroup_VacationGroupVacationAbsenceCalculationRule rule = (TermGroup_VacationGroupVacationAbsenceCalculationRule)vacationGroupSE.VacationAbsenceCalculationRule;
            switch (rule)
            {
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual:
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerHour:
                    #region Faktisk ersättning / Uppräkning per timme
                    List<Employment> finalSalaryemployments = employee.GetFinalSalaryEmployments(this.fromDate, this.toDate);
                    foreach (AttestPayrollTransactionDTO transaction in this.attestPayrollTransactionsVariable)
                    {
                        setting = ProductManager.GetPayrollProductSetting(entities, payrollProductSettings, transaction.PayrollProductId, payrollGroupId);
                        if (setting != null && !payrollProductSettings.Any(s => s.PayrollProductSettingId == setting.PayrollProductSettingId))
                            payrollProductSettings.Add(setting);

                        if (!finalSalaryemployments.IsNullOrEmpty())
                        {
                            bool continueToNextTransaction = false;
                            foreach (var finalSalaryemployment in finalSalaryemployments)
                            {
                                var employmentStartDate = finalSalaryemployment.GetEmploymentDate();
                                var employmentEndDate = finalSalaryemployment.GetEndDate();
                                if (!continueToNextTransaction && CalendarUtility.IsDateInRange(transaction.Date, employmentStartDate, employmentEndDate))
                                    continueToNextTransaction = true;
                            }

                            if (continueToNextTransaction)
                                continue;
                        }

                        if (setting != null && setting.VacationSalaryPromoted && transaction.Amount.HasValue)
                        {
                            if (firstDate == null || firstDate.Value > transaction.Date)
                                firstDate = transaction.Date;

                            if (lastDate == null || lastDate.Value < transaction.Date)
                                lastDate = transaction.Date;

                            productNumbers.Add(transaction.PayrollProductNumber);
                            SGR += transaction.Amount.Value;
                        }
                    }
                    #endregion
                    break;
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerDay:
                    #region Uppräkning per dag

                    // Group transactions per day
                    foreach (int timeBlockDateId in attestPayrollTransactionsVariable.Select(t => t.TimeBlockDateId).Distinct().ToList())
                    {
                        foreach (var transaction in attestPayrollTransactionsVariable.Where(t => t.TimeBlockDateId == timeBlockDateId).ToList())
                        {
                            // Check if current day has any vacation salary promoted absence
                            // If at least one absence transaction for current day is vacation salary promoted, the whole day is not calculated
                            bool hasSalaryPromotedAbsence = false;
                            List<AttestPayrollTransactionDTO> absenceTransactions = attestPayrollTransactionsVariable.Where(t => t.TimeBlockDateId == timeBlockDateId && t.TransactionSysPayrollTypeLevel2 == (int)TermGroup_SysPayrollType.SE_GrossSalary_Absence).ToList();
                            foreach (AttestPayrollTransactionDTO absenceTransaction in absenceTransactions)
                            {
                                // Check if payroll product is vacation salary promoted (Semesterlönegrundande)
                                setting = ProductManager.GetPayrollProductSetting(entities, payrollProductSettings, absenceTransaction.PayrollProductId, payrollGroupId);
                                if (setting != null && setting.VacationSalaryPromoted)
                                {
                                    hasSalaryPromotedAbsence = true;
                                    break;
                                }
                            }
                            if (hasSalaryPromotedAbsence)
                                break;

                            // Check if payroll product is vacation salary promoted (Semesterlönegrundande)
                            setting = ProductManager.GetPayrollProductSetting(entities, payrollProductSettings, transaction.PayrollProductId, payrollGroupId);
                            if (setting != null && setting.VacationSalaryPromoted && transaction.Amount.HasValue)
                            {
                                if (firstDate == null || firstDate.Value > transaction.Date)
                                    firstDate = transaction.Date;

                                if (lastDate == null || lastDate.Value < transaction.Date)
                                    lastDate = transaction.Date;

                                productNumbers.Add(transaction.PayrollProductNumber);
                                SGR += transaction.Amount.Value;
                            }
                        }
                    }

                    #endregion
                    break;
            }

            #endregion

            #region Result
            string products = productNumbers.OrderBy(o => o).Distinct().JoinToString(",");
            string interval = string.Empty;
            if (firstDate.HasValue && lastDate.HasValue)
                interval = $" ({firstDate.Value.ToShortDateString()}- {lastDate.Value.ToShortDateString()}) ({products})";

            result.Value = SGR;
            result.FormulaPlain = "SGR";
            result.FormulaExtracted = SGR.ToString() + interval;
            result.FormulaNames = GetParameterName("SGR");
            result.FormulaOrigin = interval;

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SGT (Semestergrundande arbetstid i timmar)

        /// <summary>
        /// Semestergrundande arbetstid i timmar
        /// </summary>
        private CalculateVacationResultDTO GetVacationSGT()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SGT");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Get presence transactions
            List<TimePayrollTransaction> presenceTransactions = GetFilteredTimePayrollTransactionForEmployeeInVacationYear().Where(t => t.IsWorkTime() && !t.RetroactivePayrollOutcomeId.HasValue).ToList();

            #endregion

            #region Calculate

            // Presence hours, vacation salary promoted
            decimal SGT = Decimal.Divide(presenceTransactions.Sum(t => t.Quantity), 60);

            #endregion

            #region Result

            result.Value = SGT;
            result.FormulaPlain = "SGT";
            result.FormulaExtracted = SGT.ToString();
            result.FormulaNames = GetParameterName("SGT");
            result.FormulaOrigin = "";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SL (Semesterlön)

        /// <summary>
        /// Semesterlön
        /// </summary>
        private CalculateVacationResultDTO GetVacationSL()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SL");

            #region Prereq

            CalculateVacationResultDTO resultSGL = this.GetVacationSGL();
            if (!resultSGL.Success)
                return resultSGL;
            result.AddChild(resultSGL);
            decimal SGL = resultSGL.Value;

            #endregion

            #region Calculate

            decimal SL = 0;

            // Check calculation type
            TermGroup_VacationGroupCalculationType calculationType = (TermGroup_VacationGroupCalculationType)vacationGroupSE.CalculationType;
            switch (calculationType)
            {
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToCollectiveAgreement:
                    #region Procentuell beräkning

                    CalculateVacationResultDTO resultSEMOP = this.GetVacationSEMOP();
                    if (!resultSEMOP.Success)
                        return resultSEMOP;
                    result.AddChild(resultSEMOP);
                    decimal SEMOP = resultSEMOP.Value;

                    switch ((TermGroup_VacationGroupVacationAbsenceCalculationRule)vacationGroupSE.VacationAbsenceCalculationRule)
                    {
                        case TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual:
                            #region Faktisk ersättning

                            // SGL * SEMOP
                            SL = Decimal.Multiply(SGL, SEMOP);
                            result.FormulaPlain = "SGL * SEMOP";
                            result.FormulaExtracted = String.Format("{0} * {1}", SGL, SEMOP);
                            result.FormulaNames = String.Format("{0} * {1}", GetParameterName("SGL"), GetParameterName("SEMOP"));

                            #endregion
                            break;
                        case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerDay:
                            #region Uppräkning per dag

                            // (SGL + (SGD * (SGL / SGD)) * SEMOP
                            CalculateVacationResultDTO resultSGD = this.GetVacationSGD();
                            if (!resultSGD.Success)
                                return resultSGD;
                            result.AddChild(resultSGD);
                            int SGD = (int)resultSGD.Value;
                            if (SGD != 0)
                                SL = Decimal.Multiply(Decimal.Add(SGL, Decimal.Multiply(SGD, Decimal.Divide(SGL, SGD))), SEMOP);

                            result.FormulaPlain = "(SGL + (SGD * (SGL / SGD)) * SEMOP";
                            result.FormulaExtracted = String.Format("({0} + ({1} * ({2} / {3})) * {4}", SGL, SGD, SGL, SGD, SEMOP);
                            result.FormulaNames = String.Format("({0} + ({1} * ({2} / {3})) * {4}", GetParameterName("SGL"), GetParameterName("SGD"), GetParameterName("SGL"), GetParameterName("SGD"), GetParameterName("SEMOP"));

                            #endregion
                            break;
                        case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerHour:
                            #region Uppräkning per timme

                            // (SGL + (SGF * (SGL / SGT)) * SEMOP
                            CalculateVacationResultDTO resultSGF = this.GetVacationSGF();
                            if (!resultSGF.Success)
                                return resultSGF;
                            result.AddChild(resultSGF);
                            int SGF = (int)resultSGF.Value;

                            CalculateVacationResultDTO resultSGT = this.GetVacationSGT();
                            if (!resultSGT.Success)
                                return resultSGT;
                            result.AddChild(resultSGT);
                            int SGT = (int)resultSGT.Value;
                            if (SGT != 0)
                                SL = Decimal.Multiply(Decimal.Add(SGL, Decimal.Multiply(SGF, Decimal.Divide(SGL, SGT))), SEMOP);

                            result.FormulaPlain = "(SGL + (SGF * (SGL / SGT)) * SEMOP";
                            result.FormulaExtracted = String.Format("({0} + ({1} * ({2} / {3})) * {4}", SGL, SGF, SGL, SGT, SEMOP);
                            result.FormulaNames = String.Format("({0} + ({1} * ({2} / {3})) * {4}", GetParameterName("SGL"), GetParameterName("SGF"), GetParameterName("SGL"), GetParameterName("SGT"), GetParameterName("SEMOP"));

                            #endregion
                            break;
                    }

                    // Värde per betald semesterdag
                    CalculateVacationResultDTO resultSLD = this.GetVacationSLD(SL);
                    if (!resultSLD.Success)
                        return resultSLD;
                    result.AddChild(resultSGL);

                    if (vacationGroupSE.VacationAbsenceCalculationRule != (int)TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual && calculationType == TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToCollectiveAgreement)
                    {
                        switch ((TermGroup_VacationGroupVacationHandleRule)vacationGroupSE.VacationHandleRule)
                        {
                            case TermGroup_VacationGroupVacationHandleRule.Hours:
                                #region Värde per timme

                                CalculateVacationResultDTO resultARBT = this.GetVacationARBT(this.GetVacationSGT().Value, this.GetVacationSGF().Value);
                                if (!resultARBT.Success)
                                    return resultARBT;
                                result.AddChild(resultARBT);

                                #endregion
                                break;
                            case TermGroup_VacationGroupVacationHandleRule.Shifts:
                                #region Värde per arbetspass

                                CalculateVacationResultDTO resultARBP = this.GetVacationARBP();
                                if (!resultARBP.Success)
                                    return resultARBP;

                                #endregion
                                break;
                        }
                    }
                    break;

                #endregion
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToCollectiveAgreement:
                    #region Semestertillägg

                    resultSLD = this.GetVacationSLD(SL);
                    if (!resultSLD.Success)
                        return resultSLD;
                    result.AddChild(resultSLD);

                    CalculateVacationResultDTO resultST = this.GetVacationST();
                    if (!resultST.Success)
                        return resultST;
                    result.AddChild(resultST);

                    CalculateVacationResultDTO resultSTR = this.GetVacationSTR();
                    if (!resultSTR.Success)
                        return resultSTR;
                    result.AddChild(resultSTR);

                    break;

                #endregion
                case TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_ABAgreement:
                    #region AB-avtal

                    resultSLD = this.GetVacationSLD(SL);
                    if (!resultSLD.Success)
                        return resultSLD;

                    #endregion
                    break;
            }

            #endregion

            #region Result

            result.Value = SL;

            return result;

            #endregion
        }

        #endregion

        #region SLB (Beräknad semesterlön)

        /// <summary>
        /// Beräknad semesterlön
        /// </summary>
        private CalculateVacationResultDTO GetVacationSLB()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SLB");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            decimal SGFV = 0;

            TermGroup_VacationGroupVacationAbsenceCalculationRule rule = (TermGroup_VacationGroupVacationAbsenceCalculationRule)vacationGroupSE.VacationAbsenceCalculationRule;
            if (rule != TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual)
            {
                CalculateVacationResultDTO resultSGFV = this.GetVacationSGFV();
                if (!resultSGFV.Success)
                    return resultSGFV;
                result.AddChild(resultSGFV);
                SGFV = resultSGFV.Value;
            }

            CalculateVacationResultDTO resultSGL = this.GetVacationSGL();
            if (!resultSGL.Success)
                return resultSGL;
            result.AddChild(resultSGL);
            decimal SGL = resultSGL.Value;

            CalculateVacationResultDTO resultSEMOP = this.GetVacationSEMOP();
            if (!resultSEMOP.Success)
                return resultSEMOP;
            result.AddChild(resultSEMOP);
            decimal SEMOP = resultSEMOP.Value;

            #endregion

            #region Calculate

            decimal SLB = 0;

            // Check calculation rule
            switch (rule)
            {
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual:
                    #region Faktisk ersättning

                    #region Formula information

                    // SGL * SEMOP

                    // SGL      Semestergrundande lön
                    // SEMOP    Omräknad procentsats vid fler än 25 dagars semesterrätt

                    #endregion

                    SLB = Decimal.Multiply(SGL, SEMOP);
                    result.FormulaPlain = "SGL * SEMOP";
                    result.FormulaExtracted = String.Format("{0} * {1})", SGL, SEMOP);
                    result.FormulaNames = String.Format("{0} * {1})", GetParameterName("SGL"), GetParameterName("SEMOP"));

                    #endregion
                    break;
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerHour:
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerDay:
                    #region Uppräkning per timme / Uppräkning per dag

                    #region Formula information

                    // (SGL + SGFV) * SEMOP

                    // SGL      Semestergrundande lön
                    // SGFV     Värde av semestergrundande frånvaro
                    // SEMOP    Omräknad procentsats vid fler än 25 dagars semesterrätt

                    #endregion

                    SLB = Decimal.Multiply(Decimal.Add(SGL, SGFV), SEMOP);
                    result.FormulaPlain = "(SGL + SGFV) * SEMOP";
                    result.FormulaExtracted = String.Format("({0} + {1}) * {2})", SGL, SGFV, SEMOP);
                    result.FormulaNames = String.Format("({0} + {1}) * {2})", GetParameterName("SGL"), GetParameterName("SGFV"), GetParameterName("SEMOP"));

                    #endregion
                    break;
            }

            #endregion

            #region Result

            result.Value = SLB;

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SLD (Semesterlön per betald semesterdag)

        /// <summary>
        /// Semesterlön per betald semesterdag
        /// </summary>
        private CalculateVacationResultDTO GetVacationSLD(decimal SL, decimal SSG = 0, int year = 1, bool? isEarningYearInput = null)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SLD");
            #region Calculate

            decimal SLD = 0;
            bool? isEarningYear = isEarningYearInput;
            bool isEarningYearSetFromInput = isEarningYearInput.HasValue;

            if (!isEarningYear.HasValue)
            {
                if (year == 0)
                {
                    isEarningYear = true;
                }
                else
                {
                    if (!vacationGroupSE.IsEarningYearIsVacationYear() && year == 1)
                        isEarningYear = true;
                }

                if (!isEarningYear.HasValue)
                    isEarningYear = false;
            }


            // Check calculation type

            TermGroup_VacationGroupCalculationType calculationType = (TermGroup_VacationGroupCalculationType)vacationGroupSE.CalculationType;
            switch (calculationType)
            {
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToCollectiveAgreement:
                    if (SSG == 0)
                    {
                        #region Procentuell beräkning

                        // Värde per betald semesterdag
                        CalculateVacationResultDTO resultSB = this.GetVacationSB();
                        if (!resultSB.Success)
                            return resultSB;
                        result.AddChild(resultSB);
                        int SB = (int)resultSB.Value;

                        if (SB != 0)
                        {
                            SLD = Decimal.Divide(SL, SB);
                            result.FormulaPlain = "SL / SB";
                            result.FormulaExtracted = String.Format("{0} / {1}", SL, SB);
                            result.FormulaNames = String.Format("{0} / {1}", GetParameterName("SL"), GetParameterName("SB"));
                        }

                        if (calculationType == TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToCollectiveAgreement)
                        {
                            // Kontroll garantibelopp
                            CalculateVacationResultDTO resultGB = this.GetVacationGB();
                            if (!resultGB.Success)
                                return resultGB;
                            result.AddChild(resultGB);

                            decimal GB = resultGB.Value;
                            if (GB > SLD)
                            {
                                SLD = GB;
                                result.FormulaPlain = "GB";
                                result.FormulaExtracted = GB.ToString();
                                result.FormulaNames = GetParameterName("GB");
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        result.Value = this.employeeFactors == null ? EmployeeManager.GetEmployeeFactor(entities, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationDayPercent, date) : EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationDayPercent, date);
                        result.FormulaPlain = "SLD";
                        result.FormulaExtracted = result.Value.ToString();
                        result.FormulaNames = GetParameterName("SLD") + (year != 1 ? "S" + year.ToString() : string.Empty);

                        return result;
                    }
                    break;

                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToCollectiveAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_ABAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_VacationDayAddition:
                    #region Semestertillägg

                    CalculateVacationResultDTO resultML = this.GetVacationML();
                    if (!resultML.Success)
                        return resultML;
                    result.AddChild(resultML);
                    decimal ML = resultML.Value;

                    var useAddition = true;

                    if (vacationGroupSE.IsEarningYearIsVacationYear() && isEarningYear.Value && vacationGroupSE.VacationSalaryPayoutRule == (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation)
                    {
                        var vacationSalaryPayoutMonthDate = vacationGroupSE.GetActualVacationSalaryPayoutMonthDate(date);
                        if (vacationSalaryPayoutMonthDate < date)
                            useAddition = false;
                    }
                    else if (!vacationGroupSE.IsEarningYearIsVacationYear() && !isEarningYear.Value && vacationGroupSE.VacationSalaryPayoutRule == (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation)
                    {
                        useAddition = false;
                    }

                    CalculateVacationResultDTO resultSEMP = this.GetVacationSEMP(useAddition);
                    if (!resultSEMP.Success)
                        return resultSEMP;
                    result.AddChild(resultSEMP);
                    decimal SEMP = resultSEMP.Value;

                    decimal STRD = 0;

                    if (vacationGroupSE.VacationVariablePayoutRule != (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation)
                    {
                        if (year < 0)
                        {
                            CalculateVacationResultDTO resultSTRDSaved = this.GetVacationSTRDSavedYears(year);

                            if (!resultSTRDSaved.Success)
                                return resultSTRDSaved;
                            result.AddChild(resultSTRDSaved);
                            STRD = resultSTRDSaved.Value;
                        }
                        else
                        {
                            if (isEarningYearSetFromInput && isEarningYear.HasValue && !isEarningYear.Value && year == 1)
                            {
                                //Det verkar som kombinationen year = 1 och isEarningYearInput = false endast anropas för de som INTE har sammanfallande semesterår och intjänandeår.
                                //Och man vill räkna ut SLDB, dvs värdet för betalada dagar.
                                // Vi skickar år 1, vilket i skrivande stund känns fel faktiskt, det borde vara 0 år så att vi hämtar ut värdet för aktuellt år.
                                // 1 år blir inte fel så längde det inte finns upplagda rörliga tillägg framåt. (Kolla detta med RD!)

                                CalculateVacationResultDTO resultSTRDSaved = this.GetVacationSTRDSavedYears(year);
                                resultSTRDSaved.SRTDAdded = true;
                                if (!resultSTRDSaved.Success)
                                    return resultSTRDSaved;
                                result.AddChild(resultSTRDSaved);
                                STRD = resultSTRDSaved.Value;
                            }
                            else
                            {
                                //Hämta rörligt semesterdagstillägg för intjänande år
                                var resultSTRD = this.GetVacationSTRD();
                                if (!resultSTRD.Success)
                                    return resultSTRD;
                                result.AddChild(resultSTRD);
                                STRD = resultSTRD.Value;
                            }

                        }
                    }
                    else
                    {
                        if (isEarningYear.Value)
                        {
                            if (vacationGroupSE.IsEarningYearIsVacationYear())
                            {
                                var vacationVariablePayoutMonthDate = vacationGroupSE.GetActualVacationVariablePayoutMonthDate(date);

                                if (vacationVariablePayoutMonthDate > date)
                                {
                                    var resultSTRD = this.GetVacationSTRD();
                                    if (!resultSTRD.Success)
                                        return resultSTRD;
                                    result.AddChild(resultSTRD);
                                    STRD = resultSTRD.Value;
                                }
                            }
                            else
                            {
                                var resultSTRD = this.GetVacationSTRD();
                                if (!resultSTRD.Success)
                                    return resultSTRD;
                                result.AddChild(resultSTRD);
                                STRD = resultSTRD.Value;
                            }
                        }
                        else if (!vacationGroupSE.IsEarningYearIsVacationYear() && year == 1) // payed days?
                        {
                            var salaryPayoutMonthDate = vacationGroupSE.GetActualVacationSalaryPayoutMonthDate(date);
                            if (salaryPayoutMonthDate > date)
                            {
                                var resultSEMP2 = this.GetVacationSEMP(true);
                                if (!resultSEMP2.Success)
                                    return resultSEMP2;
                                result.AddChild(resultSEMP2);
                                SEMP = resultSEMP2.Value;
                            }
                        }
                    }


                    CalculateVacationResultDTO resultNF = this.GetVacationNF();
                    if (!resultNF.Success)
                        return resultNF;
                    result.AddChild(resultNF);
                    decimal NF = resultNF.Value;

                    if (SSG == 0 || calculationType == TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_ABAgreement)
                    {
                        CalculateVacationResultDTO resultSSG;
                        if (calculationType != TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_ABAgreement)
                            resultSSG = this.GetVacationSSGS();  // Summa över intjänandeåret
                        else
                            resultSSG = this.GetVacationSSGA(); // Aktuell
                        if (!resultSSG.Success)
                            return resultSSG;
                        result.AddChild(resultSSG);
                        SSG = resultSSG.Value;
                    }
                    else
                    {

                        #region Fix

                        if (SSG > 1)
                        {
                            SSG = Decimal.Divide(SSG, 100);
                        }

                        #endregion

                        result.AddChild(new CalculateVacationResultDTO()
                        {
                            Value = SSG,
                            FormulaPlain = "SSG",
                            FormulaExtracted = SSG.ToString(),
                            FormulaNames = GetParameterName("SSG"),
                            FormulaOrigin = "Anställdauppgifter",
                        });
                    }

                    #region Fix

                    if (SSG > 1)
                    {
                        SSG = Decimal.Divide(SSG, 100);
                    }

                    #endregion
                    SLD = Decimal.Multiply(Decimal.Multiply(Decimal.Multiply(ML, SEMP), SSG), (Decimal.Divide(5, NF)));

                    string SempName = !string.IsNullOrEmpty(resultSEMP?.Name) ? resultSEMP.Name : "SEMP";
                    result.FormulaPlain = "ML * " + SempName + " * SSG * 5 / NF";
                    result.FormulaExtracted = String.Format("{0} * {1} * {2} * 5 / {3}", ML, SEMP, SSG, NF);
                    result.FormulaNames = String.Format("{0} * {1} * {2} * 5 / {3}", GetParameterName("ML"), GetParameterName(SempName), GetParameterName("SSG"), GetParameterName("NF"));
                    if (STRD != 0)
                    {
                        SLD = SLD + STRD;
                        result.FormulaPlain = "(" + result.FormulaPlain + ") + STRD";
                        result.FormulaExtracted = "(" + result.FormulaPlain + ") + " + STRD.ToString();
                        result.FormulaPlain = "(" + result.FormulaNames + ") + " + GetParameterName("STRD");
                    }

                    break;

                    #endregion
            }

            #endregion

            #region Result

            result.Value = SLD;

            if (isEarningYear.Value)
            {
                var clone = result.CloneDTO();
                result.AddChild(clone);
                result.Name = result.Name + "I";
            }

            return result;

            #endregion
        }

        private CalculateVacationResultDTO GetVacationSLDU(decimal SSG)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SLDU");

            #region Calculate

            decimal SLDU = 0;

            // Check calculation type
            TermGroup_VacationGroupCalculationType calculationType = (TermGroup_VacationGroupCalculationType)vacationGroupSE.CalculationType;
            switch (calculationType)
            {
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToCollectiveAgreement:
                    #region Procentuell beräkning

                    // Värde per betald semesterdag
                    CalculateVacationResultDTO resultSB = this.GetVacationSB();
                    if (!resultSB.Success)
                        return resultSB;
                    result.AddChild(resultSB);

                    if (calculationType == TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_PercentCalculation_AccordingToCollectiveAgreement)
                    {
                        // Kontroll garantibelopp
                        CalculateVacationResultDTO resultGB = this.GetVacationGB();
                        if (!resultGB.Success)
                            return resultGB;
                        result.AddChild(resultGB);

                        decimal GB = resultGB.Value;
                        if (GB > SLDU)
                        {
                            SLDU = GB;
                            result.FormulaPlain = "GB";
                            result.FormulaExtracted = GB.ToString();
                            result.FormulaNames = GetParameterName("GB");
                        }
                    }
                    break;
                #endregion
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToCollectiveAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_ABAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_VacationDayAddition:
                    #region Semestertillägg

                    CalculateVacationResultDTO resultML = this.GetVacationML();
                    if (!resultML.Success)
                        return resultML;
                    result.AddChild(resultML);
                    decimal ML = resultML.Value;

                    CalculateVacationResultDTO resultSEMPU = this.GetVacationSEMP(false);
                    if (!resultSEMPU.Success)
                        return resultSEMPU;
                    result.AddChild(resultSEMPU);
                    decimal SEMPU = resultSEMPU.Value;

                    CalculateVacationResultDTO resultNF = this.GetVacationNF();
                    if (!resultNF.Success)
                        return resultNF;
                    result.AddChild(resultNF);
                    decimal NF = resultNF.Value;

                    #region Fix

                    if (SSG > 1)
                    {
                        SSG = Decimal.Divide(SSG, 100);
                    }

                    #endregion

                    SLDU = Decimal.Multiply(Decimal.Multiply(Decimal.Multiply(ML, SEMPU), SSG), (Decimal.Divide(5, NF)));

                    result.FormulaPlain = "ML * SEMPU * SSG * 5 / NF";
                    result.FormulaExtracted = String.Format("{0} * {1} * {2} * 5 / {3}", ML, SEMPU, SSG, NF);
                    result.FormulaNames = String.Format("{0} * {1} * {2} * 5 / {3}", GetParameterName("ML"), GetParameterName("SEMPU"), GetParameterName("SSG"), GetParameterName("NF"));

                    break;

                    #endregion
            }

            #endregion

            #region Result

            result.Value = SLDU;

            return result;

            #endregion
        }

        private CalculateVacationResultDTO GetVacationSLDI(decimal SL, decimal SSG)
        {
            var result = vacationGroupSE.IsEarningYearIsVacationYear() ? GetVacationSLD(SL, SSG, 0, true) : GetVacationSLD(SL, SSG, 1, true);
            result.Name = "SLDI";
            return result;
        }

        private CalculateVacationResultDTO GetVacationSLDB(decimal SL, decimal SSG)
        {
            var result = vacationGroupSE.IsEarningYearIsVacationYear() ? GetVacationSLD(SL, SSG, 0, true) : GetVacationSLD(SL, SSG, 1, false);
            result.Name = "SLDB";
            return result;
        }

        private CalculateVacationResultDTO GetVacationSLDS1(decimal SL, decimal SSG)
        {
            var result = GetVacationSLD(SL, SSG, -1);
            result.Name = "SLDS1";
            return result;
        }

        private CalculateVacationResultDTO GetVacationSLDS2(decimal SL, decimal SSG)
        {
            var result = GetVacationSLD(SL, SSG, -2);
            result.Name = "SLDS2";
            return result;
        }

        private CalculateVacationResultDTO GetVacationSLDS3(decimal SL, decimal SSG)
        {
            var result = GetVacationSLD(SL, SSG, -3);
            result.Name = "SLDS3";
            return result;
        }

        private CalculateVacationResultDTO GetVacationSLDS4(decimal SL, decimal SSG)
        {
            var result = GetVacationSLD(SL, SSG, -4);
            result.Name = "SLDS4";
            return result;
        }
        private CalculateVacationResultDTO GetVacationSLDS5(decimal SL, decimal SSG)
        {
            var result = GetVacationSLD(SL, SSG, -5);
            result.Name = "SLDS5";
            return result;
        }

        private CalculateVacationResultDTO GetVacationSLDSF(decimal SL, decimal SSG)
        {
            var result = GetVacationSLD(SL, SSG, -6);
            result.Name = "SLDSF";
            return result;
        }

        #endregion

        #region SN (Snittlön)

        /// <summary>
        /// Snittlön
        /// </summary>
        private CalculateVacationResultDTO GetVacationSN()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SN");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            TermGroup_VacationGroupVacationAbsenceCalculationRule rule = (TermGroup_VacationGroupVacationAbsenceCalculationRule)vacationGroupSE.VacationAbsenceCalculationRule;

            decimal SGL = 0;
            decimal TL = 0;
            CalculateVacationResultDTO resultTL = null;

            if (rule != TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual)
            {
                CalculateVacationResultDTO resultSGL = GetVacationSGL();
                if (!resultSGL.Success)
                    return resultSGL;
                result.AddChild(resultSGL);
                SGL = resultSGL.Value;

                resultTL = GetVacationTL();
                if (!resultTL.Success)
                    return resultTL;
                TL = resultTL.Value;
            }

            #endregion

            #region Calculate

            decimal SN = 0;

            // Check calculation rule
            switch (rule)
            {
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual:
                    #region Faktisk ersättning

                    #endregion
                    break;
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerHour:
                    #region Uppräkning per timme

                    #region Formula information

                    // Om:
                    //  SGL = 0 använd TL
                    // Annars:
                    //  SGL / (ARBT - SGF - ESGF)

                    // SGL      Semestergrundande lön
                    // TL       Timlön
                    // ARBT     Schemalagda timmar
                    // SGF      Semestergrundande frånvarotimmar
                    // ESGF     Ej semestergrundande frånvaro i timmar vid del av dag

                    #endregion

                    if (SGL == 0)
                    {
                        SN = TL;
                        result.FormulaPlain = "TL";
                        result.FormulaExtracted = String.Format("{0}", TL);
                        result.FormulaNames = GetParameterName("TL");
                        result.AddChild(resultTL);
                    }
                    else
                    {
                        CalculateVacationResultDTO resultARBT = GetVacationARBT(this.GetVacationSGT().Value, this.GetVacationSGF().Value);
                        if (!resultARBT.Success)
                            return resultARBT;
                        result.AddChild(resultARBT);
                        decimal ARBT = resultARBT.Value;

                        CalculateVacationResultDTO resultSGF = GetVacationSGF();
                        if (!resultSGF.Success)
                            return resultSGF;
                        result.AddChild(resultSGF);
                        decimal SGF = resultSGF.Value;

                        CalculateVacationResultDTO resultESGF = GetVacationESGF();
                        if (!resultESGF.Success)
                            return resultESGF;
                        result.AddChild(resultESGF);
                        decimal ESGF = resultESGF.Value;

                        SN = Decimal.Divide(SGL, (Decimal.Subtract(Decimal.Subtract(ARBT, SGF), ESGF)));
                        result.FormulaPlain = "SGL / (ARBT - SGF - ESGF)";
                        result.FormulaExtracted = String.Format("{0} / ({1} - {2} - {3})", SGL, ARBT, SGF, ESGF);
                        result.FormulaNames = String.Format("{0} / ({1} - {2} - {3})", GetParameterName("SGL"), GetParameterName("ARBT"), GetParameterName("SGF"), GetParameterName("ESGF"));
                    }

                    #endregion
                    break;
                case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerDay:
                    #region Uppräkning per dag

                    #region Formula information

                    // Om:
                    //  SGL = 0 använd TL
                    // Annars:
                    //  SGL / (ARB - SGFDH - ESGFKH)

                    // SGL      Semestergrundande lön
                    // TL       Timlön
                    // ARB      Schemalagda arbetsdagar
                    // SGFDH    Semestergrundande frånvaro hela arbetsdagar
                    // ESGFKH   Ej semestergrundande frånvaro hel kalenderdag

                    #endregion

                    if (SGL == 0)
                    {
                        SN = TL;
                        result.FormulaPlain = "TL";
                        result.FormulaExtracted = String.Format("{0}", TL);
                        result.FormulaNames = GetParameterName("TL");
                        result.AddChild(resultTL);
                    }
                    else
                    {
                        CalculateVacationResultDTO resultARB = GetVacationARB();
                        if (!resultARB.Success)
                            return resultARB;
                        result.AddChild(resultARB);
                        decimal ARB = resultARB.Value;

                        CalculateVacationResultDTO resultSGFDH = GetVacationSGFDH();
                        if (!resultSGFDH.Success)
                            return resultSGFDH;
                        result.AddChild(resultSGFDH);
                        decimal SGFDH = resultSGFDH.Value;

                        CalculateVacationResultDTO resultESGFKH = GetVacationESGFKH();
                        if (!resultESGFKH.Success)
                            return resultESGFKH;
                        result.AddChild(resultESGFKH);
                        decimal ESGFKH = resultESGFKH.Value;

                        SN = Decimal.Divide(SGL, (Decimal.Subtract(Decimal.Subtract(ARB, SGFDH), ESGFKH)));
                        result.FormulaPlain = "SGL / (ARB - SGFDH - ESGFKH)";
                        result.FormulaExtracted = String.Format("{0} / ({1} - {2} - {3})", SGL, ARB, SGFDH, ESGFKH);
                        result.FormulaNames = String.Format("{0} / ({1} - {2} - {3})", GetParameterName("SGL"), GetParameterName("ARB"), GetParameterName("SGFDH"), GetParameterName("ESGFKH"));
                    }

                    #endregion
                    break;
            }

            #endregion

            #region Result

            result.Value = SN;
            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SO (Semester obetalda dagar)

        // Semesterrätt minus betalda dagar.

        /// <summary>
        /// Semester obetalda dagar
        /// </summary>
        private CalculateVacationResultDTO GetVacationSO()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SO");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Formula information

            // SO = SR - SB

            // SR       Semesterrätt
            // SB       Semester betalda dagar

            #endregion

            #region Prereq

            CalculateVacationResultDTO resultSR = this.GetVacationSR();
            if (!resultSR.Success)
                return resultSR;
            result.AddChild(resultSR);
            int SR = (int)resultSR.Value;

            CalculateVacationResultDTO resultSB = this.GetVacationSB();
            if (!resultSB.Success)
                return resultSB;
            result.AddChild(resultSB);
            int SB = (int)resultSB.Value;

            #endregion

            #region Calculate

            int SO = (int)Decimal.Subtract(SR, SB);

            #endregion

            #region Result

            result.Value = SO;
            result.FormulaPlain = "SR - SB";
            result.FormulaExtracted = String.Format("{0} - {1}", SR, SB);
            result.FormulaNames = String.Format("{0} - {1}", GetParameterName("SR"), GetParameterName("SB"));

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SR (Semesterrätt)

        /// <summary>
        /// Semesterrätt
        /// </summary>
        private CalculateVacationResultDTO GetVacationSR()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SR");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Get vacation days on employee
            decimal SR = 0;
            result.FormulaPlain = "SR";
            bool calculateHours = (vacationGroupSE != null && vacationGroupSE.VacationHandleRule == (int)TermGroup_VacationGroupVacationHandleRule.Hours);

            if (calculateHours)
            {
                int hours = this.employeeFactors == null ? (int)EmployeeManager.GetEmployeeFactor(entities, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationHoursPaid, date) : (int)EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationHoursPaid, date);

                if (hours != 0)
                {
                    var hoursPerDay = GetVacationFPD();

                    if (hoursPerDay.Value != 0)
                    {
                        result.AddChild(hoursPerDay);
                        SR = decimal.Divide(hours, hoursPerDay.Value);
                        result.FormulaPlain = $"SR {hours}/{hoursPerDay}";
                    }
                }
            }

            if (SR == 0)
                SR = this.employeeFactors == null ? (int)EmployeeManager.GetEmployeeFactor(entities, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationDaysPaidByLaw, date) : (int)EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationDaysPaidByLaw, date);


            #endregion

            #region Additional days based on Age

            int additionalDays = 0;
            if (this.vacationGroupSE != null && this.vacationGroupSE.UseAdditionalVacationDays && this.vacationGroupSE.NbrOfAdditionalVacationDays > 0)
            {
                int age = EmployeeManager.GetEmployeeAge(employee, toDate);
                if (age != 0 && age >= this.vacationGroupSE.AdditionalVacationDaysFromAge1)
                {
                    additionalDays = this.vacationGroupSE.AdditionalVacationDays1 ?? 0;
                    if (age >= this.vacationGroupSE.AdditionalVacationDaysFromAge2)
                        additionalDays = this.vacationGroupSE.AdditionalVacationDays2 ?? 0;

                    if (age >= this.vacationGroupSE.AdditionalVacationDaysFromAge3)
                        additionalDays = this.vacationGroupSE.AdditionalVacationDays3 ?? 0;
                }
            }

            #endregion

            #region Calculate

            result.Value = SR;

            result.FormulaNames = GetParameterName("SR");

            // No vacation days specified on employee
            // Get vacation days from vacation group
            if (SR == 0)
            {
                if (vacationGroup.VacationDaysPaidByLaw.HasValue)
                {
                    result.Value = vacationGroup.VacationDaysPaidByLaw.Value;
                    result.FormulaOrigin = "Semesteravtal";
                }
            }
            else
                result.FormulaOrigin = "Anställd";

            if (additionalDays != 0)
            {
                result.FormulaPlain = "SR+ÅTSR";
                result.Value = result.Value + additionalDays;
                result.FormulaNames = GetParameterName("SR") + "+" + GetParameterName("ÅTSR");
            }

            #endregion

            #region Result

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SSG (Sysselsättningsgrad (under intjänandeåret))

        /// <summary>
        /// Sysselsättningsgrad (under intjänandeåret)
        /// </summary>
        private CalculateVacationResultDTO GetVacationSSGS()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SSG");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            // Loop all employments for specified vacation year
            List<Tuple<int, decimal>> ssgs = new List<Tuple<int, decimal>>();
            List<Employment> employments = employee.GetEmployments(fromDate, toDate);

            foreach (Employment emp in employments.Where(w => !w.HasAppliedFinalSalaryOrManually()))
            {
                var startdate = CalendarUtility.GetLatestDate(emp.DateFrom, fromDate);
                var stopDate = CalendarUtility.GetEarliestDate(emp.GetEndDate() ?? toDate, toDate);

                foreach (var empDate in CalendarUtility.GetDates(startdate, stopDate))
                {
                    decimal percent = emp.GetPercent(empDate);
                    if (percent != 0)
                    {
                        Tuple<int, decimal> tuple = Tuple.Create(1, percent);
                        ssgs.Add(tuple);
                    }
                }
            }

            decimal SSG = 0;

            if (ssgs.Any())
            {
                // Calculate average SSG
                decimal totalSSG = 0;
                foreach (var tuple in ssgs)
                {
                    totalSSG += Decimal.Multiply(tuple.Item1, tuple.Item2);
                }

                SSG = Decimal.Divide(Decimal.Divide(totalSSG, ssgs.Select(s => s.Item1).Sum()), 100);
            }

            #endregion

            #region Result

            result.Value = SSG;
            result.FormulaPlain = "SSG";
            result.FormulaExtracted = SSG.ToString();
            result.FormulaNames = GetParameterName("SSG");
            result.FormulaOrigin = "Anställning";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SSGA (Aktuell sysselsättningsgrad)

        /// <summary>
        /// Aktuell sysselsättningsgrad
        /// </summary>
        private CalculateVacationResultDTO GetVacationSSGA()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SSGA");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            decimal SSGA = employment.GetPercent(date);
            SSGA = Decimal.Divide(SSGA, 100);

            #endregion

            #region Result

            result.Value = SSGA;
            result.FormulaPlain = "SSGA";
            result.FormulaExtracted = SSGA.ToString();
            result.FormulaNames = GetParameterName("SSGA");
            result.FormulaOrigin = "Anställning";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region SSGB (Beräknad sysselsättningsgrad)

        /// <summary>
        /// Beräknad sysselsättningsgrad
        /// </summary>
        private CalculateVacationResultDTO GetVacationSSGB()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("SSGB");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            // Check if guarantee amount is used
            if (!vacationGroupSE.UseGuaranteeAmount)
            {
                result.FormulaExtracted = "Garantibelopp används ej";
                return result;
            }

            #region Formula information

            // (ARBT + SGF) / BARB
            // Om större än 1, använd 1

            #endregion


            if (vacationGroupSE.GuaranteeAmountAccordingToHandels)
            {
                #region Prereq

                CalculateVacationResultDTO resultARBT = this.GetVacationARBT(this.GetVacationSGT().Value, this.GetVacationSGF().Value);
                if (!resultARBT.Success)
                    return resultARBT;
                result.AddChild(resultARBT);
                decimal ARBT = resultARBT.Value;

                CalculateVacationResultDTO resultSGF = this.GetVacationSGF();
                if (!resultSGF.Success)
                    return resultSGF;
                result.AddChild(resultSGF);
                decimal SGF = resultSGF.Value;

                CalculateVacationResultDTO resultBARB = this.GetVacationBARB();
                if (!resultBARB.Success)
                    return resultBARB;
                result.AddChild(resultBARB);
                decimal BARB = resultBARB.Value;

                #endregion

                #region Calculate

                decimal SSGB = BARB != 0 ? Decimal.Divide(Decimal.Add(ARBT, SGF), BARB) : 0;
                if (SSGB > 1)
                    SSGB = 1;

                #endregion

                #region Result

                result.Value = SSGB;
                result.FormulaPlain = "(ARBT + SGF) / BARB";
                result.FormulaExtracted = String.Format("({0} + {1}) / {2}", ARBT, SGF, BARB);
                result.FormulaNames = String.Format("({0} + {1}) / {2}", GetParameterName("ARBT"), GetParameterName("SGF"), GetParameterName("BARB"));
                result.FormulaOrigin = "";

                AddToAlreadyCalculated(result);

                return result;

                #endregion
            }

            else
            {
                #region Prereq

                CalculateVacationResultDTO resultSSGS = this.GetVacationSSGS();
                if (!resultSSGS.Success)
                    return resultSSGS;
                result.AddChild(resultSSGS);
                decimal SSGS = resultSSGS.Value;

                #endregion

                #region Result

                result.Value = SSGS;
                result.FormulaPlain = "SSGS";
                result.FormulaExtracted = String.Format("{0}", SSGS);
                result.FormulaNames = String.Format("{0}", GetParameterName("SSGD"));
                result.FormulaOrigin = "";

                AddToAlreadyCalculated(result);

                return result;

                #endregion
            }
        }

        #endregion

        #region ST (Semestertillägg)

        /// <summary>
        /// Semestertillägg
        /// </summary>
        private CalculateVacationResultDTO GetVacationST()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("ST");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            #endregion

            #region Calculate

            decimal NF = 0;
            decimal ML = 0;
            decimal SEMTP = 0;
            decimal SSG = 0;
            decimal ST = 0;

            // Check calculation type
            TermGroup_VacationGroupCalculationType calculationType = (TermGroup_VacationGroupCalculationType)vacationGroupSE.CalculationType;
            switch (calculationType)
            {
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToVacationLaw:
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToCollectiveAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_ABAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_VacationDayAddition:
                    CalculateVacationResultDTO resultML = this.GetVacationML();
                    if (!resultML.Success)
                        return resultML;
                    result.AddChild(resultML);
                    ML = resultML.Value;

                    CalculateVacationResultDTO resultSEMTP = this.GetVacationSEMTP();
                    if (!resultSEMTP.Success)
                        return resultSEMTP;
                    result.AddChild(resultSEMTP);
                    SEMTP = resultSEMTP.Value;

                    CalculateVacationResultDTO resultNF = this.GetVacationNF();
                    if (!resultNF.Success)
                        return resultNF;
                    result.AddChild(resultNF);
                    NF = resultNF.Value;

                    CalculateVacationResultDTO resultSSG;
                    if (calculationType != TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_ABAgreement)
                        resultSSG = this.GetVacationSSGS();  // Summa över intjänandeåret
                    else
                        resultSSG = this.GetVacationSSGA(); // Aktuell
                    if (!resultSSG.Success)
                        return resultSSG;
                    result.AddChild(resultSSG);
                    SSG = resultSSG.Value;

                    if (SSG != 0)
                        ST = Decimal.Multiply(Decimal.Multiply(Decimal.Multiply(ML, SEMTP), SSG), (Decimal.Divide(5, NF)));

                    break;
            }

            #endregion

            #region Result

            result.Value = ST;
            result.FormulaPlain = "ML * SEMTOP * SSG * 5 / NF";
            result.FormulaExtracted = String.Format("{0} * {1} * {2} * 5 / {3}", ML, SEMTP, SSG, NF);
            result.FormulaNames = String.Format("{0} * {1} * {2} * 5 / {3}", GetParameterName("ML"), GetParameterName("SEMTOP"), GetParameterName("SSG"), GetParameterName("NF"));
            result.FormulaOrigin = "";

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region STR (Semestertillägg rörligt)

        /// <summary>
        /// Semestertillägg rörligt
        /// </summary>
        private CalculateVacationResultDTO GetVacationSTR()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("STR");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            CalculateVacationResultDTO resultSGR = this.GetVacationSGR();
            if (!resultSGR.Success)
                return resultSGR;
            result.AddChild(resultSGR);
            decimal SGR = resultSGR.Value;

            CalculateVacationResultDTO resultSEMROP = this.GetVacationSEMROP();
            if (!resultSEMROP.Success)
                return resultSEMROP;
            result.AddChild(resultSEMROP);
            decimal SEMROP = resultSEMROP.Value;

            CalculateVacationResultDTO resultSEMRP = this.GetVacationSEMRP();
            if (!resultSEMRP.Success)
                return resultSEMRP;
            result.AddChild(resultSEMRP);
            decimal SEMRP = resultSEMRP.Value;

            #endregion

            #region Calculate

            decimal STR = 0;

            // Check calculation type
            TermGroup_VacationGroupCalculationType calculationType = (TermGroup_VacationGroupCalculationType)vacationGroupSE.CalculationType;
            switch (calculationType)
            {
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToVacationLaw:
                    #region Enligt semesterlagen

                    STR = Decimal.Multiply(SGR, SEMROP);

                    result.FormulaPlain = "SGL * SEMROP";
                    result.FormulaExtracted = String.Format("{0} * {1}", SGR, SEMROP);
                    result.FormulaNames = String.Format("{0} * {1}", GetParameterName("SGL"), GetParameterName("SEMROP"));
                    break;

                #endregion
                case TermGroup_VacationGroupCalculationType.EarningYearIsBeforeVacationYear_VacationDayAddition_AccordingToCollectiveAgreement:
                    #region Enligt kollektivavtal

                    switch ((TermGroup_VacationGroupVacationAbsenceCalculationRule)vacationGroupSE.VacationAbsenceCalculationRule)
                    {
                        case TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual:
                            #region Faktisk ersättning

                            // SGL * SEMROP
                            STR = Decimal.Multiply(SGR, SEMROP);

                            result.FormulaPlain = "SGL * SEMROP";
                            result.FormulaExtracted = String.Format("{0} * {1}", SGR, SEMROP);
                            result.FormulaNames = String.Format("{0} * {1}", GetParameterName("SGL"), GetParameterName("SEMROP"));

                            #endregion
                            break;
                        case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerDay:
                            #region Uppräkning per dag

                            // (SGL + (SGD * (SGL / SGD)) * SEMROP
                            CalculateVacationResultDTO resultSGD = this.GetVacationSGD();
                            if (!resultSGD.Success)
                                return resultSGD;
                            result.AddChild(resultSGD);
                            int SGD = (int)resultSGD.Value;
                            if (SGD != 0)
                                STR = Decimal.Multiply(Decimal.Add(SGR, Decimal.Multiply(SGD, Decimal.Divide(SGR, SGD))), SEMROP);

                            result.FormulaPlain = "(SGL + (SGD * (SGL / SGD)) * SEMROP";
                            result.FormulaExtracted = String.Format("({0} + ({1} * ({2} / {3})) * {4}", SGR, SGD, SGR, SGD, SEMROP);
                            result.FormulaNames = String.Format("({0} + ({1} * ({2} / {3})) * {4}", GetParameterName("SGL"), GetParameterName("SGD"), GetParameterName("SGL"), GetParameterName("SGD"), GetParameterName("SEMROP"));

                            #endregion
                            break;
                        case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerHour:
                            #region Uppräkning per timme

                            // (SGL + (SGF * (SGL / SGT)) * SEMROP
                            CalculateVacationResultDTO resultSGF = this.GetVacationSGF();
                            if (!resultSGF.Success)
                                return resultSGF;
                            result.AddChild(resultSGF);
                            int SGF = (int)resultSGF.Value;

                            CalculateVacationResultDTO resultSGT = this.GetVacationSGT();
                            if (!resultSGT.Success)
                                return resultSGT;
                            result.AddChild(resultSGT);
                            int SGT = (int)resultSGT.Value;
                            if (SGT != 0)
                                STR = Decimal.Multiply(Decimal.Add(SGR, Decimal.Multiply(SGF, Decimal.Divide(SGR, SGT))), SEMROP);

                            result.FormulaPlain = "(SGL + (SGF * (SGL / SGT)) * SEMROP";
                            result.FormulaExtracted = String.Format("({0} + ({1} * ({2} / {3})) * {4}", SGR, SGF, SGR, SGT, SEMROP);
                            result.FormulaNames = String.Format("({0} + ({1} * ({2} / {3})) * {4}", GetParameterName("SGL"), GetParameterName("SGF"), GetParameterName("SGL"), GetParameterName("SGT"), GetParameterName("SEMROP"));

                            #endregion
                            break;
                    }
                    break;

                #endregion
                case TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_ABAgreement:
                case TermGroup_VacationGroupCalculationType.EarningYearIsVacationYear_VacationDayAddition:
                    #region Semestertillägg/AB-avtal

                    switch ((TermGroup_VacationGroupVacationAbsenceCalculationRule)vacationGroupSE.VacationAbsenceCalculationRule)
                    {
                        case TermGroup_VacationGroupVacationAbsenceCalculationRule.Actual:
                            #region Faktisk ersättning

                            // SGL * SEMROP
                            STR = Decimal.Multiply(SGR, SEMROP);

                            result.FormulaPlain = "SGL * SEMROP";
                            result.FormulaExtracted = String.Format("{0} * {1}", SGR, SEMROP);
                            result.FormulaNames = String.Format("{0} * {1}", GetParameterName("SGL"), GetParameterName("SEMROP"));

                            #endregion
                            break;
                        case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerDay:
                        case TermGroup_VacationGroupVacationAbsenceCalculationRule.PerHour:
                            #region Uppräkning per dag/timme

                            // (SGL + SGFV) * SEMROP

                            CalculateVacationResultDTO resultSGFV = this.GetVacationSGFV();
                            if (!resultSGFV.Success)
                                return resultSGFV;
                            result.AddChild(resultSGFV);
                            decimal SGFV = resultSGFV.Value;

                            STR = Decimal.Multiply(Decimal.Add(SGR, SGFV), SEMROP);

                            result.FormulaPlain = "(SGL + SGFV) * SEMROP";
                            result.FormulaExtracted = String.Format("({0} + {1}) * {2}", SGR, SGFV, SEMROP);
                            result.FormulaNames = String.Format("({0} + {1}) * {2}", GetParameterName("SGL"), GetParameterName("SGFV"), GetParameterName("SEMROP"));

                            #endregion
                            break;
                    }
                    break;

                    #endregion
            }

            result.Value = STR;

            if ((SEMRP * 100) > 1 && result.Value != 0)
            {
                CalculateVacationResultDTO resultSTRD = this.GetVacationSTRD(STR);
                if (!resultSTRD.Success)
                    return resultSTRD;
                result.AddChild(resultSTRD);
            }
            else if ((SEMRP * 100) < 1 && SEMRP > 0)
            {
                CalculateVacationResultDTO resultSB = this.GetVacationSB();
                if (!resultSB.Success)
                    return resultSB;
                result.AddChild(resultSB);

                CalculateVacationResultDTO resultSR = this.GetVacationSR();
                if (!resultSR.Success)
                    return resultSR;
                result.AddChild(resultSR);
                int SR = (int)resultSR.Value;

                result.Value = SEMRP * SR * SGR;
                result.FormulaPlain = "SEMRP * SR * SGR";
                result.FormulaExtracted = SEMRP.ToString() + " * " + SR.ToString() + " * " + SGR.ToString();
                result.FormulaNames = GetParameterName("SEMRP") + " * " + GetParameterName("SR") + " * " + GetParameterName("SGR");


                if (result.Value != 0)
                {
                    CalculateVacationResultDTO resultSTRD = this.GetVacationSTRD(result.Value);
                    if (!resultSTRD.Success)
                        return resultSTRD;
                    result.AddChild(resultSTRD);
                }
            }

            #endregion

            #region Result

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        #region STRD (Semestertillägg rörligt per dag)

        /// <summary>
        /// Semestertillägg rörligt per dag
        /// </summary>
        private CalculateVacationResultDTO GetVacationSTRD(decimal STR = 0)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("STRD");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Formula information

            // STRD = STR / SB

            // STR      Semestertillägg rörligt
            // SB       Semester betalda dagar

            #endregion

            #region Prereq

            if (STR == 0)
            {
                CalculateVacationResultDTO resultSTR = this.GetVacationSTR();
                if (!resultSTR.Success)
                    return resultSTR;
                result.AddChild(resultSTR);
                STR = resultSTR.Value;
            }

            CalculateVacationResultDTO resultSB = this.GetVacationSB();
            if (!resultSB.Success)
                return resultSB;
            result.AddChild(resultSB);
            decimal SB = resultSB.Value;

            #endregion

            #region Calculate

            decimal STRD = decimal.Round(STR == 0 || SB == 0 ? 0 : Decimal.Divide(STR, SB), 2);

            #endregion

            #region Result

            result.FormulaPlain = "STR / SB)";
            result.FormulaExtracted = String.Format("{0} / {1}", STR, SB);
            result.FormulaNames = String.Format("{0} / {1}", GetParameterName("STR"), GetParameterName("SB"));
            result.Value = STRD;

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }
        /// <summary>
        /// Rörligt semesterbelopp per dag (sparade dagar)
        /// </summary>
        /// <param name="year"></param>
        /// <returns></returns>
        private CalculateVacationResultDTO GetVacationSTRDSavedYears(int year)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("STRDS" + Math.Abs(year).ToString());

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            var value = EmployeeManager.GetEmployeeFactor(this.employeeFactors, employee.EmployeeId, TermGroup_EmployeeFactorType.VacationVariableAmountPerDay, this.date.AddYears(year));

            result.Value = value;
            result.FormulaPlain = value.ToString();
            result.FormulaExtracted = value.ToString();
            result.FormulaNames = GetParameterName("STRDS") + $"{Math.Abs(year)}";
            result.FormulaOrigin = "Anställd";

            return result;

        }

        /// <summary>
        /// Antal sparade dagar med rörligt semestertillägg
        /// </summary>
        /// <param name="year"></param>
        /// <returns></returns>
        private CalculateVacationResultDTO GetVacationSTRADS(int year, EmployeeVacationSE employeeVacationSE)
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("STRADS" + Math.Abs(year).ToString());

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);
            if (year == 0)
                result.Value = GetVacationABD(employeeVacationSE).Value;
            if (year == -1)
                result.Value = employeeVacationSE.RemainingDaysYear1 ?? 0; // RemainingDaysVariableAllowanceYear1
            if (year == -2)
                result.Value = employeeVacationSE.RemainingDaysYear2 ?? 0;
            if (year == -3)
                result.Value = employeeVacationSE.RemainingDaysYear3 ?? 0;
            if (year == -4)
                result.Value = employeeVacationSE.RemainingDaysYear4 ?? 0;
            if (year == -5)
                result.Value = employeeVacationSE.RemainingDaysYear5 ?? 0;
            if (year == -6)
                result.Value = employeeVacationSE.RemainingDaysOverdue ?? 0;

            result.FormulaNames = GetParameterName("STRADS") + $"{Math.Abs(year)}";
            result.FormulaOrigin = "Anställd";
            return result;

        }
        #endregion

        #region STRFD (Semestertillägg rörligt förskottsdagar)
        /// <summary>
        /// Garantibelopp semesteravtal
        /// </summary>
        private CalculateVacationResultDTO GetVacationSTRFD()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("STRFD");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Check if guarantee amount is used
            if (vacationGroupSE.VacationVariablePayoutRule != (int)TermGroup_VacationGroupVacationSalaryPayoutRule.AllBeforeVacation && vacationGroupSE.VacationVariablePayoutRule != (int)TermGroup_VacationGroupVacationSalaryPayoutRule.PartlyPayoutBeforeVacation)
            {
                result.Value = 0;
                result.FormulaExtracted = "Semestertillägg rörligt förskott används ej";
                return result;
            }

            // Need ot be one day head in order for new amount to be valid at vacationyearend
            DateTime checkDate = date.AddDays(1);

            #endregion

            #region Calculate

            decimal numberOfDays = employee?.EmployeeVacationSE?.LastOrDefault()?.PaidVacationVariableAllowance ?? 0;
            var vacationVariablePayoutMonthDate = vacationGroupSE.GetActualVacationVariablePayoutMonthDate(checkDate);
            bool noValue = numberOfDays == 0;
            if (!noValue && vacationVariablePayoutMonthDate.HasValue && vacationVariablePayoutMonthDate.Value < checkDate)
                noValue = true;

            #endregion

            #region Result

            if (noValue)
            {
                result.Value = new decimal(0);
                result.FormulaPlain = "STRFD";
                result.FormulaExtracted = "0";
                result.FormulaNames = GetParameterName("STRFD");
                result.FormulaOrigin = "Anställd";
            }
            else
            {
                result.Value = numberOfDays;
                result.FormulaPlain = "STRFD";
                result.FormulaExtracted = numberOfDays.ToString();
                result.FormulaNames = GetParameterName("STRFD");
                result.FormulaOrigin = "Anställd";
            }

            AddToAlreadyCalculated(result);
            return result;

            #endregion
        }

        #endregion

        #region TL (Timlön)

        /// <summary>
        /// Timlön
        /// </summary>
        private CalculateVacationResultDTO GetVacationTL()
        {
            CalculateVacationResultDTO result = new CalculateVacationResultDTO("TL");

            if (AlreadyCalculated(result) != null)
                return AlreadyCalculated(result);

            #region Prereq

            // Get formula ID from vacation group
            int? payrollPriceFormulaId = vacationGroupSE.HourlySalaryFormulaId;
            if (!payrollPriceFormulaId.HasValue)
                return new CalculateVacationResultDTO("Formel för månadslön saknas på semesteravtal", "TL");

            #endregion

            #region Calculate

            PayrollPriceFormulaResultDTO formulaResult = this.EvaluatePayrollPriceFormula(entities, actorCompanyId, employee, employment, null, date, null, null, payrollPriceFormulaId.Value, null);

            #endregion

            #region Result

            result.Value = formulaResult.Amount;
            result.FormulaPlain = formulaResult.FormulaPlain;
            result.FormulaExtracted = formulaResult.FormulaExtracted;
            result.FormulaNames = formulaResult.FormulaNames;
            result.FormulaOrigin = formulaResult.FormulaOrigin;

            AddToAlreadyCalculated(result);

            return result;

            #endregion
        }

        #endregion

        private bool HasMoreThanLimitDaysCoherentEmployment(int limit)
        {
            int days = 0;
            DateTime? prevEmpDateTo = null;

            foreach (Employment currentEmployment in employee.GetActiveEmployments())
            {
                DateTime empDateFrom = currentEmployment.DateFrom.Value;

                if (prevEmpDateTo.HasValue && prevEmpDateTo.Value.AddDays(1) != empDateFrom)
                {
                    days = 0;
                }

                // Get employment stop date
                DateTime empDateTo = employment.DateTo ?? this.date;
                days += (int)(empDateTo - empDateFrom).TotalDays + 1;

                if (days >= limit)
                    return true;

                prevEmpDateTo = empDateTo;

            }

            return false;
        }

        #endregion
    }

    public class EvaluatePayrollPriceFormulaInputDTO
    {
        public int SysCountryId { get; set; }
        public int? ReportId { get; set; }
        public List<EmployeeGroup> EmployeeGroups { get; set; }
        public List<PayrollGroup> PayrollGroups { get; set; }
        public List<PayrollPriceType> PayrollPriceTypes { get; set; }
        public Dictionary<int, List<EmploymentPriceType>> EmploymentPriceTypesDict { get; set; }
        public List<PayrollGroupPriceType> PayrollGroupPriceTypes { get; set; }
        public List<PayrollProductPriceType> PayrollProductPriceTypes { get; set; }
        public List<PayrollProductPriceFormula> PayrollProductPriceFormulas { get; set; }
        public List<PayrollPriceFormula> PayrollPriceFormulas { get; set; }
        public List<TimePeriod> TimePeriods { get; set; }
        public List<SysPayrollPriceViewDTO> SysPayrollPriceViews { get; set; }
        public Dictionary<int, List<EmployeeFactor>> EmployeeFactorsDict { get; set; }
        public List<PayrollProduct> PayrollProducts { get; set; }
        private List<EmployeeAbsencePercentDTO> EmployeeAbsencePercents { get; set; }
        public List<PayrollProductReportSetting> PayrollProductReportSettings { get; set; }

        public EvaluatePayrollPriceFormulaInputDTO()
        {

        }

        public EmployeeAbsencePercentDTO GetEmployeeAbsencePercent(int employeeId, int productId, DateTime date)
        {
            if (this.EmployeeAbsencePercents == null)
                return null;

            date = CalendarUtility.GetBeginningOfDay(date);
            return this.EmployeeAbsencePercents.FirstOrDefault(i => i.EmployeeId == employeeId && i.ProductId == productId && i.Date == date && !i.IsDirty);
        }

        public EmployeeAbsencePercentDTO GetEmployeeAbsencePercent(int employeeId, DateTime date, int? sysPayrollTypeLevel1 = null, int? sysPayrollTypeLevel2 = null, int? sysPayrollTypeLevel3 = null)
        {
            if (this.EmployeeAbsencePercents == null)
                return null;

            date = CalendarUtility.GetBeginningOfDay(date);
            return this.EmployeeAbsencePercents.FirstOrDefault(i => i.EmployeeId == employeeId && i.SysPayrollTypeLevel1 == sysPayrollTypeLevel1 && i.SysPayrollTypeLevel2 == sysPayrollTypeLevel2 && i.SysPayrollTypeLevel3 == sysPayrollTypeLevel3 && i.Date == date && !i.IsDirty);
        }

        public decimal GetEmployeeAbsencePercentValue(int employeeId, DateTime date, int? sysPayrollTypeLevel1 = null, int? sysPayrollTypeLevel2 = null, int? sysPayrollTypeLevel3 = null)
        {
            return GetEmployeeAbsencePercent(employeeId, date, sysPayrollTypeLevel1, sysPayrollTypeLevel2, sysPayrollTypeLevel3)?.Percent ?? 0;
        }

        public bool ContainsEmployeeAbsencePercent(int employeeId, int productId, DateTime date)
        {
            return GetEmployeeAbsencePercent(employeeId, productId, date) != null;
        }

        public bool ContainsEmployeeAbsencePercent(int employeeId, DateTime date, int? sysPayrollTypeLevel1 = null, int? sysPayrollTypeLevel2 = null, int? sysPayrollTypeLevel3 = null)
        {
            return GetEmployeeAbsencePercent(employeeId, date, sysPayrollTypeLevel1, sysPayrollTypeLevel2, sysPayrollTypeLevel3) != null;
        }

        public void AddEmployeeAbsencePercent(int employeeId, int productId, DateTime date, decimal percent, int? sysPayrollTypeLevel1 = null, int? sysPayrollTypeLevel2 = null, int? sysPayrollTypeLevel3 = null)
        {
            if (this.EmployeeAbsencePercents == null)
                this.EmployeeAbsencePercents = new List<EmployeeAbsencePercentDTO>();
            this.EmployeeAbsencePercents.Add(new EmployeeAbsencePercentDTO(employeeId, productId, date, percent, sysPayrollTypeLevel1, sysPayrollTypeLevel2, sysPayrollTypeLevel3));
        }

        public void SetDayAsDirty(int employeeId, DateTime date)
        {
            if (this.EmployeeAbsencePercents == null)
                return;

            date = CalendarUtility.GetBeginningOfDay(date);
            foreach (var item in this.EmployeeAbsencePercents.Where(i => i.EmployeeId == employeeId && i.Date == date))
            {
                item.SetAsDirty();
            }
        }

        public List<EmployeeFactor> GetEmployeeFactors(int employeeId)
        {
            return this.EmployeeFactorsDict != null && this.EmployeeFactorsDict.ContainsKey(employeeId) ? this.EmployeeFactorsDict.GetValue(employeeId) : null;
        }
    }

    public class EmployeeAbsencePercentDTO
    {
        public int EmployeeId { get; set; }
        public int ProductId { get; set; }
        public DateTime Date { get; set; }
        public decimal Percent { get; set; }

        public int? SysPayrollTypeLevel1 { get; set; }
        public int? SysPayrollTypeLevel2 { get; set; }
        public int? SysPayrollTypeLevel3 { get; set; }
        public int? SysPayrollTypeLevel4 { get; set; }

        public EmployeeAbsencePercentDTO(int employeeId, int productId, DateTime date, decimal percent, int? sysPayrollTypeLevel1 = null, int? sysPayrollTypeLevel2 = null, int? sysPayrollTypeLevel3 = null, int? sysPayrollTypeLevel4 = null)
        {
            this.EmployeeId = employeeId;
            this.ProductId = productId;
            this.Date = date;
            this.Percent = percent;
            this.isDirty = false;
            this.SysPayrollTypeLevel1 = sysPayrollTypeLevel1;
            this.SysPayrollTypeLevel2 = sysPayrollTypeLevel2;
            this.SysPayrollTypeLevel3 = sysPayrollTypeLevel3;
            this.SysPayrollTypeLevel4 = sysPayrollTypeLevel4;
        }

        private bool isDirty;
        public bool IsDirty
        {
            get
            {
                return this.isDirty;
            }
        }
        public void SetAsDirty()
        {
            this.isDirty = true;
        }
    }
}
